/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/auth/analytics/AuthStatsCollector.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/auth/analytics/AuthStatsCollector.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AuthStatsCollector: () => (/* binding */ AuthStatsCollector)
/* harmony export */ });
/* harmony import */ var _core_analytics_RegistrationStatsCollector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/analytics/RegistrationStatsCollector.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/analytics/RegistrationStatsCollector.js");
/* harmony import */ var _core_analytics_types_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/analytics/types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/analytics/types.js");
/* harmony import */ var _core_analytics_ProductionStatsCollector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/analytics/ProductionStatsCollector.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/analytics/ProductionStatsCollector.js");
/* harmony import */ var _core_analytics_ActionStatsCollector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/analytics/ActionStatsCollector.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/analytics/ActionStatsCollector.js");





class AuthStatsCollector {
    registrationStatsCollector;
    uniqueSessionId;
    constructor(config){
        const productStatsCollector = new _core_analytics_ProductionStatsCollector_js__WEBPACK_IMPORTED_MODULE_0__.ProductionStatsCollector(config);
        const actionStatsCollector = new _core_analytics_ActionStatsCollector_js__WEBPACK_IMPORTED_MODULE_1__.ActionStatsCollector(productStatsCollector);
        this.registrationStatsCollector = new _core_analytics_RegistrationStatsCollector_js__WEBPACK_IMPORTED_MODULE_2__.RegistrationStatsCollector(actionStatsCollector);
    }
    setUniqueSessionId(id) {
        this.uniqueSessionId = id;
    }
    getFields() {
        const fields = [
            {
                name: 'sdk_type',
                value: 'vkid'
            }
        ];
        if (this.uniqueSessionId) {
            fields.push({
                name: 'unique_session_id',
                value: this.uniqueSessionId
            });
        }
        return fields;
    }
    sendCustomAuthStart(provider) {
        const fields = this.getFields();
        if (provider) {
            fields.push({
                name: 'oauth_service',
                value: provider
            });
        }
        return this.registrationStatsCollector.logEvent(_core_analytics_types_js__WEBPACK_IMPORTED_MODULE_3__.ProductionStatsEventScreen.NOWHERE, {
            event_type: 'custom_auth_start',
            fields
        });
    }
}




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/auth/auth.js":
/*!**********************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/auth/auth.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Auth: () => (/* binding */ Auth)
/* harmony export */ });
/* harmony import */ var _lib_vkontakte_vkjs_lib_es6_querystring_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./../lib/@vkontakte/vkjs/lib/es6/querystring.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/lib/@vkontakte/vkjs/lib/es6/querystring.js");
/* harmony import */ var _analytics_AuthStatsCollector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./analytics/AuthStatsCollector.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/auth/analytics/AuthStatsCollector.js");
/* harmony import */ var _authDataService_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./authDataService.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/auth/authDataService.js");
/* harmony import */ var _core_config_types_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/config/types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/config/types.js");
/* harmony import */ var _utils_cookie_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/cookie.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/utils/cookie.js");
/* harmony import */ var _utils_domain_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/domain.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/utils/domain.js");
/* harmony import */ var _utils_oauth_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utils/oauth.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/utils/oauth.js");
/* harmony import */ var _utils_url_url_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../utils/url/url.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/utils/url/url.js");
/* harmony import */ var _utils_uuid_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/uuid.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/utils/uuid.js");
/* harmony import */ var _widgets_oauthList_types_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../widgets/oauthList/types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oauthList/types.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/auth/constants.js");
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/auth/types.js");

















const CODE_CHALLENGE_METHOD = 's256';
class Auth {
    /**
   * @ignore
   */ static config;
    dataService;
    opener;
    interval;
    id = (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_0__.uuid)();
    analytics;
    state;
    constructor(){
        this.analytics = new _analytics_AuthStatsCollector_js__WEBPACK_IMPORTED_MODULE_1__.AuthStatsCollector(Auth.config);
    }
    close = ()=>{
        this.opener && this.opener.close();
    };
    handleMessage = ({ origin, source, data })=>{
        if (source !== this.opener || !this.opener || !(0,_utils_domain_js__WEBPACK_IMPORTED_MODULE_2__.isDomainAllowed)(origin)) {
            return;
        }
        this.unsubscribe();
        if (data.payload.error) {
            this.dataService.sendAuthorizationFailed(data.payload.error);
            return;
        }
        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
        if (data.action === _constants_js__WEBPACK_IMPORTED_MODULE_3__.OAUTH2_RESPONSE + this.state) {
            if (this.state !== data.payload.state) {
                this.dataService.sendStateMismatchError();
            } else {
                (0,_utils_cookie_js__WEBPACK_IMPORTED_MODULE_4__.setExtIdCookie)(data.payload.ext_id);
                delete data.payload.ext_id;
                // Сбрасываем после проверки
                (0,_utils_cookie_js__WEBPACK_IMPORTED_MODULE_4__.clearStateCookie)();
                this.state = '';
                const { responseMode } = Auth.config.get();
                if (responseMode === _core_config_types_js__WEBPACK_IMPORTED_MODULE_5__.ConfigResponseMode.Redirect) {
                    this.redirectWithPayload(data.payload);
                    this.close();
                } else {
                    this.dataService.sendSuccessData(data.payload);
                }
            }
            return;
        }
        this.dataService.sendEventNotSupported();
    };
    handleInterval = ()=>{
        if (this.opener?.closed) {
            this.unsubscribe();
            this.dataService.sendNewTabHasBeenClosed();
        }
    };
    subscribe = ()=>{
        this.interval = window.setInterval(this.handleInterval, 1000);
        window.addEventListener('message', this.handleMessage);
        this.dataService.removeCallback();
    };
    unsubscribe = ()=>{
        window.removeEventListener('message', this.handleMessage);
        clearInterval(this.interval);
        this.dataService.setCallback(this.close);
    };
    loginInNewTab = (url)=>{
        const opener = window.open(url, '_blank');
        return this.handleWindowOpen(opener);
    };
    loginInNewWindow = (url)=>{
        const width = 800;
        const height = 800;
        const top = screen.height / 2 - height / 2;
        const left = screen.width / 2 - width / 2;
        const windowFeatures = `top=${top},left=${left},width=${width},height=${height},location`;
        const opener = window.open(url, '_blank', windowFeatures);
        return this.handleWindowOpen(opener);
    };
    handleWindowOpen = (opener)=>{
        this.dataService = new _authDataService_js__WEBPACK_IMPORTED_MODULE_6__.AuthDataService();
        this.opener = opener;
        if (this.opener) {
            this.subscribe();
        } else {
            this.dataService.sendCannotCreateNewTab();
        }
        return this.dataService.value;
    };
    loginByRedirect = (url)=>{
        location.assign(url);
        return Promise.resolve();
    };
    login = (params)=>{
        const config = Auth.config.get();
        const { scope, app, codeChallenge, prompt } = config;
        const flowSource = params?.statsFlowSource || _types_js__WEBPACK_IMPORTED_MODULE_7__.AuthStatsFlowSource.AUTH;
        const sessionId = params?.uniqueSessionId || this.id;
        if (flowSource === _types_js__WEBPACK_IMPORTED_MODULE_7__.AuthStatsFlowSource.AUTH) {
            this.analytics.setUniqueSessionId(sessionId);
        }
        (0,_utils_cookie_js__WEBPACK_IMPORTED_MODULE_4__.codeVerifier)(config.codeVerifier);
        this.state = (0,_utils_cookie_js__WEBPACK_IMPORTED_MODULE_4__.state)(config.state);
        const authorizePrompt = [
            ...prompt
        ];
        // Если открыто из 3-в-1, добавляем login в начало
        const hasProvider = Object.values(_widgets_oauthList_types_js__WEBPACK_IMPORTED_MODULE_8__.ExternalOAuthName).includes(params?.provider);
        if (hasProvider) {
            authorizePrompt.unshift(_core_config_types_js__WEBPACK_IMPORTED_MODULE_5__.Prompt.Login);
        }
        const queryParams = {
            lang_id: params?.lang,
            scheme: params?.scheme,
            code_challenge: codeChallenge || (0,_utils_oauth_js__WEBPACK_IMPORTED_MODULE_9__.generateCodeChallenge)((0,_utils_cookie_js__WEBPACK_IMPORTED_MODULE_4__.codeVerifier)()),
            code_challenge_method: CODE_CHALLENGE_METHOD,
            client_id: app,
            response_type: _constants_js__WEBPACK_IMPORTED_MODULE_3__.OAUTH2_RESPONSE_TYPE,
            scope,
            state: this.state,
            provider: params?.provider,
            prompt: authorizePrompt.join(' ').trim(),
            stats_info: (0,_utils_url_url_js__WEBPACK_IMPORTED_MODULE_10__.encodeStatsInfo)({
                flow_source: flowSource,
                session_id: sessionId
            })
        };
        if (config.mode !== _core_config_types_js__WEBPACK_IMPORTED_MODULE_5__.ConfigAuthMode.Redirect) {
            if (flowSource === _types_js__WEBPACK_IMPORTED_MODULE_7__.AuthStatsFlowSource.AUTH) {
                void this.analytics.sendCustomAuthStart(params?.provider);
            }
            queryParams.origin = location.protocol + '//' + location.hostname;
        }
        let url = (0,_utils_url_url_js__WEBPACK_IMPORTED_MODULE_10__.getVKIDUrl)('authorize', queryParams, config);
        if (params?.screen) {
            Object.assign(queryParams, {
                oauth_version: 2,
                screen: params?.screen,
                redirect_state: this.state
            });
            url = (0,_utils_url_url_js__WEBPACK_IMPORTED_MODULE_10__.getVKIDUrl)('auth', queryParams, config);
        }
        switch(config.mode){
            case _core_config_types_js__WEBPACK_IMPORTED_MODULE_5__.ConfigAuthMode.InNewWindow:
                return this.loginInNewWindow(url);
            case _core_config_types_js__WEBPACK_IMPORTED_MODULE_5__.ConfigAuthMode.InNewTab:
                return this.loginInNewTab(url);
            default:
                {
                    if (flowSource === _types_js__WEBPACK_IMPORTED_MODULE_7__.AuthStatsFlowSource.AUTH) {
                        return this.analytics.sendCustomAuthStart(params?.provider).finally(()=>{
                            void this.loginByRedirect(url);
                        });
                    }
                    return this.loginByRedirect(url);
                }
        }
    };
    checkState(stateToCheck) {
        if (this.state !== stateToCheck) {
            return {
                code: _types_js__WEBPACK_IMPORTED_MODULE_7__.AuthErrorCode.StateMismatch,
                error: _constants_js__WEBPACK_IMPORTED_MODULE_3__.AUTH_ERROR_TEXT[_types_js__WEBPACK_IMPORTED_MODULE_7__.AuthErrorCode.StateMismatch],
                state: stateToCheck
            };
        }
        (0,_utils_cookie_js__WEBPACK_IMPORTED_MODULE_4__.clearStateCookie)();
        this.state = '';
    }
    exchangeCode(code, deviceId) {
        const config = Auth.config.get();
        this.state = (0,_utils_cookie_js__WEBPACK_IMPORTED_MODULE_4__.state)(config.state);
        const queryParams = {
            grant_type: 'authorization_code',
            redirect_uri: config.redirectUrl,
            client_id: config.app,
            code_verifier: (0,_utils_cookie_js__WEBPACK_IMPORTED_MODULE_4__.codeVerifier)(),
            state: this.state,
            device_id: deviceId
        };
        const queryParamsString = _lib_vkontakte_vkjs_lib_es6_querystring_js__WEBPACK_IMPORTED_MODULE_11__.querystring.stringify(queryParams);
        return fetch(`https://${config.__vkidDomain}/oauth2/auth?${queryParamsString}`, {
            method: 'POST',
            body: new URLSearchParams({
                code
            })
        }).then((res)=>this.oauthSectionFetchHandler(res)).then((res)=>{
            const checkStateError = this.checkState(res.state);
            if (checkStateError) {
                throw checkStateError;
            }
            // Сбрасываем динамические параметры после обмена кода
            (0,_utils_cookie_js__WEBPACK_IMPORTED_MODULE_4__.clearCodeVerifierCookie)();
            return res;
        });
    }
    refreshToken(refreshToken, deviceId) {
        const config = Auth.config.get();
        this.state = (0,_utils_cookie_js__WEBPACK_IMPORTED_MODULE_4__.state)(config.state);
        const queryParams = {
            grant_type: 'refresh_token',
            redirect_uri: config.redirectUrl,
            client_id: config.app,
            device_id: deviceId,
            state: this.state
        };
        const queryParamsString = _lib_vkontakte_vkjs_lib_es6_querystring_js__WEBPACK_IMPORTED_MODULE_11__.querystring.stringify(queryParams);
        return fetch(`https://${config.__vkidDomain}/oauth2/auth?${queryParamsString}`, {
            method: 'POST',
            body: new URLSearchParams({
                refresh_token: refreshToken
            })
        }).then((res)=>this.oauthSectionFetchHandler(res)).then((res)=>{
            const checkStateError = this.checkState(res.state);
            if (checkStateError) {
                throw checkStateError;
            }
            Auth.config.update({
                state: config.state
            });
            return res;
        });
    }
    logout(accessToken) {
        const config = Auth.config.get();
        const queryParams = {
            client_id: config.app
        };
        const queryParamsString = _lib_vkontakte_vkjs_lib_es6_querystring_js__WEBPACK_IMPORTED_MODULE_11__.querystring.stringify(queryParams);
        return fetch(`https://${config.__vkidDomain}/oauth2/logout?${queryParamsString}`, {
            method: 'POST',
            body: new URLSearchParams({
                access_token: accessToken
            })
        }).then((res)=>this.oauthSectionFetchHandler(res));
    }
    userInfo(accessToken) {
        const config = Auth.config.get();
        const queryParams = {
            client_id: config.app
        };
        const queryParamsString = _lib_vkontakte_vkjs_lib_es6_querystring_js__WEBPACK_IMPORTED_MODULE_11__.querystring.stringify(queryParams);
        return fetch(`https://${config.__vkidDomain}/oauth2/user_info?${queryParamsString}`, {
            method: 'POST',
            body: new URLSearchParams({
                access_token: accessToken
            })
        }).then((res)=>this.oauthSectionFetchHandler(res));
    }
    publicInfo(idToken) {
        const config = Auth.config.get();
        const queryParams = {
            client_id: config.app
        };
        const queryParamsString = _lib_vkontakte_vkjs_lib_es6_querystring_js__WEBPACK_IMPORTED_MODULE_11__.querystring.stringify(queryParams);
        return fetch(`https://${config.__vkidDomain}/oauth2/public_info?${queryParamsString}`, {
            method: 'POST',
            body: new URLSearchParams({
                id_token: idToken
            })
        }).then((res)=>this.oauthSectionFetchHandler(res));
    }
    oauthSectionFetchHandler(res) {
        return res.json().then((resJson)=>{
            if ('error' in resJson) {
                throw resJson;
            }
            return resJson;
        });
    }
    redirectWithPayload(payload) {
        location.assign((0,_utils_url_url_js__WEBPACK_IMPORTED_MODULE_10__.getRedirectWithPayloadUrl)(payload, Auth.config));
    }
}




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/auth/authDataService.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/auth/authDataService.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AuthDataService: () => (/* binding */ AuthDataService)
/* harmony export */ });
/* harmony import */ var _core_dataService_dataService_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/dataService/dataService.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/dataService/dataService.js");
/* harmony import */ var _utils_cookie_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/cookie.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/utils/cookie.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/auth/constants.js");
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/auth/types.js");





class AuthDataService extends _core_dataService_dataService_js__WEBPACK_IMPORTED_MODULE_0__.DataService {
    state = (0,_utils_cookie_js__WEBPACK_IMPORTED_MODULE_1__.state)();
    sendSuccessData = (payload)=>{
        this.sendSuccess({
            type: payload.type,
            code: payload.code,
            state: payload.state,
            device_id: payload.device_id,
            expires_in: payload.expires_in,
            ext_id: payload.ext_id
        });
    };
    sendNewTabHasBeenClosed = ()=>{
        this.sendError({
            code: _types_js__WEBPACK_IMPORTED_MODULE_2__.AuthErrorCode.NewTabHasBeenClosed,
            error: _constants_js__WEBPACK_IMPORTED_MODULE_3__.AUTH_ERROR_TEXT[_types_js__WEBPACK_IMPORTED_MODULE_2__.AuthErrorCode.NewTabHasBeenClosed],
            state: this.state
        });
    };
    // TODO: Типизировать details
    sendAuthorizationFailed = (details)=>{
        this.sendError({
            code: _types_js__WEBPACK_IMPORTED_MODULE_2__.AuthErrorCode.AuthorizationFailed,
            error: _constants_js__WEBPACK_IMPORTED_MODULE_3__.AUTH_ERROR_TEXT[_types_js__WEBPACK_IMPORTED_MODULE_2__.AuthErrorCode.AuthorizationFailed],
            error_description: JSON.stringify(details),
            state: this.state
        });
    };
    sendEventNotSupported = ()=>{
        this.sendError({
            code: _types_js__WEBPACK_IMPORTED_MODULE_2__.AuthErrorCode.EventNotSupported,
            error: _constants_js__WEBPACK_IMPORTED_MODULE_3__.AUTH_ERROR_TEXT[_types_js__WEBPACK_IMPORTED_MODULE_2__.AuthErrorCode.EventNotSupported],
            state: this.state
        });
    };
    sendCannotCreateNewTab = ()=>{
        this.sendError({
            code: _types_js__WEBPACK_IMPORTED_MODULE_2__.AuthErrorCode.CannotCreateNewTab,
            error: _constants_js__WEBPACK_IMPORTED_MODULE_3__.AUTH_ERROR_TEXT[_types_js__WEBPACK_IMPORTED_MODULE_2__.AuthErrorCode.CannotCreateNewTab],
            state: this.state
        });
    };
    sendStateMismatchError = ()=>{
        this.sendError({
            code: _types_js__WEBPACK_IMPORTED_MODULE_2__.AuthErrorCode.StateMismatch,
            error: _constants_js__WEBPACK_IMPORTED_MODULE_3__.AUTH_ERROR_TEXT[_types_js__WEBPACK_IMPORTED_MODULE_2__.AuthErrorCode.StateMismatch],
            state: this.state
        });
    };
}




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/auth/constants.js":
/*!***************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/auth/constants.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AUTH_ERROR_TEXT: () => (/* binding */ AUTH_ERROR_TEXT),
/* harmony export */   OAUTH2_RESPONSE: () => (/* binding */ OAUTH2_RESPONSE),
/* harmony export */   OAUTH2_RESPONSE_TYPE: () => (/* binding */ OAUTH2_RESPONSE_TYPE)
/* harmony export */ });
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/auth/types.js");


const OAUTH2_RESPONSE_TYPE = 'code';
const AUTH_ERROR_TEXT = {
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.AuthErrorCode.EventNotSupported]: 'Event is not supported',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.AuthErrorCode.CannotCreateNewTab]: 'Cannot create new tab. Try checking your browser settings',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.AuthErrorCode.NewTabHasBeenClosed]: 'New tab has been closed',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.AuthErrorCode.AuthorizationFailed]: 'Authorization failed with an error',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.AuthErrorCode.StateMismatch]: 'The received state does not match the expected state'
};
const OAUTH2_RESPONSE = 'oauth2_authorize_response';




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/auth/types.js":
/*!***********************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/auth/types.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AuthErrorCode: () => (/* binding */ AuthErrorCode),
/* harmony export */   AuthStatsFlowSource: () => (/* binding */ AuthStatsFlowSource)
/* harmony export */ });
var AuthStatsFlowSource;
(function(AuthStatsFlowSource) {
    AuthStatsFlowSource["AUTH"] = 'from_custom_auth';
    AuthStatsFlowSource["BUTTON_ONE_TAP"] = 'from_one_tap';
    AuthStatsFlowSource["FLOATING_ONE_TAP"] = 'from_floating_one_tap';
    AuthStatsFlowSource["MULTIBRANDING"] = 'from_multibranding';
})(AuthStatsFlowSource || (AuthStatsFlowSource = {}));
var AuthErrorCode;
(function(AuthErrorCode) {
    AuthErrorCode[AuthErrorCode[/**
   * Неизвестное событие
   */ "EventNotSupported"] = 100] = "EventNotSupported";
    AuthErrorCode[AuthErrorCode[/**
   * Новая вкладка не создалась
   */ "CannotCreateNewTab"] = 101] = "CannotCreateNewTab";
    AuthErrorCode[AuthErrorCode[/**
   * Новая вкладка была закрыта
   */ "NewTabHasBeenClosed"] = 102] = "NewTabHasBeenClosed";
    AuthErrorCode[AuthErrorCode[/**
   * Авторизация завершилась ошибкой
   */ "AuthorizationFailed"] = 103] = "AuthorizationFailed";
    AuthErrorCode[AuthErrorCode[/**
   * Проверка стейта завершилась с ошибкой
   */ "StateMismatch"] = 104] = "StateMismatch";
})(AuthErrorCode || (AuthErrorCode = {}));




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/constants.js":
/*!**********************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/constants.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   COOKIE_EXPIRES_TIME_15_MIN: () => (/* binding */ COOKIE_EXPIRES_TIME_15_MIN),
/* harmony export */   DOMAIN: () => (/* binding */ DOMAIN),
/* harmony export */   LOGIN_DOMAIN: () => (/* binding */ LOGIN_DOMAIN),
/* harmony export */   OAUTH_DOMAIN: () => (/* binding */ OAUTH_DOMAIN),
/* harmony export */   VERSION: () => (/* binding */ VERSION),
/* harmony export */   VKID_DOMAIN: () => (/* binding */ VKID_DOMAIN)
/* harmony export */ });
// @ts-ignore-next-line пробрасываем версию из package.json в rollup.config
const VERSION = "2.4.0";
// @ts-ignore-next-line пробрасываем тип сборки из rollup.config
const DOMAIN = 'vk.com';
const LOGIN_DOMAIN = `login.${DOMAIN}`;
const OAUTH_DOMAIN = `oauth.${DOMAIN}`;
const VKID_DOMAIN = `id.${DOMAIN}`;
const COOKIE_EXPIRES_TIME_15_MIN = 900_000;




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/core/analytics/ActionStatsCollector.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/core/analytics/ActionStatsCollector.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ActionStatsCollector: () => (/* binding */ ActionStatsCollector)
/* harmony export */ });
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/analytics/types.js");


class ActionStatsCollector {
    productStatsCollector;
    constructor(productStatsCollector){
        this.productStatsCollector = productStatsCollector;
    }
    logEvent(params) {
        const statsEvent = {
            ...this.productStatsCollector.getBaseEvent(params.screen),
            type: _types_js__WEBPACK_IMPORTED_MODULE_0__.ProductionStatsEventTypes.TYPE_ACTION,
            [_types_js__WEBPACK_IMPORTED_MODULE_0__.ProductionStatsEventTypes.TYPE_ACTION]: params.event
        };
        return this.productStatsCollector.logEvent(statsEvent);
    }
}




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/core/analytics/ProductionStatsCollector.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/core/analytics/ProductionStatsCollector.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ProductionStatsCollector: () => (/* binding */ ProductionStatsCollector)
/* harmony export */ });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../constants.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/constants.js");
/* harmony import */ var _utils_request_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/request.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/utils/request.js");



class ProductionStatsCollector {
    static MAX_INT32 = 2147483647;
    timeoutId = null;
    lastEvent;
    config;
    stackEvents = [];
    constructor(config){
        this.config = config;
    }
    getIntId() {
        return Math.floor(Math.random() * ProductionStatsCollector.MAX_INT32);
    }
    getCurrentTime(isMicrosec = true) {
        const strTime = Date.now().toString(10);
        if (isMicrosec) {
            return strTime + '000';
        }
        return strTime;
    }
    sendStats(event) {
        this.stackEvents.push(event);
        this.timeoutId && window.clearTimeout(this.timeoutId);
        return new Promise((res, rej)=>{
            this.timeoutId = window.setTimeout(()=>{
                const params = {
                    events: JSON.stringify(this.stackEvents),
                    sak_version: _constants_js__WEBPACK_IMPORTED_MODULE_0__.VERSION
                };
                this.stackEvents = [];
                const url = (0,_utils_request_js__WEBPACK_IMPORTED_MODULE_1__.getStatsUrl)('stat_events_vkid_sdk', this.config);
                (0,_utils_request_js__WEBPACK_IMPORTED_MODULE_1__.request)(url, params).then(res).catch(rej);
            }, 0);
        });
    }
    getBaseEvent(screen) {
        return {
            id: this.getIntId(),
            prev_event_id: this.lastEvent?.id || 0,
            prev_nav_id: 0,
            timestamp: this.getCurrentTime(),
            url: window.location.href,
            screen
        };
    }
    logEvent(event) {
        this.lastEvent = event;
        return this.sendStats(event);
    }
}




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/core/analytics/RegistrationStatsCollector.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/core/analytics/RegistrationStatsCollector.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RegistrationStatsCollector: () => (/* binding */ RegistrationStatsCollector)
/* harmony export */ });
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/analytics/types.js");


class RegistrationStatsCollector {
    actionStatsCollector;
    constructor(actionStatsCollector){
        this.actionStatsCollector = actionStatsCollector;
    }
    logEvent(screen, event) {
        const statsEvent = {
            type: _types_js__WEBPACK_IMPORTED_MODULE_0__.ProductionStatsTypeActions.TYPE_REGISTRATION_ITEM,
            [_types_js__WEBPACK_IMPORTED_MODULE_0__.ProductionStatsTypeActions.TYPE_REGISTRATION_ITEM]: event
        };
        return this.actionStatsCollector.logEvent({
            screen,
            event: statsEvent
        });
    }
}




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/core/analytics/SakSessionStatsCollector.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/core/analytics/SakSessionStatsCollector.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SakSessionStatsCollector: () => (/* binding */ SakSessionStatsCollector)
/* harmony export */ });
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/analytics/types.js");


class SakSessionStatsCollector {
    actionStatsCollector;
    constructor(actionStatsCollector){
        this.actionStatsCollector = actionStatsCollector;
    }
    logEvent(event) {
        const statsEvent = {
            type: _types_js__WEBPACK_IMPORTED_MODULE_0__.ProductionStatsTypeActions.TYPE_SAK_SESSION_EVENT_ITEM,
            [_types_js__WEBPACK_IMPORTED_MODULE_0__.ProductionStatsTypeActions.TYPE_SAK_SESSION_EVENT_ITEM]: event
        };
        return this.actionStatsCollector.logEvent({
            screen: _types_js__WEBPACK_IMPORTED_MODULE_0__.ProductionStatsEventScreen.NOWHERE,
            event: statsEvent
        });
    }
    sendSdkInit(additionalInfo) {
        void this.logEvent({
            step: 'vkid_sdk_init',
            additional_info: additionalInfo
        });
    }
}




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/core/analytics/types.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/core/analytics/types.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ProductionStatsEventScreen: () => (/* binding */ ProductionStatsEventScreen),
/* harmony export */   ProductionStatsEventTypes: () => (/* binding */ ProductionStatsEventTypes),
/* harmony export */   ProductionStatsTypeActions: () => (/* binding */ ProductionStatsTypeActions)
/* harmony export */ });
var ProductionStatsEventTypes;
(function(ProductionStatsEventTypes) {
    ProductionStatsEventTypes["TYPE_ACTION"] = 'type_action';
})(ProductionStatsEventTypes || (ProductionStatsEventTypes = {}));
var ProductionStatsTypeActions;
(function(ProductionStatsTypeActions) {
    ProductionStatsTypeActions["TYPE_REGISTRATION_ITEM"] = 'type_registration_item';
    ProductionStatsTypeActions["TYPE_SAK_SESSION_EVENT_ITEM"] = 'type_sak_sessions_event_item';
})(ProductionStatsTypeActions || (ProductionStatsTypeActions = {}));
var ProductionStatsEventScreen;
(function(ProductionStatsEventScreen) {
    ProductionStatsEventScreen["NOWHERE"] = 'nowhere';
    ProductionStatsEventScreen["FLOATING_ONE_TAP"] = 'floating_one_tap';
    ProductionStatsEventScreen["MULTIBRANDING"] = 'multibranding_widget';
})(ProductionStatsEventScreen || (ProductionStatsEventScreen = {}));




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/core/bridge/bridge.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/core/bridge/bridge.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BRIDGE_MESSAGE_TYPE_SDK: () => (/* binding */ BRIDGE_MESSAGE_TYPE_SDK),
/* harmony export */   Bridge: () => (/* binding */ Bridge)
/* harmony export */ });
/* harmony import */ var _dispatcher_dispatcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dispatcher/dispatcher.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/dispatcher/dispatcher.js");
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/bridge/types.js");



const BRIDGE_MESSAGE_TYPE_SDK = 'vk-sak-sdk';
class Bridge extends _dispatcher_dispatcher_js__WEBPACK_IMPORTED_MODULE_0__.Dispatcher {
    config;
    constructor(config){
        super();
        this.config = config;
        this.handleMessage = this.handleMessage.bind(this);
        // eslint-disable-next-line
        window.addEventListener('message', this.handleMessage);
    }
    destroy() {
        /* Clear references for memory */ // @ts-ignore-next-line Удаление происходит при десктруктуризации бриджа, поэтому это безопасно.
        delete this.config;
        // eslint-disable-next-line
        window.removeEventListener('message', this.handleMessage);
    }
    sendMessage(message) {
        this.config.iframe.contentWindow?.postMessage({
            type: BRIDGE_MESSAGE_TYPE_SDK,
            ...message
        }, this.config.origin);
    }
    handleMessage(event) {
        const isUnsupportedMessage = !this.config.origin || event.origin !== this.config.origin || event.source !== this.config.iframe.contentWindow || event.data?.type !== BRIDGE_MESSAGE_TYPE_SDK;
        if (isUnsupportedMessage) {
            this.events.emit(_types_js__WEBPACK_IMPORTED_MODULE_1__.BridgeEvents.UNSUPPORTED_MESSAGE, event.data);
            return;
        }
        this.events.emit(_types_js__WEBPACK_IMPORTED_MODULE_1__.BridgeEvents.MESSAGE, event.data);
    }
}




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/core/bridge/types.js":
/*!******************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/core/bridge/types.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BridgeEvents: () => (/* binding */ BridgeEvents)
/* harmony export */ });
var BridgeEvents;
(function(BridgeEvents) {
    BridgeEvents["MESSAGE"] = 'message';
    BridgeEvents["UNSUPPORTED_MESSAGE"] = 'unsupported_message';
})(BridgeEvents || (BridgeEvents = {}));




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/core/config/config.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/core/config/config.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Config: () => (/* binding */ Config)
/* harmony export */ });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../constants.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/constants.js");
/* harmony import */ var _analytics_SakSessionStatsCollector_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../analytics/SakSessionStatsCollector.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/analytics/SakSessionStatsCollector.js");
/* harmony import */ var _analytics_ProductionStatsCollector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../analytics/ProductionStatsCollector.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/analytics/ProductionStatsCollector.js");
/* harmony import */ var _analytics_ActionStatsCollector_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../analytics/ActionStatsCollector.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/analytics/ActionStatsCollector.js");
/* harmony import */ var _validator_validator_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../validator/validator.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/validator/validator.js");
/* harmony import */ var _validator_rules_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../validator/rules.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/validator/rules.js");
/* harmony import */ var _services_MyTrackerService_MyTrackerService_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../services/MyTrackerService/MyTrackerService.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/services/MyTrackerService/MyTrackerService.js");
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/config/types.js");










function _ts_decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}
class Config {
    sakSessionStatsCollector;
    store = {
        app: 0,
        redirectUrl: '',
        mode: _types_js__WEBPACK_IMPORTED_MODULE_0__.ConfigAuthMode.InNewTab,
        responseMode: _types_js__WEBPACK_IMPORTED_MODULE_0__.ConfigResponseMode.Redirect,
        codeVerifier: '',
        state: '',
        prompt: [
            _types_js__WEBPACK_IMPORTED_MODULE_0__.Prompt.Default
        ],
        __loginDomain: _constants_js__WEBPACK_IMPORTED_MODULE_1__.LOGIN_DOMAIN,
        __oauthDomain: _constants_js__WEBPACK_IMPORTED_MODULE_1__.OAUTH_DOMAIN,
        __vkidDomain: _constants_js__WEBPACK_IMPORTED_MODULE_1__.VKID_DOMAIN
    };
    myTrackerService;
    constructor(){
        const productStatsCollector = new _analytics_ProductionStatsCollector_js__WEBPACK_IMPORTED_MODULE_2__.ProductionStatsCollector(this);
        const actionStatsCollector = new _analytics_ActionStatsCollector_js__WEBPACK_IMPORTED_MODULE_3__.ActionStatsCollector(productStatsCollector);
        this.sakSessionStatsCollector = new _analytics_SakSessionStatsCollector_js__WEBPACK_IMPORTED_MODULE_4__.SakSessionStatsCollector(actionStatsCollector);
        this.myTrackerService = new _services_MyTrackerService_MyTrackerService_js__WEBPACK_IMPORTED_MODULE_5__.MyTrackerService(this);
    }
    init(config) {
        this.set(config);
        this.sakSessionStatsCollector.sendSdkInit(config.source);
        this.myTrackerService.init();
        return this;
    }
    update(config) {
        return this.set(config);
    }
    set(config) {
        this.store = {
            ...this.store,
            ...config
        };
        return this;
    }
    get() {
        return this.store;
    }
}
_ts_decorate([
    (0,_validator_validator_js__WEBPACK_IMPORTED_MODULE_6__.validator)({
        app: [
            _validator_rules_js__WEBPACK_IMPORTED_MODULE_7__.isRequired,
            _validator_rules_js__WEBPACK_IMPORTED_MODULE_7__.isNumber
        ],
        redirectUrl: [
            _validator_rules_js__WEBPACK_IMPORTED_MODULE_7__.isRequired
        ]
    })
], Config.prototype, "init", null);




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/core/config/types.js":
/*!******************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/core/config/types.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ConfigAuthMode: () => (/* binding */ ConfigAuthMode),
/* harmony export */   ConfigResponseMode: () => (/* binding */ ConfigResponseMode),
/* harmony export */   ConfigSource: () => (/* binding */ ConfigSource),
/* harmony export */   Prompt: () => (/* binding */ Prompt)
/* harmony export */ });
var ConfigAuthMode;
(function(ConfigAuthMode) {
    ConfigAuthMode["Redirect"] = 'redirect';
    ConfigAuthMode["InNewTab"] = 'new_tab';
    ConfigAuthMode["InNewWindow"] = 'new_window';
})(ConfigAuthMode || (ConfigAuthMode = {}));
var ConfigResponseMode;
(function(ConfigResponseMode) {
    ConfigResponseMode["Redirect"] = 'redirect';
    ConfigResponseMode["Callback"] = 'callback';
})(ConfigResponseMode || (ConfigResponseMode = {}));
var ConfigSource;
(function(ConfigSource) {
    ConfigSource["LOWCODE"] = 'lowcode';
})(ConfigSource || (ConfigSource = {}));
var Prompt;
(function(Prompt) {
    Prompt["Default"] = '';
    Prompt["None"] = 'none';
    Prompt["Login"] = 'login';
    Prompt["Consent"] = 'consent';
    Prompt["SelectAccount"] = 'select_account';
})(Prompt || (Prompt = {}));




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/core/dataService/dataService.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/core/dataService/dataService.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DataService: () => (/* binding */ DataService)
/* harmony export */ });
class DataService {
    promise;
    callback;
    resolve;
    reject;
    constructor(){
        this.promise = new Promise((resolve, reject)=>{
            this.resolve = resolve;
            this.reject = reject;
        });
    }
    setCallback = (callback)=>{
        this.callback = callback;
    };
    removeCallback = ()=>{
        this.callback = null;
    };
    sendSuccess = (value)=>{
        this.resolve(value);
        this.callback && this.callback();
    };
    sendError = (value)=>{
        this.reject(value);
        this.callback && this.callback();
    };
    get value() {
        return this.promise;
    }
}




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/core/dispatcher/dispatcher.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/core/dispatcher/dispatcher.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Dispatcher: () => (/* binding */ Dispatcher)
/* harmony export */ });
/* harmony import */ var _lib_mitt_dist_mitt_es_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./../../lib/mitt/dist/mitt.es.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/lib/mitt/dist/mitt.es.js");


class Dispatcher {
    events = (0,_lib_mitt_dist_mitt_es_js__WEBPACK_IMPORTED_MODULE_0__["default"])();
    on(event, handler) {
        this.events.on(event, handler);
        return this;
    }
    off(event, handler) {
        this.events.off(event, handler);
        return this;
    }
}




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/core/validator/rules.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/core/validator/rules.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isNotEmptyOAuthList: () => (/* binding */ isNotEmptyOAuthList),
/* harmony export */   isNumber: () => (/* binding */ isNumber),
/* harmony export */   isRequired: () => (/* binding */ isRequired),
/* harmony export */   isValidHeight: () => (/* binding */ isValidHeight)
/* harmony export */ });
const isRequired = (param)=>{
    let result = true;
    if (typeof param === 'string' && param.trim() === '' || param === undefined || param == null) {
        result = false;
    }
    return {
        result,
        makeError: (valueName)=>`${valueName} is required parameter`
    };
};
const isNumber = (param)=>{
    return {
        result: [
            'number',
            'string'
        ].includes(typeof param) && !isNaN(parseInt(param)),
        makeError: (valueName)=>`${valueName} should be number`
    };
};
const isValidHeight = (param)=>{
    let result = param !== undefined && param.height !== undefined && isNumber(param.height) && param.height < 57 && param.height > 31 || param === undefined || param.height === undefined;
    return {
        result,
        makeError: ()=>'The height should correspond to the range from 32 to 56'
    };
};
const isNotEmptyOAuthList = (param)=>{
    return {
        result: param?.length && param.length >= 1,
        makeError: ()=>'OAuth list can\'t be empty'
    };
};




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/core/validator/validator.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/core/validator/validator.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   validator: () => (/* binding */ validator)
/* harmony export */ });
const validator = (rules)=>{
    return (target, propertyName, descriptor)=>{
        const originalMethod = descriptor.value;
        descriptor.value = function(params) {
            const rulesKeys = Object.keys(rules);
            for (let key of rulesKeys){
                const validateHandlers = rules[key];
                validateHandlers?.forEach((handler)=>{
                    const { result, makeError } = handler(params[key]);
                    if (!result) {
                        throw new Error(makeError(key));
                    }
                });
            }
            return originalMethod?.apply(this, arguments);
        };
    };
};




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/core/widget/constants.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/core/widget/constants.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WIDGET_ERROR_TEXT: () => (/* binding */ WIDGET_ERROR_TEXT)
/* harmony export */ });
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/widget/types.js");


const WIDGET_ERROR_TEXT = {
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.WidgetErrorCode.TimeoutExceeded]: 'timeout',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.WidgetErrorCode.InternalError]: 'internal error',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.WidgetErrorCode.AuthError]: 'auth error'
};




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/core/widget/events.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/core/widget/events.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WidgetEvents: () => (/* binding */ WidgetEvents)
/* harmony export */ });
var WidgetEvents;
(function(WidgetEvents) {
    WidgetEvents["START_LOAD"] = 'common: start load';
    WidgetEvents["LOAD"] = 'common: load';
    WidgetEvents["SHOW"] = 'common: show';
    WidgetEvents["HIDE"] = 'common: hide';
    WidgetEvents["CLOSE"] = 'common: close';
    WidgetEvents["ERROR"] = 'common: error';
    WidgetEvents["RESIZE"] = 'common: resize';
})(WidgetEvents || (WidgetEvents = {}));




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/core/widget/template.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/core/widget/template.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getWidgetTemplate: () => (/* binding */ getWidgetTemplate)
/* harmony export */ });
const getWidgetTemplate = (id)=>{
    return `
<div id="${id}" data-test-id="widget">
  <style>
    #${id} {
      width: 100%;
      height: 100%;
      max-width: 100%;
      max-height: 100%;
    }

    #${id} iframe {
      border: none;
      color-scheme: auto;
    }

    #${id} .loader,
    #${id} .error {
      display: none;
      width: 100%;
      height: 100%;
      text-align: center;
    }
  </style>
  <div class="loader"></div>
  <div class="error"></div>
  <iframe width="100%" height="100%"></iframe>
</div>
  `;
};




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/core/widget/types.js":
/*!******************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/core/widget/types.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WidgetErrorCode: () => (/* binding */ WidgetErrorCode),
/* harmony export */   WidgetState: () => (/* binding */ WidgetState)
/* harmony export */ });
var WidgetState;
(function(WidgetState) {
    WidgetState["LOADING"] = 'loading';
    WidgetState["LOADED"] = 'loaded';
    WidgetState["NOT_LOADED"] = 'not_loaded';
})(WidgetState || (WidgetState = {}));
var WidgetErrorCode;
(function(WidgetErrorCode) {
    WidgetErrorCode[WidgetErrorCode[/**
   * Не загрузился iframe
   */ "TimeoutExceeded"] = 0] = "TimeoutExceeded";
    WidgetErrorCode[WidgetErrorCode[/**
   * Внутренняя ошибка
   */ "InternalError"] = 1] = "InternalError";
    WidgetErrorCode[WidgetErrorCode[/**
   * Ошибка авторизации
   */ "AuthError"] = 2] = "AuthError";
})(WidgetErrorCode || (WidgetErrorCode = {}));




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/core/widget/widget.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/core/widget/widget.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Widget: () => (/* binding */ Widget)
/* harmony export */ });
/* harmony import */ var _bridge_bridge_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../bridge/bridge.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/bridge/bridge.js");
/* harmony import */ var _bridge_types_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../bridge/types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/bridge/types.js");
/* harmony import */ var _dispatcher_dispatcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dispatcher/dispatcher.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/dispatcher/dispatcher.js");
/* harmony import */ var _validator_validator_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../validator/validator.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/validator/validator.js");
/* harmony import */ var _validator_rules_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../validator/rules.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/validator/rules.js");
/* harmony import */ var _utils_url_url_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../utils/url/url.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/utils/url/url.js");
/* harmony import */ var _utils_uuid_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/uuid.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/utils/uuid.js");
/* harmony import */ var _widgets_oneTap_events_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../widgets/oneTap/events.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oneTap/events.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./constants.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/widget/constants.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./events.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/widget/events.js");
/* harmony import */ var _template_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./template.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/widget/template.js");
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/widget/types.js");













function _ts_decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}
const MODULE_LOAD_TIMEOUT = 5000;
const MODULE_CHANGE_STATE_TIMEOUT = 300;
class Widget extends _dispatcher_dispatcher_js__WEBPACK_IMPORTED_MODULE_0__.Dispatcher {
    /**
   * @ignore
   */ static config;
    /**
   * @ignore
   */ static auth;
    id = (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_1__.uuid)();
    lang;
    scheme;
    vkidAppName = '';
    config;
    timeoutTimer;
    bridge;
    container;
    templateRenderer = _template_js__WEBPACK_IMPORTED_MODULE_2__.getWidgetTemplate;
    elements;
    constructor(){
        super();
        this.config = Widget.config;
    }
    render(params) {
        const { container, ...otherParams } = params;
        this.container = container;
        this.renderTemplate();
        this.registerElements();
        if ('fastAuthDisabled' in params && params['fastAuthDisabled']) {
            this.setState(_types_js__WEBPACK_IMPORTED_MODULE_3__.WidgetState.NOT_LOADED);
            return this;
        }
        this.loadWidgetFrame(otherParams);
        return this;
    }
    close() {
        clearTimeout(this.timeoutTimer);
        this.elements?.root?.remove();
        this.bridge?.destroy();
        this.events.emit(_events_js__WEBPACK_IMPORTED_MODULE_4__.WidgetEvents.CLOSE);
    }
    show() {
        if (this.elements.root) {
            this.elements.root.style.display = 'block';
            this.events.emit(_events_js__WEBPACK_IMPORTED_MODULE_4__.WidgetEvents.SHOW);
        }
        return this;
    }
    hide() {
        if (this.elements.root) {
            this.elements.root.style.display = 'none';
            this.events.emit(_events_js__WEBPACK_IMPORTED_MODULE_4__.WidgetEvents.HIDE);
        }
        return this;
    }
    /**
   * Метод вызывается перед началом загрузки iframe с VK ID приложением
   */ onStartLoadHandler() {
        this.setState(_types_js__WEBPACK_IMPORTED_MODULE_3__.WidgetState.LOADING);
        this.timeoutTimer = setTimeout(()=>{
            this.onErrorHandler({
                code: _types_js__WEBPACK_IMPORTED_MODULE_3__.WidgetErrorCode.TimeoutExceeded,
                text: _constants_js__WEBPACK_IMPORTED_MODULE_5__.WIDGET_ERROR_TEXT[_types_js__WEBPACK_IMPORTED_MODULE_3__.WidgetErrorCode.TimeoutExceeded]
            });
        }, MODULE_LOAD_TIMEOUT);
        this.events.emit(_events_js__WEBPACK_IMPORTED_MODULE_4__.WidgetEvents.START_LOAD);
    }
    /**
   * Метод вызывается после того, как полностью загружен iframe с VK ID приложением
   */ onLoadHandler() {
        clearTimeout(this.timeoutTimer);
        setTimeout(()=>{
            // Задержка избавляет от моргания замены шаблона на iframe
            this.setState(_types_js__WEBPACK_IMPORTED_MODULE_3__.WidgetState.LOADED);
        }, MODULE_CHANGE_STATE_TIMEOUT);
        this.events.emit(_events_js__WEBPACK_IMPORTED_MODULE_4__.WidgetEvents.LOAD);
    }
    /**
   * Метод вызывается, когда во время работы/загрузки VK ID приложения произошла ошибка
   */ onErrorHandler(error) {
        clearTimeout(this.timeoutTimer);
        this.setState(_types_js__WEBPACK_IMPORTED_MODULE_3__.WidgetState.NOT_LOADED);
        this.events.emit(_widgets_oneTap_events_js__WEBPACK_IMPORTED_MODULE_6__.OneTapInternalEvents.AUTHENTICATION_INFO, {
            is_online: false
        });
        this.events.emit(_events_js__WEBPACK_IMPORTED_MODULE_4__.WidgetEvents.ERROR, error);
        this.elements?.iframe?.remove();
    }
    /**
   * Метод вызывается при сообщениях от VK ID приложения
   */ onBridgeMessageHandler(event) {
        switch(event.handler){
            case _events_js__WEBPACK_IMPORTED_MODULE_4__.WidgetEvents.LOAD:
                {
                    this.onLoadHandler();
                    break;
                }
            case _events_js__WEBPACK_IMPORTED_MODULE_4__.WidgetEvents.CLOSE:
                {
                    this.close();
                    break;
                }
            case _events_js__WEBPACK_IMPORTED_MODULE_4__.WidgetEvents.ERROR:
                {
                    this.onErrorHandler({
                        code: _types_js__WEBPACK_IMPORTED_MODULE_3__.WidgetErrorCode.InternalError,
                        text: _constants_js__WEBPACK_IMPORTED_MODULE_5__.WIDGET_ERROR_TEXT[_types_js__WEBPACK_IMPORTED_MODULE_3__.WidgetErrorCode.InternalError],
                        details: event.params
                    });
                    break;
                }
            case _events_js__WEBPACK_IMPORTED_MODULE_4__.WidgetEvents.RESIZE:
                {
                    this.elements.root.style.height = `${event.params.height}px`;
                    break;
                }
        }
    }
    // <Дополнительные хелперы>
    renderTemplate() {
        this.container.insertAdjacentHTML('beforeend', this.templateRenderer(this.id));
    }
    loadWidgetFrame(params) {
        this.onStartLoadHandler();
        this.bridge = new _bridge_bridge_js__WEBPACK_IMPORTED_MODULE_7__.Bridge({
            iframe: this.elements.iframe,
            origin: `https://${this.config.get().__vkidDomain}`
        });
        this.bridge.on(_bridge_types_js__WEBPACK_IMPORTED_MODULE_8__.BridgeEvents.MESSAGE, (event)=>this.onBridgeMessageHandler(event));
        this.elements.iframe.src = this.getWidgetFrameSrc(this.config.get(), params);
    }
    getWidgetFrameSrc(config, params) {
        const queryParams = {
            ...params,
            origin: location.protocol + '//' + location.host,
            oauth_version: 2
        };
        return (0,_utils_url_url_js__WEBPACK_IMPORTED_MODULE_9__.getVKIDUrl)(this.vkidAppName, queryParams, config);
    }
    setState(state) {
        this.elements.root.setAttribute('data-state', state);
    }
    registerElements() {
        const root = document.getElementById(this.id);
        this.elements = {
            root,
            iframe: root.querySelector('iframe')
        };
    }
    redirectWithPayload(payload) {
        location.assign((0,_utils_url_url_js__WEBPACK_IMPORTED_MODULE_9__.getRedirectWithPayloadUrl)(payload, Widget.config));
    }
}
_ts_decorate([
    (0,_validator_validator_js__WEBPACK_IMPORTED_MODULE_10__.validator)({
        container: [
            _validator_rules_js__WEBPACK_IMPORTED_MODULE_11__.isRequired
        ]
    })
], Widget.prototype, "render", null);




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Auth: () => (/* binding */ globalAuth),
/* harmony export */   AuthErrorCode: () => (/* reexport safe */ _auth_types_js__WEBPACK_IMPORTED_MODULE_0__.AuthErrorCode),
/* harmony export */   Config: () => (/* binding */ globalConfig),
/* harmony export */   ConfigAuthMode: () => (/* reexport safe */ _core_config_types_js__WEBPACK_IMPORTED_MODULE_1__.ConfigAuthMode),
/* harmony export */   ConfigResponseMode: () => (/* reexport safe */ _core_config_types_js__WEBPACK_IMPORTED_MODULE_1__.ConfigResponseMode),
/* harmony export */   ConfigSource: () => (/* reexport safe */ _core_config_types_js__WEBPACK_IMPORTED_MODULE_1__.ConfigSource),
/* harmony export */   FloatingOneTap: () => (/* reexport safe */ _widgets_floatingOneTap_floatingOneTap_js__WEBPACK_IMPORTED_MODULE_7__.FloatingOneTap),
/* harmony export */   FloatingOneTapContentId: () => (/* reexport safe */ _widgets_floatingOneTap_types_js__WEBPACK_IMPORTED_MODULE_8__.FloatingOneTapContentId),
/* harmony export */   FloatingOneTapInternalEvents: () => (/* reexport safe */ _widgets_floatingOneTap_events_js__WEBPACK_IMPORTED_MODULE_9__.FloatingOneTapInternalEvents),
/* harmony export */   Languages: () => (/* reexport safe */ _types_js__WEBPACK_IMPORTED_MODULE_3__.Languages),
/* harmony export */   OAuthList: () => (/* reexport safe */ _widgets_oauthList_oauthList_js__WEBPACK_IMPORTED_MODULE_10__.OAuthList),
/* harmony export */   OAuthListInternalEvents: () => (/* reexport safe */ _widgets_oauthList_events_js__WEBPACK_IMPORTED_MODULE_12__.OAuthListInternalEvents),
/* harmony export */   OAuthName: () => (/* reexport safe */ _widgets_oauthList_types_js__WEBPACK_IMPORTED_MODULE_11__.OAuthName),
/* harmony export */   OneTap: () => (/* reexport safe */ _widgets_oneTap_oneTap_js__WEBPACK_IMPORTED_MODULE_4__.OneTap),
/* harmony export */   OneTapContentId: () => (/* reexport safe */ _widgets_oneTap_types_js__WEBPACK_IMPORTED_MODULE_5__.OneTapContentId),
/* harmony export */   OneTapInternalEvents: () => (/* reexport safe */ _widgets_oneTap_events_js__WEBPACK_IMPORTED_MODULE_6__.OneTapInternalEvents),
/* harmony export */   OneTapSkin: () => (/* reexport safe */ _widgets_oneTap_types_js__WEBPACK_IMPORTED_MODULE_5__.OneTapSkin),
/* harmony export */   Prompt: () => (/* reexport safe */ _core_config_types_js__WEBPACK_IMPORTED_MODULE_1__.Prompt),
/* harmony export */   Scheme: () => (/* reexport safe */ _types_js__WEBPACK_IMPORTED_MODULE_3__.Scheme),
/* harmony export */   WidgetEvents: () => (/* reexport safe */ _core_widget_events_js__WEBPACK_IMPORTED_MODULE_2__.WidgetEvents)
/* harmony export */ });
/* harmony import */ var _auth_auth_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./auth/auth.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/auth/auth.js");
/* harmony import */ var _auth_types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./auth/types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/auth/types.js");
/* harmony import */ var _core_config_config_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./core/config/config.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/config/config.js");
/* harmony import */ var _core_config_types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core/config/types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/config/types.js");
/* harmony import */ var _core_widget_widget_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./core/widget/widget.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/widget/widget.js");
/* harmony import */ var _core_widget_events_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core/widget/events.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/widget/events.js");
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/types.js");
/* harmony import */ var _widgets_oneTap_oneTap_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./widgets/oneTap/oneTap.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oneTap/oneTap.js");
/* harmony import */ var _widgets_oneTap_types_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./widgets/oneTap/types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oneTap/types.js");
/* harmony import */ var _widgets_oneTap_events_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./widgets/oneTap/events.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oneTap/events.js");
/* harmony import */ var _widgets_floatingOneTap_floatingOneTap_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./widgets/floatingOneTap/floatingOneTap.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/floatingOneTap/floatingOneTap.js");
/* harmony import */ var _widgets_floatingOneTap_types_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./widgets/floatingOneTap/types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/floatingOneTap/types.js");
/* harmony import */ var _widgets_floatingOneTap_events_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./widgets/floatingOneTap/events.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/floatingOneTap/events.js");
/* harmony import */ var _widgets_oauthList_oauthList_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./widgets/oauthList/oauthList.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oauthList/oauthList.js");
/* harmony import */ var _widgets_oauthList_types_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./widgets/oauthList/types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oauthList/types.js");
/* harmony import */ var _widgets_oauthList_events_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./widgets/oauthList/events.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oauthList/events.js");

















const globalConfig = new _core_config_config_js__WEBPACK_IMPORTED_MODULE_13__.Config();
/** Export Auth */ _auth_auth_js__WEBPACK_IMPORTED_MODULE_14__.Auth.config = globalConfig;
const globalAuth = new _auth_auth_js__WEBPACK_IMPORTED_MODULE_14__.Auth();
/** Export Core Widget */ _core_widget_widget_js__WEBPACK_IMPORTED_MODULE_15__.Widget.config = globalConfig;
_core_widget_widget_js__WEBPACK_IMPORTED_MODULE_15__.Widget.auth = globalAuth;




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/lib/@babel/runtime/helpers/esm/defineProperty.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/lib/@babel/runtime/helpers/esm/defineProperty.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _defineProperty)
/* harmony export */ });
/* harmony import */ var _toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toPropertyKey.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/lib/@babel/runtime/helpers/esm/toPropertyKey.js");


function _defineProperty(obj, key, value) {
  key = (0,_toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__["default"])(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/lib/@babel/runtime/helpers/esm/toPrimitive.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/lib/@babel/runtime/helpers/esm/toPrimitive.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _toPrimitive)
/* harmony export */ });
/* harmony import */ var _typeof_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typeof.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/lib/@babel/runtime/helpers/esm/typeof.js");


function _toPrimitive(input, hint) {
  if ((0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__["default"])(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if ((0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__["default"])(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/lib/@babel/runtime/helpers/esm/toPropertyKey.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/lib/@babel/runtime/helpers/esm/toPropertyKey.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _toPropertyKey)
/* harmony export */ });
/* harmony import */ var _typeof_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./typeof.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/lib/@babel/runtime/helpers/esm/typeof.js");
/* harmony import */ var _toPrimitive_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toPrimitive.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/lib/@babel/runtime/helpers/esm/toPrimitive.js");



function _toPropertyKey(arg) {
  var key = (0,_toPrimitive_js__WEBPACK_IMPORTED_MODULE_0__["default"])(arg, "string");
  return (0,_typeof_js__WEBPACK_IMPORTED_MODULE_1__["default"])(key) === "symbol" ? key : String(key);
}




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/lib/@babel/runtime/helpers/esm/typeof.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/lib/@babel/runtime/helpers/esm/typeof.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _typeof)
/* harmony export */ });
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/lib/@vkontakte/vkjs/lib/es6/functions.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/lib/@vkontakte/vkjs/lib/es6/functions.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   debounce: () => (/* binding */ debounce),
/* harmony export */   noop: () => (/* binding */ noop)
/* harmony export */ });
var noop = function noop() {}; // eslint-disable-line @typescript-eslint/no-empty-function
function debounce(fn, delay) {
  var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : window;
  var timeout;
  var args;

  var later = function later() {
    return fn.apply(context, args);
  };

  return function () {
    for (var _len2 = arguments.length, a = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      a[_key2] = arguments[_key2];
    }

    args = a;
    clearTimeout(timeout);
    timeout = setTimeout(later, delay);
  };
}




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/lib/@vkontakte/vkjs/lib/es6/querystring.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/lib/@vkontakte/vkjs/lib/es6/querystring.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   querystring: () => (/* binding */ querystring)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../@babel/runtime/helpers/esm/defineProperty.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/lib/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _babel_runtime_helpers_esm_typeof_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../@babel/runtime/helpers/esm/typeof.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/lib/@babel/runtime/helpers/esm/typeof.js");



function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0,_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_0__["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function parse(query) {
  if (typeof query !== 'string') {
    return {};
  }

  query = query.trim().replace(/^[?#&]/, '');

  if (!query) {
    return {};
  }

  var matches = /\?(.+)$/ig.exec(query);
  var str = matches ? matches[1] : query;
  return str.split('&').reduce(function (acc, item) {
    var param = item.split('=');

    if (param[1]) {
      acc[param[0]] = decodeURIComponent(param[1]);
    }

    return acc;
  }, {});
}

function stringify(data) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if ((0,_babel_runtime_helpers_esm_typeof_js__WEBPACK_IMPORTED_MODULE_1__["default"])(data) !== 'object' || data === null) {
    return '';
  }

  options = _objectSpread({
    encode: true
  }, options);

  var encode = function encode(value) {
    return options.encode ? encodeURIComponent(value) : String(value);
  };

  return Object.keys(data).reduce(function (acc, key) {
    var value = data[key];

    if (value === undefined) {
      return acc;
    }

    if (value === null) {
      if (!options.skipNull) {
        acc.push([encode(key), ''].join('='));
      }

      return acc;
    }

    if (Array.isArray(value)) {
      value.map(function (arrayItem) {
        acc.push("".concat(encode(key), "[]=").concat(encode(arrayItem)));
      }).join();
      return acc;
    }

    acc.push([encode(key), encode(value)].join('='));
    return acc;
  }, []).join('&');
}

var querystring = {
  parse: parse,
  stringify: stringify
};




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/lib/mitt/dist/mitt.es.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/lib/mitt/dist/mitt.es.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ mitt)
/* harmony export */ });
//      
// An event handler can take an optional event argument
// and should not return a value
                                          
                                                               

// An array of all currently registered event handlers for a type
                                            
                                                            
// A map of event types and their corresponding event handlers.
                        
                                 
                                   
  

/** Mitt: Tiny (~200b) functional event emitter / pubsub.
 *  @name mitt
 *  @returns {Mitt}
 */
function mitt(all                 ) {
	all = all || Object.create(null);

	return {
		/**
		 * Register an event handler for the given type.
		 *
		 * @param  {String} type	Type of event to listen for, or `"*"` for all events
		 * @param  {Function} handler Function to call in response to given event
		 * @memberOf mitt
		 */
		on: function on(type        , handler              ) {
			(all[type] || (all[type] = [])).push(handler);
		},

		/**
		 * Remove an event handler for the given type.
		 *
		 * @param  {String} type	Type of event to unregister `handler` from, or `"*"`
		 * @param  {Function} handler Handler function to remove
		 * @memberOf mitt
		 */
		off: function off(type        , handler              ) {
			if (all[type]) {
				all[type].splice(all[type].indexOf(handler) >>> 0, 1);
			}
		},

		/**
		 * Invoke all handlers for the given type.
		 * If present, `"*"` handlers are invoked after type-matched handlers.
		 *
		 * @param {String} type  The event type to invoke
		 * @param {Any} [evt]  Any value (object is recommended and powerful), passed to each handler
		 * @memberOf mitt
		 */
		emit: function emit(type        , evt     ) {
			(all[type] || []).slice().map(function (handler) { handler(evt); });
			(all['*'] || []).slice().map(function (handler) { handler(type, evt); });
		}
	};
}




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/lib/nanoid/non-secure/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/lib/nanoid/non-secure/index.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   customAlphabet: () => (/* binding */ customAlphabet),
/* harmony export */   nanoid: () => (/* binding */ nanoid)
/* harmony export */ });
let urlAlphabet =
  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict';
let customAlphabet = (alphabet, defaultSize = 21) => {
  return (size = defaultSize) => {
    let id = '';
    let i = size;
    while (i--) {
      id += alphabet[(Math.random() * alphabet.length) | 0];
    }
    return id
  }
};
let nanoid = (size = 21) => {
  let id = '';
  let i = size;
  while (i--) {
    id += urlAlphabet[(Math.random() * 64) | 0];
  }
  return id
};




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/lib/resize-observer-polyfill/dist/ResizeObserver.es.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/lib/resize-observer-polyfill/dist/ResizeObserver.es.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ index)
/* harmony export */ });
/**
 * A collection of shims that provide minimal functionality of the ES6 collections.
 *
 * These implementations are not meant to be used outside of the ResizeObserver
 * modules as they cover only a limited range of use cases.
 */
/* eslint-disable require-jsdoc, valid-jsdoc */
var MapShim = (function () {
    if (typeof Map !== 'undefined') {
        return Map;
    }
    /**
     * Returns index in provided array that matches the specified key.
     *
     * @param {Array<Array>} arr
     * @param {*} key
     * @returns {number}
     */
    function getIndex(arr, key) {
        var result = -1;
        arr.some(function (entry, index) {
            if (entry[0] === key) {
                result = index;
                return true;
            }
            return false;
        });
        return result;
    }
    return /** @class */ (function () {
        function class_1() {
            this.__entries__ = [];
        }
        Object.defineProperty(class_1.prototype, "size", {
            /**
             * @returns {boolean}
             */
            get: function () {
                return this.__entries__.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {*} key
         * @returns {*}
         */
        class_1.prototype.get = function (key) {
            var index = getIndex(this.__entries__, key);
            var entry = this.__entries__[index];
            return entry && entry[1];
        };
        /**
         * @param {*} key
         * @param {*} value
         * @returns {void}
         */
        class_1.prototype.set = function (key, value) {
            var index = getIndex(this.__entries__, key);
            if (~index) {
                this.__entries__[index][1] = value;
            }
            else {
                this.__entries__.push([key, value]);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */
        class_1.prototype.delete = function (key) {
            var entries = this.__entries__;
            var index = getIndex(entries, key);
            if (~index) {
                entries.splice(index, 1);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */
        class_1.prototype.has = function (key) {
            return !!~getIndex(this.__entries__, key);
        };
        /**
         * @returns {void}
         */
        class_1.prototype.clear = function () {
            this.__entries__.splice(0);
        };
        /**
         * @param {Function} callback
         * @param {*} [ctx=null]
         * @returns {void}
         */
        class_1.prototype.forEach = function (callback, ctx) {
            if (ctx === void 0) { ctx = null; }
            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
                var entry = _a[_i];
                callback.call(ctx, entry[1], entry[0]);
            }
        };
        return class_1;
    }());
})();

/**
 * Detects whether window and document objects are available in current environment.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;

// Returns global object of a current environment.
var global$1 = (function () {
    if (typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g.Math === Math) {
        return __webpack_require__.g;
    }
    if (typeof self !== 'undefined' && self.Math === Math) {
        return self;
    }
    if (typeof window !== 'undefined' && window.Math === Math) {
        return window;
    }
    // eslint-disable-next-line no-new-func
    return Function('return this')();
})();

/**
 * A shim for the requestAnimationFrame which falls back to the setTimeout if
 * first one is not supported.
 *
 * @returns {number} Requests' identifier.
 */
var requestAnimationFrame$1 = (function () {
    if (typeof requestAnimationFrame === 'function') {
        // It's required to use a bounded function because IE sometimes throws
        // an "Invalid calling object" error if rAF is invoked without the global
        // object on the left hand side.
        return requestAnimationFrame.bind(global$1);
    }
    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };
})();

// Defines minimum timeout before adding a trailing call.
var trailingTimeout = 2;
/**
 * Creates a wrapper function which ensures that provided callback will be
 * invoked only once during the specified delay period.
 *
 * @param {Function} callback - Function to be invoked after the delay period.
 * @param {number} delay - Delay after which to invoke callback.
 * @returns {Function}
 */
function throttle (callback, delay) {
    var leadingCall = false, trailingCall = false, lastCallTime = 0;
    /**
     * Invokes the original callback function and schedules new invocation if
     * the "proxy" was called during current request.
     *
     * @returns {void}
     */
    function resolvePending() {
        if (leadingCall) {
            leadingCall = false;
            callback();
        }
        if (trailingCall) {
            proxy();
        }
    }
    /**
     * Callback invoked after the specified delay. It will further postpone
     * invocation of the original function delegating it to the
     * requestAnimationFrame.
     *
     * @returns {void}
     */
    function timeoutCallback() {
        requestAnimationFrame$1(resolvePending);
    }
    /**
     * Schedules invocation of the original function.
     *
     * @returns {void}
     */
    function proxy() {
        var timeStamp = Date.now();
        if (leadingCall) {
            // Reject immediately following calls.
            if (timeStamp - lastCallTime < trailingTimeout) {
                return;
            }
            // Schedule new call to be in invoked when the pending one is resolved.
            // This is important for "transitions" which never actually start
            // immediately so there is a chance that we might miss one if change
            // happens amids the pending invocation.
            trailingCall = true;
        }
        else {
            leadingCall = true;
            trailingCall = false;
            setTimeout(timeoutCallback, delay);
        }
        lastCallTime = timeStamp;
    }
    return proxy;
}

// Minimum delay before invoking the update of observers.
var REFRESH_DELAY = 20;
// A list of substrings of CSS properties used to find transition events that
// might affect dimensions of observed elements.
var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];
// Check if MutationObserver is available.
var mutationObserverSupported = typeof MutationObserver !== 'undefined';
/**
 * Singleton controller class which handles updates of ResizeObserver instances.
 */
var ResizeObserverController = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserverController.
     *
     * @private
     */
    function ResizeObserverController() {
        /**
         * Indicates whether DOM listeners have been added.
         *
         * @private {boolean}
         */
        this.connected_ = false;
        /**
         * Tells that controller has subscribed for Mutation Events.
         *
         * @private {boolean}
         */
        this.mutationEventsAdded_ = false;
        /**
         * Keeps reference to the instance of MutationObserver.
         *
         * @private {MutationObserver}
         */
        this.mutationsObserver_ = null;
        /**
         * A list of connected observers.
         *
         * @private {Array<ResizeObserverSPI>}
         */
        this.observers_ = [];
        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
    }
    /**
     * Adds observer to observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be added.
     * @returns {void}
     */
    ResizeObserverController.prototype.addObserver = function (observer) {
        if (!~this.observers_.indexOf(observer)) {
            this.observers_.push(observer);
        }
        // Add listeners if they haven't been added yet.
        if (!this.connected_) {
            this.connect_();
        }
    };
    /**
     * Removes observer from observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be removed.
     * @returns {void}
     */
    ResizeObserverController.prototype.removeObserver = function (observer) {
        var observers = this.observers_;
        var index = observers.indexOf(observer);
        // Remove observer if it's present in registry.
        if (~index) {
            observers.splice(index, 1);
        }
        // Remove listeners if controller has no connected observers.
        if (!observers.length && this.connected_) {
            this.disconnect_();
        }
    };
    /**
     * Invokes the update of observers. It will continue running updates insofar
     * it detects changes.
     *
     * @returns {void}
     */
    ResizeObserverController.prototype.refresh = function () {
        var changesDetected = this.updateObservers_();
        // Continue running updates if changes have been detected as there might
        // be future ones caused by CSS transitions.
        if (changesDetected) {
            this.refresh();
        }
    };
    /**
     * Updates every observer from observers list and notifies them of queued
     * entries.
     *
     * @private
     * @returns {boolean} Returns "true" if any observer has detected changes in
     *      dimensions of it's elements.
     */
    ResizeObserverController.prototype.updateObservers_ = function () {
        // Collect observers that have active observations.
        var activeObservers = this.observers_.filter(function (observer) {
            return observer.gatherActive(), observer.hasActive();
        });
        // Deliver notifications in a separate cycle in order to avoid any
        // collisions between observers, e.g. when multiple instances of
        // ResizeObserver are tracking the same element and the callback of one
        // of them changes content dimensions of the observed target. Sometimes
        // this may result in notifications being blocked for the rest of observers.
        activeObservers.forEach(function (observer) { return observer.broadcastActive(); });
        return activeObservers.length > 0;
    };
    /**
     * Initializes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.connect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already added.
        if (!isBrowser || this.connected_) {
            return;
        }
        // Subscription to the "Transitionend" event is used as a workaround for
        // delayed transitions. This way it's possible to capture at least the
        // final state of an element.
        document.addEventListener('transitionend', this.onTransitionEnd_);
        window.addEventListener('resize', this.refresh);
        if (mutationObserverSupported) {
            this.mutationsObserver_ = new MutationObserver(this.refresh);
            this.mutationsObserver_.observe(document, {
                attributes: true,
                childList: true,
                characterData: true,
                subtree: true
            });
        }
        else {
            document.addEventListener('DOMSubtreeModified', this.refresh);
            this.mutationEventsAdded_ = true;
        }
        this.connected_ = true;
    };
    /**
     * Removes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.disconnect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already removed.
        if (!isBrowser || !this.connected_) {
            return;
        }
        document.removeEventListener('transitionend', this.onTransitionEnd_);
        window.removeEventListener('resize', this.refresh);
        if (this.mutationsObserver_) {
            this.mutationsObserver_.disconnect();
        }
        if (this.mutationEventsAdded_) {
            document.removeEventListener('DOMSubtreeModified', this.refresh);
        }
        this.mutationsObserver_ = null;
        this.mutationEventsAdded_ = false;
        this.connected_ = false;
    };
    /**
     * "Transitionend" event handler.
     *
     * @private
     * @param {TransitionEvent} event
     * @returns {void}
     */
    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
        var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;
        // Detect whether transition may affect dimensions of an element.
        var isReflowProperty = transitionKeys.some(function (key) {
            return !!~propertyName.indexOf(key);
        });
        if (isReflowProperty) {
            this.refresh();
        }
    };
    /**
     * Returns instance of the ResizeObserverController.
     *
     * @returns {ResizeObserverController}
     */
    ResizeObserverController.getInstance = function () {
        if (!this.instance_) {
            this.instance_ = new ResizeObserverController();
        }
        return this.instance_;
    };
    /**
     * Holds reference to the controller's instance.
     *
     * @private {ResizeObserverController}
     */
    ResizeObserverController.instance_ = null;
    return ResizeObserverController;
}());

/**
 * Defines non-writable/enumerable properties of the provided target object.
 *
 * @param {Object} target - Object for which to define properties.
 * @param {Object} props - Properties to be defined.
 * @returns {Object} Target object.
 */
var defineConfigurable = (function (target, props) {
    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
        var key = _a[_i];
        Object.defineProperty(target, key, {
            value: props[key],
            enumerable: false,
            writable: false,
            configurable: true
        });
    }
    return target;
});

/**
 * Returns the global object associated with provided element.
 *
 * @param {Object} target
 * @returns {Object}
 */
var getWindowOf = (function (target) {
    // Assume that the element is an instance of Node, which means that it
    // has the "ownerDocument" property from which we can retrieve a
    // corresponding global object.
    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
    // Return the local global object if it's not possible extract one from
    // provided element.
    return ownerGlobal || global$1;
});

// Placeholder of an empty content rectangle.
var emptyRect = createRectInit(0, 0, 0, 0);
/**
 * Converts provided string to a number.
 *
 * @param {number|string} value
 * @returns {number}
 */
function toFloat(value) {
    return parseFloat(value) || 0;
}
/**
 * Extracts borders size from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @param {...string} positions - Borders positions (top, right, ...)
 * @returns {number}
 */
function getBordersSize(styles) {
    var positions = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        positions[_i - 1] = arguments[_i];
    }
    return positions.reduce(function (size, position) {
        var value = styles['border-' + position + '-width'];
        return size + toFloat(value);
    }, 0);
}
/**
 * Extracts paddings sizes from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @returns {Object} Paddings box.
 */
function getPaddings(styles) {
    var positions = ['top', 'right', 'bottom', 'left'];
    var paddings = {};
    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
        var position = positions_1[_i];
        var value = styles['padding-' + position];
        paddings[position] = toFloat(value);
    }
    return paddings;
}
/**
 * Calculates content rectangle of provided SVG element.
 *
 * @param {SVGGraphicsElement} target - Element content rectangle of which needs
 *      to be calculated.
 * @returns {DOMRectInit}
 */
function getSVGContentRect(target) {
    var bbox = target.getBBox();
    return createRectInit(0, 0, bbox.width, bbox.height);
}
/**
 * Calculates content rectangle of provided HTMLElement.
 *
 * @param {HTMLElement} target - Element for which to calculate the content rectangle.
 * @returns {DOMRectInit}
 */
function getHTMLElementContentRect(target) {
    // Client width & height properties can't be
    // used exclusively as they provide rounded values.
    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
    // By this condition we can catch all non-replaced inline, hidden and
    // detached elements. Though elements with width & height properties less
    // than 0.5 will be discarded as well.
    //
    // Without it we would need to implement separate methods for each of
    // those cases and it's not possible to perform a precise and performance
    // effective test for hidden elements. E.g. even jQuery's ':visible' filter
    // gives wrong results for elements with width & height less than 0.5.
    if (!clientWidth && !clientHeight) {
        return emptyRect;
    }
    var styles = getWindowOf(target).getComputedStyle(target);
    var paddings = getPaddings(styles);
    var horizPad = paddings.left + paddings.right;
    var vertPad = paddings.top + paddings.bottom;
    // Computed styles of width & height are being used because they are the
    // only dimensions available to JS that contain non-rounded values. It could
    // be possible to utilize the getBoundingClientRect if only it's data wasn't
    // affected by CSS transformations let alone paddings, borders and scroll bars.
    var width = toFloat(styles.width), height = toFloat(styles.height);
    // Width & height include paddings and borders when the 'border-box' box
    // model is applied (except for IE).
    if (styles.boxSizing === 'border-box') {
        // Following conditions are required to handle Internet Explorer which
        // doesn't include paddings and borders to computed CSS dimensions.
        //
        // We can say that if CSS dimensions + paddings are equal to the "client"
        // properties then it's either IE, and thus we don't need to subtract
        // anything, or an element merely doesn't have paddings/borders styles.
        if (Math.round(width + horizPad) !== clientWidth) {
            width -= getBordersSize(styles, 'left', 'right') + horizPad;
        }
        if (Math.round(height + vertPad) !== clientHeight) {
            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
        }
    }
    // Following steps can't be applied to the document's root element as its
    // client[Width/Height] properties represent viewport area of the window.
    // Besides, it's as well not necessary as the <html> itself neither has
    // rendered scroll bars nor it can be clipped.
    if (!isDocumentElement(target)) {
        // In some browsers (only in Firefox, actually) CSS width & height
        // include scroll bars size which can be removed at this step as scroll
        // bars are the only difference between rounded dimensions + paddings
        // and "client" properties, though that is not always true in Chrome.
        var vertScrollbar = Math.round(width + horizPad) - clientWidth;
        var horizScrollbar = Math.round(height + vertPad) - clientHeight;
        // Chrome has a rather weird rounding of "client" properties.
        // E.g. for an element with content width of 314.2px it sometimes gives
        // the client width of 315px and for the width of 314.7px it may give
        // 314px. And it doesn't happen all the time. So just ignore this delta
        // as a non-relevant.
        if (Math.abs(vertScrollbar) !== 1) {
            width -= vertScrollbar;
        }
        if (Math.abs(horizScrollbar) !== 1) {
            height -= horizScrollbar;
        }
    }
    return createRectInit(paddings.left, paddings.top, width, height);
}
/**
 * Checks whether provided element is an instance of the SVGGraphicsElement.
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
var isSVGGraphicsElement = (function () {
    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
    // interface.
    if (typeof SVGGraphicsElement !== 'undefined') {
        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };
    }
    // If it's so, then check that element is at least an instance of the
    // SVGElement and that it has the "getBBox" method.
    // eslint-disable-next-line no-extra-parens
    return function (target) { return (target instanceof getWindowOf(target).SVGElement &&
        typeof target.getBBox === 'function'); };
})();
/**
 * Checks whether provided element is a document element (<html>).
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
function isDocumentElement(target) {
    return target === getWindowOf(target).document.documentElement;
}
/**
 * Calculates an appropriate content rectangle for provided html or svg element.
 *
 * @param {Element} target - Element content rectangle of which needs to be calculated.
 * @returns {DOMRectInit}
 */
function getContentRect(target) {
    if (!isBrowser) {
        return emptyRect;
    }
    if (isSVGGraphicsElement(target)) {
        return getSVGContentRect(target);
    }
    return getHTMLElementContentRect(target);
}
/**
 * Creates rectangle with an interface of the DOMRectReadOnly.
 * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
 *
 * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
 * @returns {DOMRectReadOnly}
 */
function createReadOnlyRect(_a) {
    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
    // If DOMRectReadOnly is available use it as a prototype for the rectangle.
    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
    var rect = Object.create(Constr.prototype);
    // Rectangle's properties are not writable and non-enumerable.
    defineConfigurable(rect, {
        x: x, y: y, width: width, height: height,
        top: y,
        right: x + width,
        bottom: height + y,
        left: x
    });
    return rect;
}
/**
 * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
 * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
 *
 * @param {number} x - X coordinate.
 * @param {number} y - Y coordinate.
 * @param {number} width - Rectangle's width.
 * @param {number} height - Rectangle's height.
 * @returns {DOMRectInit}
 */
function createRectInit(x, y, width, height) {
    return { x: x, y: y, width: width, height: height };
}

/**
 * Class that is responsible for computations of the content rectangle of
 * provided DOM element and for keeping track of it's changes.
 */
var ResizeObservation = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObservation.
     *
     * @param {Element} target - Element to be observed.
     */
    function ResizeObservation(target) {
        /**
         * Broadcasted width of content rectangle.
         *
         * @type {number}
         */
        this.broadcastWidth = 0;
        /**
         * Broadcasted height of content rectangle.
         *
         * @type {number}
         */
        this.broadcastHeight = 0;
        /**
         * Reference to the last observed content rectangle.
         *
         * @private {DOMRectInit}
         */
        this.contentRect_ = createRectInit(0, 0, 0, 0);
        this.target = target;
    }
    /**
     * Updates content rectangle and tells whether it's width or height properties
     * have changed since the last broadcast.
     *
     * @returns {boolean}
     */
    ResizeObservation.prototype.isActive = function () {
        var rect = getContentRect(this.target);
        this.contentRect_ = rect;
        return (rect.width !== this.broadcastWidth ||
            rect.height !== this.broadcastHeight);
    };
    /**
     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
     * from the corresponding properties of the last observed content rectangle.
     *
     * @returns {DOMRectInit} Last observed content rectangle.
     */
    ResizeObservation.prototype.broadcastRect = function () {
        var rect = this.contentRect_;
        this.broadcastWidth = rect.width;
        this.broadcastHeight = rect.height;
        return rect;
    };
    return ResizeObservation;
}());

var ResizeObserverEntry = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObserverEntry.
     *
     * @param {Element} target - Element that is being observed.
     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
     */
    function ResizeObserverEntry(target, rectInit) {
        var contentRect = createReadOnlyRect(rectInit);
        // According to the specification following properties are not writable
        // and are also not enumerable in the native implementation.
        //
        // Property accessors are not being used as they'd require to define a
        // private WeakMap storage which may cause memory leaks in browsers that
        // don't support this type of collections.
        defineConfigurable(this, { target: target, contentRect: contentRect });
    }
    return ResizeObserverEntry;
}());

var ResizeObserverSPI = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback function that is invoked
     *      when one of the observed elements changes it's content dimensions.
     * @param {ResizeObserverController} controller - Controller instance which
     *      is responsible for the updates of observer.
     * @param {ResizeObserver} callbackCtx - Reference to the public
     *      ResizeObserver instance which will be passed to callback function.
     */
    function ResizeObserverSPI(callback, controller, callbackCtx) {
        /**
         * Collection of resize observations that have detected changes in dimensions
         * of elements.
         *
         * @private {Array<ResizeObservation>}
         */
        this.activeObservations_ = [];
        /**
         * Registry of the ResizeObservation instances.
         *
         * @private {Map<Element, ResizeObservation>}
         */
        this.observations_ = new MapShim();
        if (typeof callback !== 'function') {
            throw new TypeError('The callback provided as parameter 1 is not a function.');
        }
        this.callback_ = callback;
        this.controller_ = controller;
        this.callbackCtx_ = callbackCtx;
    }
    /**
     * Starts observing provided element.
     *
     * @param {Element} target - Element to be observed.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.observe = function (target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is already being observed.
        if (observations.has(target)) {
            return;
        }
        observations.set(target, new ResizeObservation(target));
        this.controller_.addObserver(this);
        // Force the update of observations.
        this.controller_.refresh();
    };
    /**
     * Stops observing provided element.
     *
     * @param {Element} target - Element to stop observing.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.unobserve = function (target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is not being observed.
        if (!observations.has(target)) {
            return;
        }
        observations.delete(target);
        if (!observations.size) {
            this.controller_.removeObserver(this);
        }
    };
    /**
     * Stops observing all elements.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.disconnect = function () {
        this.clearActive();
        this.observations_.clear();
        this.controller_.removeObserver(this);
    };
    /**
     * Collects observation instances the associated element of which has changed
     * it's content rectangle.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.gatherActive = function () {
        var _this = this;
        this.clearActive();
        this.observations_.forEach(function (observation) {
            if (observation.isActive()) {
                _this.activeObservations_.push(observation);
            }
        });
    };
    /**
     * Invokes initial callback function with a list of ResizeObserverEntry
     * instances collected from active resize observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.broadcastActive = function () {
        // Do nothing if observer doesn't have active observations.
        if (!this.hasActive()) {
            return;
        }
        var ctx = this.callbackCtx_;
        // Create ResizeObserverEntry instance for every active observation.
        var entries = this.activeObservations_.map(function (observation) {
            return new ResizeObserverEntry(observation.target, observation.broadcastRect());
        });
        this.callback_.call(ctx, entries, ctx);
        this.clearActive();
    };
    /**
     * Clears the collection of active observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.clearActive = function () {
        this.activeObservations_.splice(0);
    };
    /**
     * Tells whether observer has active observations.
     *
     * @returns {boolean}
     */
    ResizeObserverSPI.prototype.hasActive = function () {
        return this.activeObservations_.length > 0;
    };
    return ResizeObserverSPI;
}());

// Registry of internal observers. If WeakMap is not available use current shim
// for the Map collection as it has all required methods and because WeakMap
// can't be fully polyfilled anyway.
var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
/**
 * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
 * exposing only those methods and properties that are defined in the spec.
 */
var ResizeObserver = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback that is invoked when
     *      dimensions of the observed elements change.
     */
    function ResizeObserver(callback) {
        if (!(this instanceof ResizeObserver)) {
            throw new TypeError('Cannot call a class as a function.');
        }
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        var controller = ResizeObserverController.getInstance();
        var observer = new ResizeObserverSPI(callback, controller, this);
        observers.set(this, observer);
    }
    return ResizeObserver;
}());
// Expose public methods of ResizeObserver.
[
    'observe',
    'unobserve',
    'disconnect'
].forEach(function (method) {
    ResizeObserver.prototype[method] = function () {
        var _a;
        return (_a = observers.get(this))[method].apply(_a, arguments);
    };
});

var index = (function () {
    // Export existing implementation if available.
    if (typeof global$1.ResizeObserver !== 'undefined') {
        return global$1.ResizeObserver;
    }
    return ResizeObserver;
})();




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/services/MyTrackerService/MyTrackerService.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/services/MyTrackerService/MyTrackerService.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MyTrackerService: () => (/* binding */ MyTrackerService)
/* harmony export */ });
/* harmony import */ var _utils_request_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/request.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/utils/request.js");
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/services/MyTrackerService/types.js");



class MyTrackerService {
    config;
    constructor(config){
        this.config = config;
    }
    init() {
        this.getTrackerId().then(({ response })=>{
            if (response.active === _types_js__WEBPACK_IMPORTED_MODULE_0__.MyTrackerStatus.ON) {
                this.includeOnPage(response.tracker_id);
            }
        }).catch(console.error);
    }
    getTrackerId() {
        const url = (0,_utils_request_js__WEBPACK_IMPORTED_MODULE_1__.getStatsUrl)('vkid_sdk_get_config', this.config);
        return (0,_utils_request_js__WEBPACK_IMPORTED_MODULE_1__.request)(url, {});
    }
    includeOnPage(trackerId) {
        // @ts-expect-error
        const _tmr = window._tmr || (window._tmr = []);
        _tmr.push({
            id: trackerId,
            type: 'pageView',
            start: new Date().getTime()
        });
        if (document.getElementById('tmr-code')) {
            return;
        }
        const ts = document.createElement('script');
        ts.type = 'text/javascript';
        ts.async = true;
        ts.id = 'tmr-code';
        ts.src = 'https://mytopf.com/js/code.js';
        const s = document.getElementsByTagName('script')[0];
        // @ts-expect-error
        s.parentNode.insertBefore(ts, s);
    }
}




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/services/MyTrackerService/types.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/services/MyTrackerService/types.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MyTrackerStatus: () => (/* binding */ MyTrackerStatus)
/* harmony export */ });
var MyTrackerStatus;
(function(MyTrackerStatus) {
    MyTrackerStatus[MyTrackerStatus["OFF"] = 0] = "OFF";
    MyTrackerStatus[MyTrackerStatus["ON"] = 1] = "ON";
    MyTrackerStatus[MyTrackerStatus["IN_PROGRESS"] = 2] = "IN_PROGRESS";
})(MyTrackerStatus || (MyTrackerStatus = {}));




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/types.js":
/*!******************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/types.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Languages: () => (/* binding */ Languages),
/* harmony export */   Scheme: () => (/* binding */ Scheme)
/* harmony export */ });
var Languages;
(function(Languages) {
    Languages[Languages["RUS"] = 0] = "RUS";
    Languages[Languages["UKR"] = 1] = "UKR";
    Languages[Languages["ENG"] = 3] = "ENG";
    Languages[Languages["SPA"] = 4] = "SPA";
    Languages[Languages["GERMAN"] = 6] = "GERMAN";
    Languages[Languages["POL"] = 15] = "POL";
    Languages[Languages["FRA"] = 16] = "FRA";
    Languages[Languages["UZB"] = 65] = "UZB";
    Languages[Languages["TURKEY"] = 82] = "TURKEY";
    Languages[Languages["KAZ"] = 97] = "KAZ";
    Languages[Languages["BEL"] = 114] = "BEL";
})(Languages || (Languages = {}));
var Scheme;
(function(Scheme) {
    Scheme["LIGHT"] = 'light';
    Scheme["DARK"] = 'dark';
})(Scheme || (Scheme = {}));




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/utils/cookie.js":
/*!*************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/utils/cookie.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   clearCodeVerifierCookie: () => (/* binding */ clearCodeVerifierCookie),
/* harmony export */   clearStateCookie: () => (/* binding */ clearStateCookie),
/* harmony export */   codeVerifier: () => (/* binding */ codeVerifier),
/* harmony export */   cookie: () => (/* binding */ cookie),
/* harmony export */   setExtIdCookie: () => (/* binding */ setExtIdCookie),
/* harmony export */   state: () => (/* binding */ state)
/* harmony export */ });
/* harmony import */ var _lib_nanoid_non_secure_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./../lib/nanoid/non-secure/index.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/lib/nanoid/non-secure/index.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/constants.js");



function getCookie(name) {
    try {
        let matches = document.cookie.match(new RegExp('(?:^|; )' + ('vkid_sdk:' + name).replace(/([.$?*|{}()\[\]\\\/+^])/g, '\\$1') + '=([^;]*)'));
        return matches ? decodeURIComponent(matches[1]) : undefined;
    } catch (e) {
        return undefined;
    }
}
function setCookie(name, params) {
    try {
        const expireTime = new Date(new Date().getTime() + (params.expires || _constants_js__WEBPACK_IMPORTED_MODULE_0__.COOKIE_EXPIRES_TIME_15_MIN)).toUTCString();
        const allowedDomain = location.host.split('.').slice(-2).join('.');
        document.cookie = [
            `vkid_sdk:${name}=${encodeURIComponent(params.value || '')}`,
            `expires=${expireTime}`,
            'path=/',
            `domain=.${allowedDomain}`,
            'SameSite=Strict',
            'Secure'
        ].join('; ');
    } catch (e) {}
}
function clearCookie(name) {
    const allowedDomain = location.host.split('.').slice(-2).join('.');
    try {
        document.cookie = [
            `vkid_sdk:${name}=`,
            'expires=Thu, 01 Jan 1970 00:00:00 UTC',
            'path=/',
            'SameSite=Strict',
            'Secure',
            `domain=.${allowedDomain}`
        ].join('; ');
    } catch (e) {}
}
function cookie(name, params) {
    if (params.value) {
        setCookie(name, params);
        return params.value;
    }
    let value;
    value = getCookie(name);
    if (!value) {
        value = (0,_lib_nanoid_non_secure_index_js__WEBPACK_IMPORTED_MODULE_1__.nanoid)(48);
        setCookie(name, {
            ...params,
            value
        });
    }
    return value;
}
const state = (value)=>cookie('state', {
        value
    });
const codeVerifier = (value)=>cookie('codeVerifier', {
        value
    });
const clearStateCookie = ()=>clearCookie('state');
const clearCodeVerifierCookie = ()=>clearCookie('codeVerifier');
const COOKIE_EXPIRES_TIME_1_YEAR = 31_536_000_000;
function setExtIdCookie(value) {
    if (!value) {
        return;
    }
    try {
        const expireTime = new Date(new Date().getTime() + COOKIE_EXPIRES_TIME_1_YEAR).toUTCString();
        const allowedDomain = location.host.split('.').slice(-2).join('.');
        document.cookie = [
            `vkidExtId=${encodeURIComponent(value || '')}`,
            `expires=${expireTime}`,
            'path=/',
            `domain=.${allowedDomain}`,
            'SameSite=Strict',
            'Secure'
        ].join('; ');
    } catch (e) {}
}




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/utils/domain.js":
/*!*************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/utils/domain.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isDomainAllowed: () => (/* binding */ isDomainAllowed)
/* harmony export */ });
const ALLOWED_DOMAINS = [
    '.vk.com',
    '.vk.ru'
];
const isDomainAllowed = (origin)=>!!ALLOWED_DOMAINS.find((domain)=>origin.endsWith(domain));




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/utils/oauth.js":
/*!************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/utils/oauth.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   generateCodeChallenge: () => (/* binding */ generateCodeChallenge)
/* harmony export */ });
/* harmony import */ var crypto_js_enc_base64__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto-js/enc-base64 */ "./node_modules/crypto-js/enc-base64.js");
/* harmony import */ var crypto_js_enc_base64__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto_js_enc_base64__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var crypto_js_sha256__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! crypto-js/sha256 */ "./node_modules/crypto-js/sha256.js");
/* harmony import */ var crypto_js_sha256__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(crypto_js_sha256__WEBPACK_IMPORTED_MODULE_1__);



/**
 * Генерация code challenge для нового oauth
 */ const generateCodeChallenge = (codeVerifier)=>{
    const hash = crypto_js_sha256__WEBPACK_IMPORTED_MODULE_1___default()(codeVerifier);
    const base64 = crypto_js_enc_base64__WEBPACK_IMPORTED_MODULE_0___default().stringify(hash);
    return base64.replace(/=*$/g, '').replace(/\+/g, '-').replace(/\//g, '_');
};




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/utils/request.js":
/*!**************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/utils/request.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getStatsUrl: () => (/* binding */ getStatsUrl),
/* harmony export */   request: () => (/* binding */ request)
/* harmony export */ });
const getStatsUrl = (method, config)=>{
    const { __vkidDomain: domain, app } = config.get();
    return `https://${domain}/${method}?app_id=${app}&v=5.207`;
};
const makeParams = (params)=>{
    const pairs = Object.keys(params).map((key)=>{
        let param = params[key];
        key = encodeURIComponent(key || '');
        param = encodeURIComponent(param === undefined ? '' : param);
        return `${key}=${param}`;
    });
    return pairs.join('&');
};
const request = (url, params)=>{
    const paramsString = makeParams(params);
    return fetch(url, {
        method: 'POST',
        body: paramsString,
        mode: 'cors',
        credentials: 'include',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded'
        }
    }).then((res)=>res.json());
};




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/utils/styles.js":
/*!*************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/utils/styles.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getButtonFontSize: () => (/* binding */ getButtonFontSize),
/* harmony export */   getButtonLogoSize: () => (/* binding */ getButtonLogoSize),
/* harmony export */   getButtonPadding: () => (/* binding */ getButtonPadding)
/* harmony export */ });
const getButtonPadding = (height)=>{
    const res = (height - 30) / 2 + 3;
    if (height < 40) {
        return res;
    }
    return res - 2;
};
const getButtonFontSize = (height)=>{
    if (height < 40) {
        return 14;
    }
    if (height > 47) {
        return 17;
    }
    return 16;
};
const getButtonLogoSize = (height)=>{
    if (height < 40) {
        return 24;
    }
    return 28;
};




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/utils/url/nullOrUndefined.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/utils/url/nullOrUndefined.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isNullOrUndefined: () => (/* binding */ isNullOrUndefined)
/* harmony export */ });
const isNullOrUndefined = (value)=>value === null || value === undefined;




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/utils/url/url.js":
/*!**************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/utils/url/url.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   encodeStatsInfo: () => (/* binding */ encodeStatsInfo),
/* harmony export */   getRedirectWithPayloadUrl: () => (/* binding */ getRedirectWithPayloadUrl),
/* harmony export */   getVKIDUrl: () => (/* binding */ getVKIDUrl)
/* harmony export */ });
/* harmony import */ var _lib_vkontakte_vkjs_lib_es6_querystring_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./../../lib/@vkontakte/vkjs/lib/es6/querystring.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/lib/@vkontakte/vkjs/lib/es6/querystring.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../constants.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/constants.js");




const getVKIDUrl = (module, params, config)=>{
    const queryParams = {
        ...params,
        v: _constants_js__WEBPACK_IMPORTED_MODULE_0__.VERSION,
        sdk_type: 'vkid',
        app_id: config.app,
        redirect_uri: config.redirectUrl,
        debug: config.__debug ? 1 : null,
        localhost: config.__localhost ? 1 : null
    };
    const queryParamsString = _lib_vkontakte_vkjs_lib_es6_querystring_js__WEBPACK_IMPORTED_MODULE_1__.querystring.stringify(queryParams, {
        skipNull: true
    });
    return `https://${config.__vkidDomain}/${module}?${queryParamsString}`;
};
const getRedirectWithPayloadUrl = (payload, config)=>{
    const redirectUrlFromConfig = config.get().redirectUrl;
    const containsQuery = redirectUrlFromConfig.includes('?');
    const params = Object.keys(payload).map((key)=>encodeURIComponent(key) + '=' + encodeURIComponent(payload[key])).join('&');
    return `${redirectUrlFromConfig}${containsQuery ? '&' : '?'}${params}`;
};
const encodeStatsInfo = (params)=>{
    const hasParams = Object.values(params).filter(Boolean).length;
    if (hasParams) {
        return btoa(JSON.stringify(params));
    }
};




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/utils/uuid.js":
/*!***********************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/utils/uuid.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   uuid: () => (/* binding */ uuid)
/* harmony export */ });
/* harmony import */ var _lib_nanoid_non_secure_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./../lib/nanoid/non-secure/index.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/lib/nanoid/non-secure/index.js");


const uuid = (0,_lib_nanoid_non_secure_index_js__WEBPACK_IMPORTED_MODULE_0__.customAlphabet)('qazwsxedcrfvtgbyhnujmikol', 6);




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/floatingOneTap/analytics/FloatingOneTapStatsCollector.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/widgets/floatingOneTap/analytics/FloatingOneTapStatsCollector.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FloatingOneTapStatsCollector: () => (/* binding */ FloatingOneTapStatsCollector)
/* harmony export */ });
/* harmony import */ var _core_analytics_RegistrationStatsCollector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/analytics/RegistrationStatsCollector.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/analytics/RegistrationStatsCollector.js");
/* harmony import */ var _core_analytics_types_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/analytics/types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/analytics/types.js");
/* harmony import */ var _core_analytics_ProductionStatsCollector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/analytics/ProductionStatsCollector.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/analytics/ProductionStatsCollector.js");
/* harmony import */ var _core_analytics_ActionStatsCollector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/analytics/ActionStatsCollector.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/analytics/ActionStatsCollector.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constants.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/floatingOneTap/analytics/constants.js");






class FloatingOneTapStatsCollector {
    registrationStatsCollector;
    uniqueSessionId;
    constructor(config){
        const productStatsCollector = new _core_analytics_ProductionStatsCollector_js__WEBPACK_IMPORTED_MODULE_0__.ProductionStatsCollector(config);
        const actionStatsCollector = new _core_analytics_ActionStatsCollector_js__WEBPACK_IMPORTED_MODULE_1__.ActionStatsCollector(productStatsCollector);
        this.registrationStatsCollector = new _core_analytics_RegistrationStatsCollector_js__WEBPACK_IMPORTED_MODULE_2__.RegistrationStatsCollector(actionStatsCollector);
    }
    setUniqueSessionId(id) {
        this.uniqueSessionId = id;
    }
    getFields() {
        const fields = [
            {
                name: 'sdk_type',
                value: 'vkid'
            }
        ];
        if (this.uniqueSessionId) {
            fields.push({
                name: 'unique_session_id',
                value: this.uniqueSessionId
            });
        }
        return fields;
    }
    sendScreenProceed(params) {
        void this.registrationStatsCollector.logEvent(_core_analytics_types_js__WEBPACK_IMPORTED_MODULE_3__.ProductionStatsEventScreen.NOWHERE, {
            event_type: 'screen_proceed',
            screen_to: _core_analytics_types_js__WEBPACK_IMPORTED_MODULE_3__.ProductionStatsEventScreen.FLOATING_ONE_TAP,
            fields: [
                ...this.getFields(),
                {
                    name: 'theme_type',
                    value: params.scheme
                },
                {
                    name: 'language',
                    value: params.lang.toString()
                },
                {
                    name: 'text_type',
                    value: _constants_js__WEBPACK_IMPORTED_MODULE_4__.TEXT_TYPE[params.contentId]
                }
            ]
        });
    }
    sendIframeLoadingFailed() {
        void this.registrationStatsCollector.logEvent(_core_analytics_types_js__WEBPACK_IMPORTED_MODULE_3__.ProductionStatsEventScreen.FLOATING_ONE_TAP, {
            event_type: 'iframe_loading_failed',
            fields: this.getFields()
        });
    }
    sendNoUserButtonShow() {
        void this.registrationStatsCollector.logEvent(_core_analytics_types_js__WEBPACK_IMPORTED_MODULE_3__.ProductionStatsEventScreen.FLOATING_ONE_TAP, {
            event_type: 'no_user_button_show',
            fields: this.getFields()
        });
    }
    sendNoUserButtonTap() {
        return this.registrationStatsCollector.logEvent(_core_analytics_types_js__WEBPACK_IMPORTED_MODULE_3__.ProductionStatsEventScreen.FLOATING_ONE_TAP, {
            event_type: 'no_user_button_tap',
            fields: this.getFields()
        });
    }
}




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/floatingOneTap/analytics/constants.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/widgets/floatingOneTap/analytics/constants.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TEXT_TYPE: () => (/* binding */ TEXT_TYPE)
/* harmony export */ });
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/floatingOneTap/types.js");


const TEXT_TYPE = {
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.FloatingOneTapContentId.SIGN_IN_TO_SERVICE]: 'service_sign_in',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.FloatingOneTapContentId.REGISTRATION_FOR_EVENT]: 'event_reg',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.FloatingOneTapContentId.SUBMIT_APPLICATIONS]: 'request',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.FloatingOneTapContentId.MAKE_ORDER_WITH_SERVICE]: 'service_order_placing',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.FloatingOneTapContentId.MAKE_ORDER_WITHOUT_SERVICE]: 'vkid_order_placing',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.FloatingOneTapContentId.SIGN_IN_TO_ACCOUNT]: 'account_sign_in',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.FloatingOneTapContentId.FAST_REGISTRATION]: 'fast_reg'
};




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/floatingOneTap/events.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/widgets/floatingOneTap/events.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FloatingOneTapInternalEvents: () => (/* binding */ FloatingOneTapInternalEvents)
/* harmony export */ });
var FloatingOneTapInternalEvents;
(function(FloatingOneTapInternalEvents) {
    FloatingOneTapInternalEvents["LOGIN_SUCCESS"] = 'floatingonetap: success login';
    FloatingOneTapInternalEvents["SHOW_FULL_AUTH"] = 'floatingonetap: show full auth';
    FloatingOneTapInternalEvents["START_AUTHORIZE"] = 'floatingonetap: start authorize';
    FloatingOneTapInternalEvents["NOT_AUTHORIZED"] = 'floatingonetap: not authorized';
})(FloatingOneTapInternalEvents || (FloatingOneTapInternalEvents = {}));




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/floatingOneTap/floatingOneTap.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/widgets/floatingOneTap/floatingOneTap.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FloatingOneTap: () => (/* binding */ FloatingOneTap)
/* harmony export */ });
/* harmony import */ var _auth_types_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../auth/types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/auth/types.js");
/* harmony import */ var _core_analytics_types_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../core/analytics/types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/analytics/types.js");
/* harmony import */ var _core_config_types_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../core/config/types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/config/types.js");
/* harmony import */ var _core_validator_validator_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../core/validator/validator.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/validator/validator.js");
/* harmony import */ var _core_validator_rules_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../core/validator/rules.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/validator/rules.js");
/* harmony import */ var _core_widget_widget_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/widget/widget.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/widget/widget.js");
/* harmony import */ var _core_widget_events_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/widget/events.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/widget/events.js");
/* harmony import */ var _core_widget_types_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/widget/types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/widget/types.js");
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/types.js");
/* harmony import */ var _oauthList_oauthList_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../oauthList/oauthList.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oauthList/oauthList.js");
/* harmony import */ var _oauthList_types_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../oauthList/types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oauthList/types.js");
/* harmony import */ var _oauthList_events_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../oauthList/events.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oauthList/events.js");
/* harmony import */ var _analytics_FloatingOneTapStatsCollector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./analytics/FloatingOneTapStatsCollector.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/floatingOneTap/analytics/FloatingOneTapStatsCollector.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/floatingOneTap/events.js");
/* harmony import */ var _template_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./template.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/floatingOneTap/template.js");
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/floatingOneTap/types.js");


















function _ts_decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}
const defaultIndent = {
    top: 12,
    right: 12,
    bottom: 12
};
class FloatingOneTap extends _core_widget_widget_js__WEBPACK_IMPORTED_MODULE_0__.Widget {
    analytics;
    vkidAppName = 'floating_one_tap_auth';
    constructor(){
        super();
        this.analytics = new _analytics_FloatingOneTapStatsCollector_js__WEBPACK_IMPORTED_MODULE_1__.FloatingOneTapStatsCollector(FloatingOneTap.config);
    }
    sendSuccessLoginEvent = (params)=>{
        this.events.emit(_events_js__WEBPACK_IMPORTED_MODULE_2__.FloatingOneTapInternalEvents.LOGIN_SUCCESS, params);
    };
    onBridgeMessageHandler(event) {
        switch(event.handler){
            case _events_js__WEBPACK_IMPORTED_MODULE_2__.FloatingOneTapInternalEvents.SHOW_FULL_AUTH:
                {
                    const params = event.params;
                    const authParams = {};
                    if (params.screen) {
                        authParams.screen = params.screen;
                    }
                    if (params.sdk_oauth) {
                        authParams.provider = params.sdk_oauth;
                        authParams.statsFlowSource = _auth_types_js__WEBPACK_IMPORTED_MODULE_3__.AuthStatsFlowSource.MULTIBRANDING;
                    }
                    this.openFullAuth(authParams);
                    break;
                }
            case _events_js__WEBPACK_IMPORTED_MODULE_2__.FloatingOneTapInternalEvents.NOT_AUTHORIZED:
                {
                    this.setState(_core_widget_types_js__WEBPACK_IMPORTED_MODULE_4__.WidgetState.NOT_LOADED);
                    setTimeout(()=>{
                        // Ожидает выполнение анимации и меняет ui
                        this.setState(_core_widget_types_js__WEBPACK_IMPORTED_MODULE_4__.WidgetState.LOADED);
                    }, 500);
                    clearTimeout(this.timeoutTimer);
                    break;
                }
            default:
                {
                    super.onBridgeMessageHandler(event);
                    break;
                }
        }
    }
    onErrorHandler(error) {
        this.analytics.sendIframeLoadingFailed();
        this.analytics.sendNoUserButtonShow();
        super.onErrorHandler(error);
    }
    openFullAuth(value) {
        const params = {
            statsFlowSource: _auth_types_js__WEBPACK_IMPORTED_MODULE_3__.AuthStatsFlowSource.FLOATING_ONE_TAP,
            ...value,
            uniqueSessionId: this.id,
            lang: this.lang,
            scheme: this.scheme
        };
        FloatingOneTap.auth.login(params).then(this.sendSuccessLoginEvent).catch((error)=>{
            this.events.emit(_core_widget_events_js__WEBPACK_IMPORTED_MODULE_5__.WidgetEvents.ERROR, {
                code: _core_widget_types_js__WEBPACK_IMPORTED_MODULE_4__.WidgetErrorCode.AuthError,
                text: error.error
            });
        });
    }
    login(value) {
        if (this.config.get().mode === _core_config_types_js__WEBPACK_IMPORTED_MODULE_6__.ConfigAuthMode.Redirect) {
            this.analytics.sendNoUserButtonTap().finally(()=>{
                this.openFullAuth(value);
            });
        } else {
            void this.analytics.sendNoUserButtonTap();
            this.openFullAuth(value);
        }
    }
    renderOAuthList(params) {
        if (!params.oauthList.length) {
            return;
        }
        const oauthList = new _oauthList_oauthList_js__WEBPACK_IMPORTED_MODULE_7__.OAuthList();
        oauthList.on(_oauthList_events_js__WEBPACK_IMPORTED_MODULE_8__.OAuthListInternalEvents.LOGIN_SUCCESS, this.sendSuccessLoginEvent).render({
            ...params,
            flowSource: _core_analytics_types_js__WEBPACK_IMPORTED_MODULE_9__.ProductionStatsEventScreen.FLOATING_ONE_TAP,
            uniqueSessionId: this.id
        });
    }
    render(params) {
        this.lang = params?.lang || _types_js__WEBPACK_IMPORTED_MODULE_10__.Languages.RUS;
        this.scheme = params?.scheme || _types_js__WEBPACK_IMPORTED_MODULE_10__.Scheme.LIGHT;
        const providers = (params.oauthList || []).filter((provider)=>provider !== _oauthList_types_js__WEBPACK_IMPORTED_MODULE_11__.OAuthName.VK);
        const queryParams = {
            scheme: this.scheme,
            lang_id: this.lang,
            show_alternative_login: params?.showAlternativeLogin ? 1 : 0,
            content_id: params?.contentId || _types_js__WEBPACK_IMPORTED_MODULE_12__.FloatingOneTapContentId.SIGN_IN_TO_SERVICE,
            providers: providers.join(','),
            uuid: this.id
        };
        this.analytics.setUniqueSessionId(this.id);
        this.templateRenderer = (0,_template_js__WEBPACK_IMPORTED_MODULE_13__.getFloatingOneTapTemplate)({
            login: this.login.bind(this),
            close: this.close.bind(this),
            scheme: this.scheme,
            lang: this.lang,
            indent: Object.assign(defaultIndent, params.indent || {}),
            contentId: queryParams.content_id,
            appName: params.appName,
            renderOAuthList: this.renderOAuthList.bind(this),
            providers
        });
        this.analytics.sendScreenProceed({
            scheme: this.scheme,
            lang: this.lang,
            contentId: queryParams.content_id
        });
        if (params.fastAuthEnabled === false) {
            this.analytics.sendNoUserButtonShow();
            queryParams.fastAuthDisabled = true;
        }
        return super.render({
            container: document.body,
            ...queryParams
        });
    }
}
_ts_decorate([
    (0,_core_validator_validator_js__WEBPACK_IMPORTED_MODULE_14__.validator)({
        appName: [
            _core_validator_rules_js__WEBPACK_IMPORTED_MODULE_15__.isRequired
        ]
    })
], FloatingOneTap.prototype, "render", null);




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/floatingOneTap/langs/buttonLang.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/widgets/floatingOneTap/langs/buttonLang.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getButtonLang: () => (/* binding */ getButtonLang)
/* harmony export */ });
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/types.js");
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/floatingOneTap/types.js");



const SIGN_IN = {
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.RUS]: 'Войти с VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UKR]: 'Увійти з VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.BEL]: 'Увайсці з VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.KAZ]: 'VK ID арқылы кіру',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UZB]: 'VK ID yordamida kirish',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.ENG]: 'Sign in with VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.SPA]: 'Iniciar sesión con VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.GERMAN]: 'Mit VK-ID anmelden',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.POL]: 'Wejdź z VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.FRA]: 'Se connecter avec VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.TURKEY]: 'VK ID aracılığıyla gir'
};
const MAKE_ORDER = {
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.RUS]: 'Оформить с VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UKR]: 'Оформити з VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.BEL]: 'Аформіць з VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.KAZ]: 'VK ID арқылы рәсімдеу',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UZB]: 'VK ID yordamida shakllantirish',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.ENG]: 'Order with VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.SPA]: 'Pedir con VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.GERMAN]: 'Mit VK-ID bestellen',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.POL]: 'Wypełnij z VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.FRA]: 'Commander avec VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.TURKEY]: 'VK ID aracılığıyla oluştur'
};
const CONTINUE = {
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.RUS]: 'Продолжить с VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UKR]: 'Продовжити з VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.BEL]: 'Працягнуць з VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.KAZ]: 'VK ID арқылы жалғастыру',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UZB]: 'VK ID bilan davom etish',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.ENG]: 'Continue with VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.SPA]: 'Continuar con VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.GERMAN]: 'Mit VK ID fortfahren',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.POL]: 'Kontynuuj z VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.FRA]: 'Continuer avec VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.TURKEY]: 'VK ID ile devam et'
};
const getButtonLang = (contentId, lang)=>{
    switch(contentId){
        case _types_js__WEBPACK_IMPORTED_MODULE_1__.FloatingOneTapContentId.SIGN_IN_TO_SERVICE:
        case _types_js__WEBPACK_IMPORTED_MODULE_1__.FloatingOneTapContentId.SIGN_IN_TO_ACCOUNT:
        case _types_js__WEBPACK_IMPORTED_MODULE_1__.FloatingOneTapContentId.REGISTRATION_FOR_EVENT:
        case _types_js__WEBPACK_IMPORTED_MODULE_1__.FloatingOneTapContentId.SUBMIT_APPLICATIONS:
            return SIGN_IN[lang] || SIGN_IN[_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.RUS];
        case _types_js__WEBPACK_IMPORTED_MODULE_1__.FloatingOneTapContentId.MAKE_ORDER_WITH_SERVICE:
        case _types_js__WEBPACK_IMPORTED_MODULE_1__.FloatingOneTapContentId.MAKE_ORDER_WITHOUT_SERVICE:
            return MAKE_ORDER[lang] || MAKE_ORDER[_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.RUS];
        case _types_js__WEBPACK_IMPORTED_MODULE_1__.FloatingOneTapContentId.FAST_REGISTRATION:
            return CONTINUE[lang] || CONTINUE[_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.RUS];
        default:
            return SIGN_IN[_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.RUS];
    }
};




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/floatingOneTap/langs/descriptionLang.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/widgets/floatingOneTap/langs/descriptionLang.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getDescriptionLang: () => (/* binding */ getDescriptionLang)
/* harmony export */ });
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/types.js");


const DESCRIPTION = {
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.RUS]: 'После этого вам станут доступны все возможности сервиса. Ваши данные будут надёжно защищены.',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UKR]: 'Після цього вам стануть доступні всі можливості сервісу. Ваші дані будуть надійно захищені.',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.BEL]: 'Пасля гэтага вам стануць даступны ўсе магчымасці сэрвісу. Вашы даныя будуць надзейна абаронены.',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.KAZ]: 'Содан кейін сізге сервистің барлық мүмкіндігі қолжетімді болып, деректеріңіз сенімді қораулы болады.',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UZB]: 'Bundan so‘ng, sizga xizmatning barcha imkoniyatlari ochiladi. Maʼlumotlaringiz ishonchli himoyalanadi.',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.ENG]: 'Afterwards, you\'ll have access to\u00A0all of\u00A0the\u00A0service\'s features. Your personal data will be carefully protected.',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.SPA]: 'Después, tendrás acceso a\u00A0todas las funciones del\u00A0servicio. Tus datos personales estarán cuidadosamente protegidos.',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.GERMAN]: 'Anschließend stehen Ihnen alle Funktionen des Dienstes zur Verfügung. Ihre\u00A0persönlichen Daten werden sorgfältig geschützt.',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.POL]: 'Po tym wszystkie funkcje serwisu będą dostępne. Twoje dane będą dobrze chronione.',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.FRA]: 'Cela vous permettra d\'avoir accès à\u00A0toutes les\u00A0fonctionnalités du service. Vos données personnelles seront soigneusement protégées.',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.TURKEY]: 'Bundan sonra hizmetin tüm özellikleri kullanımınıza sunulacaktır. Verileriniz güvenilir bir şekilde korunacaktır.'
};
const getDescriptionLang = (lang)=>{
    return DESCRIPTION[lang] || DESCRIPTION[_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.RUS];
};




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/floatingOneTap/langs/titleLang.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/widgets/floatingOneTap/langs/titleLang.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getTitleLang: () => (/* binding */ getTitleLang)
/* harmony export */ });
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/types.js");
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/floatingOneTap/types.js");



const SIGN_IN_TO_SERVICE = {
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.RUS]: 'Войдите в\u00A0сервис или\u00A0зарегистрируйтесь',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UKR]: 'Увійдіть у\u00A0сервіс або\u00A0зареєструйтеся',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.BEL]: 'Увайдзіце ў\u00A0сэрвіс ці\u00A0зарэгіструйцеся',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.KAZ]: 'Сервиске кіріңіз немесе тіркеліңіз',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UZB]: 'Xizmatga\u00A0kiring va\u00A0ro‘yxatdan o‘ting',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.ENG]: 'Sign in to\u00A0service or\u00A0sign up',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.SPA]: 'Acceder al\u00A0servicio o\u00A0registrarse',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.GERMAN]: 'Melden Sie sich beim\u00A0Dienst\u00A0an oder registrieren Sie\u00A0sich',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.POL]: 'Wejdź do\u00A0serwisu lub\u00A0zarejestruj się',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.FRA]: 'Connectez-vous au\u00A0service ou\u00A0inscrivez-vous',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.TURKEY]: 'Hizmete\u00A0girin yada\u00A0oturum oluşturun'
};
const SIGN_IN_TO_ACCOUNT = {
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.RUS]: 'Войдите в учётную запись {service}',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UKR]: 'Увійдіть в обліковий запис {service}',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.BEL]: 'Увайдзіце ва ўліковы запіс {service}',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.KAZ]: '{service} есептік жазбасына кіріңіз',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UZB]: '{service} hisobiga kiring',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.ENG]: 'Sign in to\u00A0{service} account',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.SPA]: 'Acceder a la cuenta\u00A0{service}',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.GERMAN]: 'Melden Sie sich bei Ihrem\u00A0{service}-Konto an',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.POL]: 'Wejdź na rachunek {service}',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.FRA]: 'Connectez-vous à\u00A0{service}',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.TURKEY]: '{service} hesabına girin'
};
const REGISTRATION_FOR_EVENT = {
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.RUS]: 'Зарегистрируйтесь на\u00A0мероприятие',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UKR]: 'Зареєструйтеся на\u00A0захід',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.BEL]: 'Зарэгіструйцеся на\u00A0мерапрыемства',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.KAZ]: 'Шараға тіркеліңіз',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UZB]: 'Tadbirda\u00A0ro‘yxatdan o‘ting',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.ENG]: 'Sign up for\u00A0event',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.SPA]: 'Registrarse en\u00A0el\u00A0evento',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.GERMAN]: 'Melden\u00A0Sie\u00A0sich für\u00A0die\u00A0Veranstaltung\u00A0an',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.POL]: 'Zarejestruj się na\u00A0wydarzenie',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.FRA]: 'Inscrivez-vous à\u00A0l\'événement',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.TURKEY]: 'Eylemde\u00A0kaydolun'
};
const SUBMIT_APPLICATIONS = {
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.RUS]: 'Подайте заявку с\u00A0VK\u00A0ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UKR]: 'Подайте запит з\u00A0VK\u00A0ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.BEL]: 'Падайце заяўку з\u00A0VK\u00A0ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.KAZ]: 'VK\u00A0ID арқылы тапсырыс жасаңыз',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UZB]: 'VK\u00A0ID\u00A0yordamida talabnoma berish',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.ENG]: 'Apply with\u00A0VK\u00A0ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.SPA]: 'Solicitar con\u00A0VK\u00A0ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.GERMAN]: 'Bewerben Sie mit\u00A0VK-ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.POL]: 'Złóż wniosek z\u00A0VK\u00A0ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.FRA]: 'Envoyez une\u00A0demande avec\u00A0VK\u00A0ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.TURKEY]: 'VK\u00A0ID\u00A0yardımıyla başvuru gönderin'
};
const MAKE_ORDER_WITH_SERVICE = {
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.RUS]: 'Оформите заказ в\u00A0{service} с\u00A0VK\u00A0ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UKR]: 'Оформіть замовлення в\u00A0{service} з\u00A0VK\u00A0ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.BEL]: 'Аформіце заказ у\u00A0{service} з\u00A0VK\u00A0ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.KAZ]: '{service} сервисінде \u00A0VK\u00A0ID арқылы тапсырыс жасаңыз',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UZB]: 'VK\u00A0ID\u00A0orqali {service}\u00A0da buyurtma\u00A0shakllantirish',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.ENG]: 'Place order on\u00A0{service} with\u00A0VK\u00A0ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.SPA]: 'Realizar pedido en\u00A0{service} con\u00A0VK\u00A0ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.GERMAN]: 'Machen Sie eine\u00A0Bestellung auf\u00A0{service} mit\u00A0VK-ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.POL]: 'Wypełnij zamówienie w\u00A0{service} z\u00A0VK\u00A0ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.FRA]: 'Passez la\u00A0commande sur\u00A0{service} avec\u00A0VK\u00A0ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.TURKEY]: 'VK\u00A0ID\u00A0aracılığıyla {service} te sipariş oluşturun'
};
const MAKE_ORDER_WITHOUT_SERVICE = {
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.RUS]: 'Оформите заказ с\u00A0VK\u00A0ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UKR]: 'Оформіть замовлення з\u00A0VK\u00A0ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.BEL]: 'Аформіце заказ з\u00A0VK\u00A0ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.KAZ]: 'VK\u00A0ID арқылы тапсырыс жасаңыз',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UZB]: 'VK\u00A0ID\u00A0orqali buyurtmani shakllantirish',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.ENG]: 'Place order with\u00A0VK\u00A0ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.SPA]: 'Realizar pedido con\u00A0VK\u00A0ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.GERMAN]: 'Machen Sie eine\u00A0Bestellung mit\u00A0VK-ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.POL]: 'Wypełnij zamówienie z\u00A0VK\u00A0ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.FRA]: 'Passez la\u00A0commande avec\u00A0VK\u00A0ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.TURKEY]: 'VK\u00A0ID\u00A0aracılığıyla sipariş oluşturun'
};
const FAST_REGISTRATION = {
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.RUS]: 'Быстрая регистрация\nв\u00A0{service}',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UKR]: 'Швидка реєстрація в\u00A0{service}',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.BEL]: 'Хуткая рэгістрацыя ў\u00A0{service}',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.KAZ]: '{service} сервисіне тез тіркелу',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UZB]: '{service}\u00A0da tezkor ro‘yxatdan o‘tish',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.ENG]: 'Quick sign-up with\u00A0{service}',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.SPA]: 'Registro rápido con\u00A0{service}',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.GERMAN]: 'Schnelle Registrierung bei\u00A0{service}',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.POL]: 'Szybka rejestracja w\u00A0{service}',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.FRA]: 'Inscription rapide avec\u00A0{service}',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.TURKEY]: '{service}\'te\u00A0hızlı oturum açma'
};
const getTitleLang = (contentId, lang, appName)=>{
    let result = SIGN_IN_TO_SERVICE[_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.RUS];
    switch(contentId){
        case _types_js__WEBPACK_IMPORTED_MODULE_1__.FloatingOneTapContentId.SIGN_IN_TO_SERVICE:
            result = SIGN_IN_TO_SERVICE[lang];
            break;
        case _types_js__WEBPACK_IMPORTED_MODULE_1__.FloatingOneTapContentId.SIGN_IN_TO_ACCOUNT:
            result = SIGN_IN_TO_ACCOUNT[lang];
            break;
        case _types_js__WEBPACK_IMPORTED_MODULE_1__.FloatingOneTapContentId.REGISTRATION_FOR_EVENT:
            result = REGISTRATION_FOR_EVENT[lang];
            break;
        case _types_js__WEBPACK_IMPORTED_MODULE_1__.FloatingOneTapContentId.SUBMIT_APPLICATIONS:
            result = SUBMIT_APPLICATIONS[lang];
            break;
        case _types_js__WEBPACK_IMPORTED_MODULE_1__.FloatingOneTapContentId.MAKE_ORDER_WITH_SERVICE:
            result = MAKE_ORDER_WITH_SERVICE[lang];
            break;
        case _types_js__WEBPACK_IMPORTED_MODULE_1__.FloatingOneTapContentId.MAKE_ORDER_WITHOUT_SERVICE:
            result = MAKE_ORDER_WITHOUT_SERVICE[lang];
            break;
        case _types_js__WEBPACK_IMPORTED_MODULE_1__.FloatingOneTapContentId.FAST_REGISTRATION:
            result = FAST_REGISTRATION[lang];
            break;
    }
    return result.replace('{service}', appName);
};




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/floatingOneTap/template.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/widgets/floatingOneTap/template.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getFloatingOneTapTemplate: () => (/* binding */ getFloatingOneTapTemplate)
/* harmony export */ });
/* harmony import */ var _langs_buttonLang_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./langs/buttonLang.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/floatingOneTap/langs/buttonLang.js");
/* harmony import */ var _langs_titleLang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./langs/titleLang.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/floatingOneTap/langs/titleLang.js");
/* harmony import */ var _langs_descriptionLang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./langs/descriptionLang.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/floatingOneTap/langs/descriptionLang.js");




const logoVkIdSvg = `
  <svg width="33" height="16" viewBox="0 0 33 16" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M20 13H21.6479V3.5H20V13Z" fill="var(--floating--color_text_primary)"/>
    <path d="M23.7801 13H27.474C30.4127 13 32.5 11.0326 32.5 8.24326C32.5 5.46738 30.4127 3.5 27.474 3.5H23.7801V13ZM25.4279 11.5177V4.98227H27.474C29.4377 4.98227 30.7835 6.31631 30.7835 8.24326C30.7835 10.1837 29.4377 11.5177 27.474 11.5177H25.4279Z" fill="var(--floating--color_text_primary)"/>
    <path d="M0 7.68C0 4.05961 0 2.24942 1.12471 1.12471C2.24942 0 4.05961 0 7.68 0H8.32C11.9404 0 13.7506 0 14.8753 1.12471C16 2.24942 16 4.05961 16 7.68V8.32C16 11.9404 16 13.7506 14.8753 14.8753C13.7506 16 11.9404 16 8.32 16H7.68C4.05961 16 2.24942 16 1.12471 14.8753C0 13.7506 0 11.9404 0 8.32V7.68Z" fill="#0077FF"/>
    <path d="M8.56331 11.66C4.91665 11.66 2.83667 9.16 2.75 5H4.57666C4.63666 8.05333 5.9833 9.34333 7.04997 9.61V5H8.77002V7.63C9.82335 7.51667 10.9299 6.32 11.3032 5H13.0233C12.7366 6.62667 11.5366 7.82667 10.6833 8.32C11.5366 8.72 12.9033 9.76667 13.4233 11.66H11.5299C11.1233 10.3933 10.11 9.41333 8.77002 9.28V11.66H8.56331Z" fill="white"/>
  </svg>
`;
const logoVkSvg = `
  <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path fill-rule="evenodd" clip-rule="evenodd" d="M4.2653 4.2653C3 5.5306 3 7.56707 3 11.64V12.36C3 16.4329 3 18.4694 4.2653 19.7347C5.5306 21 7.56706 21 11.64 21H12.36C16.4329 21 18.4694 21 19.7347 19.7347C21 18.4694 21 16.4329 21 12.36V11.64C21 7.56707 21 5.5306 19.7347 4.2653C18.4694 3 16.4329 3 12.36 3H11.64C7.56706 3 5.5306 3 4.2653 4.2653Z" fill="white"/>
    <path d="M12.6095 16C8.55576 16 6.09636 13.1823 6 8.5H8.05309C8.1171 11.9395 9.67903 13.397 10.8764 13.6967V8.5H12.8439V11.4683C13.9988 11.3401 15.2076 9.98991 15.614 8.5H17.5505C17.2406 10.3321 15.9246 11.6823 14.9948 12.2392C15.9253 12.6895 17.4225 13.8682 18 16H15.8714C15.4219 14.5749 14.321 13.4712 12.8446 13.3213V16H12.6095Z" fill="#0077FF"/>
  </svg>
`;
const closeSvg = `
  <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path fill-rule="evenodd" clip-rule="evenodd" d="M4.71967 4.71969C5.01256 4.42679 5.48744 4.42679 5.78033 4.71969L10 8.93935L14.2197 4.71969C14.5126 4.42679 14.9874 4.42679 15.2803 4.71969C15.5732 5.01258 15.5732 5.48745 15.2803 5.78035L11.0607 10L15.2803 14.2197C15.5732 14.5126 15.5732 14.9875 15.2803 15.2803C14.9874 15.5732 14.5126 15.5732 14.2197 15.2803L10 11.0607L5.78033 15.2803C5.48744 15.5732 5.01256 15.5732 4.71967 15.2803C4.42678 14.9875 4.42678 14.5126 4.71967 14.2197L8.93934 10L4.71967 5.78035C4.42678 5.48745 4.42678 5.01258 4.71967 4.71969Z" fill="currentColor"/>
  </svg>
`;
const spinnerSvg = `
  <svg width="28" height="28" viewBox="0 0 28 28" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M14 22C13.4477 22 13 21.5523 13 21C13 20.4477 13.4477 20 14 20C17.3137 20 20 17.3137 20 14C20 10.6863 17.3137 8 14 8C10.6863 8 8 10.6863 8 14C8 14.6472 8.10214 15.2793 8.3002 15.8802C8.4731 16.4047 8.18807 16.9701 7.66355 17.143C7.13902 17.3159 6.57365 17.0308 6.40074 16.5063C6.13628 15.7041 6 14.8606 6 14C6 9.58172 9.58172 6 14 6C18.4183 6 22 9.58172 22 14C22 18.4183 18.4183 22 14 22Z" fill="currentColor"/>
  </svg>
`;
const INTERNAL_INDENT = 12;
const getIndent = (value)=>{
    if (!value || value <= INTERNAL_INDENT) {
        return 0;
    }
    return value - INTERNAL_INDENT;
};
const getFloatingOneTapTemplate = ({ scheme, indent, login, close, lang, contentId, appName, providers, renderOAuthList })=>(id)=>{
        const titleText = (0,_langs_titleLang_js__WEBPACK_IMPORTED_MODULE_0__.getTitleLang)(contentId, lang, appName);
        const descriptionText = (0,_langs_descriptionLang_js__WEBPACK_IMPORTED_MODULE_1__.getDescriptionLang)(lang);
        const buttonText = (0,_langs_buttonLang_js__WEBPACK_IMPORTED_MODULE_2__.getButtonLang)(contentId, lang);
        const floatingEl = document.createElement('div');
        floatingEl.classList.add(`VkIdWebSdk__floating_${id}`);
        const containerEl = document.createElement('div');
        containerEl.classList.add(`VkIdWebSdk__floating_container_${id}`);
        const headerEl = document.createElement('div');
        headerEl.classList.add(`VkIdWebSdk__floating_header_${id}`);
        headerEl.innerHTML = logoVkIdSvg;
        const headerAppNameEl = document.createElement('span');
        headerAppNameEl.classList.add(`VkIdWebSdk__floating_appName_${id}`);
        headerAppNameEl.innerText = `\u00A0·\u00A0${appName}`;
        const headerCloseEl = document.createElement('div');
        headerCloseEl.classList.add(`VkIdWebSdk__floating_close_${id}`);
        const headerCloseButtonEl = document.createElement('button');
        headerCloseButtonEl.classList.add(`VkIdWebSdk__floating_button_reset_${id}`);
        headerCloseButtonEl.classList.add(`VkIdWebSdk__floating_close_btn_${id}`);
        headerCloseButtonEl.innerHTML = closeSvg;
        close && (headerCloseButtonEl.onclick = close);
        const contentEl = document.createElement('div');
        contentEl.classList.add(`VkIdWebSdk__floating_content_${id}`);
        const titleEl = document.createElement('div');
        titleEl.classList.add(`VkIdWebSdk__floating_title_${id}`);
        titleEl.innerText = titleText;
        const descriptionEl = document.createElement('div');
        descriptionEl.classList.add(`VkIdWebSdk__floating_description_${id}`);
        descriptionEl.innerText = descriptionText;
        const actionEl = document.createElement('div');
        const buttonEl = document.createElement('button');
        buttonEl.classList.add(`VkIdWebSdk__floating_button_reset_${id}`);
        buttonEl.classList.add(`VkIdWebSdk__floating_button_${id}`);
        login && (buttonEl.onclick = login);
        const buttonContentEl = document.createElement('div');
        buttonContentEl.classList.add(`VkIdWebSdk__floating_button_content_${id}`);
        const buttonLogoEl = document.createElement('span');
        buttonLogoEl.classList.add(`VkIdWebSdk__floating_button_logo_${id}`);
        buttonLogoEl.innerHTML = logoVkSvg;
        const buttonTextEl = document.createElement('span');
        buttonTextEl.classList.add(`VkIdWebSdk__floating_button_text_${id}`);
        buttonTextEl.innerText = buttonText;
        const buttonSpinnerEl = document.createElement('span');
        buttonSpinnerEl.classList.add(`VkIdWebSdk__floating_button_spinner_${id}`);
        buttonSpinnerEl.innerHTML = spinnerSvg;
        const oauthListEl = document.createElement('div');
        oauthListEl.classList.add(`VkIdWebSdk__oauthList_container_${id}`);
        const handleLoaded = ()=>{
            const floatingOneTap = document.getElementById(id);
            if (floatingOneTap) {
                floatingOneTap.appendChild(floatingEl);
                floatingEl.appendChild(containerEl);
                containerEl.appendChild(headerEl);
                containerEl.appendChild(contentEl);
                containerEl.appendChild(actionEl);
                headerEl.appendChild(headerCloseEl);
                headerEl.appendChild(headerAppNameEl);
                headerCloseEl.appendChild(headerCloseButtonEl);
                contentEl.appendChild(titleEl);
                contentEl.appendChild(descriptionEl);
                actionEl.appendChild(buttonEl);
                buttonEl.appendChild(buttonContentEl);
                buttonContentEl.appendChild(buttonLogoEl);
                buttonContentEl.appendChild(buttonTextEl);
                buttonContentEl.appendChild(buttonSpinnerEl);
                if (providers?.length) {
                    containerEl.appendChild(oauthListEl);
                    renderOAuthList({
                        lang,
                        scheme,
                        container: oauthListEl,
                        oauthList: providers,
                        styles: {
                            borderRadius: 8,
                            height: 36
                        }
                    });
                }
            }
        };
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', handleLoaded);
        } else {
            setTimeout(handleLoaded, 0);
        }
        return `
<div id="${id}" data-test-id="floatingOneTap" data-scheme="${scheme}">
  <style>
    :root #${id} {
      --floating--contaner_padding: 16px;
      --floating--container_box_shadow: 0px 0px 2px rgba(0,0,0,.08),0px 4px 16px rgba(0,0,0,.08);
      --floating--font_family: -apple-system,system-ui,"Helvetica Neue",Roboto,sans-serif;
      --floating--close_button_color_transparent--hover: rgba(0,16,61,.04);
      --floating--close_button_color_transparent--active: rgba(0,16,61,.08);
      --floating--button_text_color: #FFFFFF;
      --floating--button_background_color: #0077ff;
    }

    :root #${id}[data-scheme=light] {
      --floating--color_background_modal: #ffffff;
      --floating--color_icon_medium: #818c99;
      --floating--color_text_primary: #000000;
      --floating--color_text_secondary: #818c99;
      --floating--button_background_color--hover: #0071F2;
      --floating--button_background_color--focus: #0071F2;
      --floating--button_background_color--active: #0069E1;
    }

    :root #${id}[data-scheme=dark] {
      --floating--color_background_modal: #1C1D1E;
      --floating--color_icon_medium: #b0b1b6;
      --floating--color_text_primary: #e1e3e6;
      --floating--color_text_secondary: #76787a;
      --floating--button_background_color--hover: #097EFF;
      --floating--button_background_color--focus: #097EFF;
      --floating--button_background_color--active: #1385FF;
      --floating--close_button_color_transparent--hover: hsla(0,0%,100%,.04);
      --floating--close_button_color_transparent--active: hsla(0,0%,100%,.08);
      --floating--container_box_shadow: 0px 0px 2px 0px rgba(0, 0, 0, 0.30), 0px 4px 16px 0px rgba(0, 0, 0, 0.30);
    }

    #${id} {
      position: fixed;
      z-index: 99999;
    }

    #${id} iframe {
      position: absolute;
      opacity: 0;
      pointer-events: none;
      border: none;
      color-scheme: auto;
    }

    #${id} .VkIdWebSdk__floating_button_reset_${id} {
      border: none;
      margin: 0;
      padding: 0;
      width: auto;
      overflow: visible;
      background: transparent;
      color: inherit;
      font: inherit;
      line-height: normal;
      -webkit-font-smoothing: inherit;
      -moz-osx-font-smoothing: inherit;
      -webkit-appearance: none;
    }

    #${id} .VkIdWebSdk__floating_${id} {
      padding: 12px;
    }

    #${id} .VkIdWebSdk__floating_container_${id} {
      background: var(--floating--color_background_modal);
      border-radius: 12px;
      padding: var(--floating--contaner_padding);
      box-shadow: var(--floating--container_box_shadow);
      box-sizing: border-box;
    }

    #${id} .VkIdWebSdk__floating_header_${id} {
      display: flex;
      align-items: center;
      position: relative;
      padding: 2px 0;
    }

    #${id} .VkIdWebSdk__floating_appName_${id} {
      font-family: var(--floating--font_family);
      font-weight: 400;
      font-size: 13px;
      line-height: 16px;
      color: var(--floating--color_text_secondary);
    }

    #${id} .VkIdWebSdk__floating_close_${id} {
      position: absolute;
      display: flex;
      align-items: center;
      justify-content: center;
      top: -4px;
      right: -4px;
      height: 28px;
      width: 28px;
      color: var(--floating--color_icon_medium);
    }

    #${id} .VkIdWebSdk__floating_close_btn_${id} {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: .15s;
    }

    #${id} .VkIdWebSdk__floating_close_btn_${id}:hover {
      cursor: pointer;
      background: var(--floating--close_button_color_transparent--hover);
    }

    #${id} .VkIdWebSdk__floating_close_btn_${id}:active {
      background: var(--floating--close_button_color_transparent--active);
    }

    #${id} .VkIdWebSdk__floating_content_${id} {
      padding: 36px 32px;
      text-align: center;
      font-family: var(--floating--font_family);
    }

    #${id} .VkIdWebSdk__floating_title_${id} {
      color: var(--floating--color_text_primary);
      font-weight: 500;
      font-size: 20px;
      line-height: 24px;
    }

    #${id} .VkIdWebSdk__floating_description_${id} {
      color: var(--floating--color_text_secondary);
      font-weight: 400;
      font-size: 15px;
      line-height: 20px;
      margin-top: 8px;
    }

    #${id} .VkIdWebSdk__floating_button_${id} {
      height: 36px;
      width: 100%;
      border-radius: 8px;
      color: var(--floating--button_text_color);
      transition: .15s;
      cursor: pointer;
      background: var(--floating--button_background_color);
    }

    #${id} .VkIdWebSdk__floating_button_${id}:hover {
      background: var(--floating--button_background_color--hover);
    }

    #${id} .VkIdWebSdk__floating_button_${id}:focus {
      background: var(--floating--button_background_color--focus);
    }

    #${id} .VkIdWebSdk__floating_button_${id}:active {
      background: var(--floating--button_background_color--active);
    }

    #${id} .VkIdWebSdk__floating_button_content_${id} {
     display: flex;
     justify-content: center;
     align-items: center;
     padding: 0 6px;
    }

    #${id} .VkIdWebSdk__floating_button_logo_${id},
    #${id} .VkIdWebSdk__floating_button_spinner_${id} {
      display: inline-flex;
    }

    #${id} .VkIdWebSdk__floating_button_spinner_${id} {
      width: 24px;
      animation: vkIdSdkButtonSpinner 0.7s linear infinite;
    }

    #${id} .VkIdWebSdk__floating_button_text_${id} {
      font-weight: 500;
      line-height: 20px;
      font-family: var(--floating--font_family);
      font-size: 15px;
      transition: .5s;
      min-width: max-content;
      margin-left: 6px;
      text-align: center;
    }

    #${id} .VkIdWebSdk__oauthList_container_${id} {
      margin-top: 16px;
    }

    #${id}[data-state=loaded] iframe {
      position: initial;
      opacity: 100;
      pointer-events: all;
    }

    #${id}[data-state=loaded] .VkIdWebSdk__floating_${id} {
      display: none;
    }

    #${id}[data-state=not_loaded] .VkIdWebSdk__floating_button_spinner_${id} {
      transition: .2s;
      opacity: 0;
      pointer-events: none;
      width: 0;
    }

    #${id}[data-state=loading] .VkIdWebSdk__floating_button_text_${id} {
      flex: 1;
    }

    @media (max-width: 480px) {
      #${id} {
        display: flex;
        align-items: flex-end;
        left: 0;
        right: 0;
        bottom: ${getIndent(indent.bottom)}px;
        width: 100%;
        height: 340px;
      }
    }
    @media (min-width: 481px) {
      #${id} {
        top: ${getIndent(indent.top)}px;
        right: ${getIndent(indent.right)}px;
        width: 384px;
        height: 360px;
      }
    }

    @keyframes vkIdSdkButtonSpinner {
      0% {
        transform: rotate(0deg);
      }
      100% {
        transform: rotate(360deg);
      }
    }
  </style>
  <iframe width="100%" height="100%" />
</div>
  `;
    };




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/floatingOneTap/types.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/widgets/floatingOneTap/types.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FloatingOneTapContentId: () => (/* binding */ FloatingOneTapContentId)
/* harmony export */ });
var FloatingOneTapContentId;
(function(FloatingOneTapContentId) {
    FloatingOneTapContentId[FloatingOneTapContentId[/**
   * Войти или зарегистрироваться
   */ "SIGN_IN_TO_SERVICE"] = 0] = "SIGN_IN_TO_SERVICE";
    FloatingOneTapContentId[FloatingOneTapContentId[/**
   * Войти в учетную запись сервиса
   */ "SIGN_IN_TO_ACCOUNT"] = 1] = "SIGN_IN_TO_ACCOUNT";
    FloatingOneTapContentId[FloatingOneTapContentId[/**
   * Регистрация на мероприятие
   */ "REGISTRATION_FOR_EVENT"] = 2] = "REGISTRATION_FOR_EVENT";
    FloatingOneTapContentId[FloatingOneTapContentId[/**
   * Подача заявки
   */ "SUBMIT_APPLICATIONS"] = 3] = "SUBMIT_APPLICATIONS";
    FloatingOneTapContentId[FloatingOneTapContentId[/**
   * Оформление заказа в сервисе
   */ "MAKE_ORDER_WITH_SERVICE"] = 4] = "MAKE_ORDER_WITH_SERVICE";
    FloatingOneTapContentId[FloatingOneTapContentId[/**
   * Оформление заказа
   */ "MAKE_ORDER_WITHOUT_SERVICE"] = 5] = "MAKE_ORDER_WITHOUT_SERVICE";
    FloatingOneTapContentId[FloatingOneTapContentId[/**
   * Быстрая регистрация
   */ "FAST_REGISTRATION"] = 6] = "FAST_REGISTRATION";
})(FloatingOneTapContentId || (FloatingOneTapContentId = {}));




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oauthList/analytics/OAuthListStatsCollector.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oauthList/analytics/OAuthListStatsCollector.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OAuthListStatsCollector: () => (/* binding */ OAuthListStatsCollector)
/* harmony export */ });
/* harmony import */ var _core_analytics_RegistrationStatsCollector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/analytics/RegistrationStatsCollector.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/analytics/RegistrationStatsCollector.js");
/* harmony import */ var _core_analytics_ProductionStatsCollector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/analytics/ProductionStatsCollector.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/analytics/ProductionStatsCollector.js");
/* harmony import */ var _core_analytics_ActionStatsCollector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/analytics/ActionStatsCollector.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/analytics/ActionStatsCollector.js");





class OAuthListStatsCollector {
    registrationStatsCollector;
    uniqueSessionId;
    constructor(config){
        const productStatsCollector = new _core_analytics_ProductionStatsCollector_js__WEBPACK_IMPORTED_MODULE_0__.ProductionStatsCollector(config);
        const actionStatsCollector = new _core_analytics_ActionStatsCollector_js__WEBPACK_IMPORTED_MODULE_1__.ActionStatsCollector(productStatsCollector);
        this.registrationStatsCollector = new _core_analytics_RegistrationStatsCollector_js__WEBPACK_IMPORTED_MODULE_2__.RegistrationStatsCollector(actionStatsCollector);
    }
    setUniqueSessionId(id) {
        this.uniqueSessionId = id;
    }
    getFields() {
        const fields = [
            {
                name: 'sdk_type',
                value: 'vkid'
            }
        ];
        if (this.uniqueSessionId) {
            fields.push({
                name: 'unique_session_id',
                value: this.uniqueSessionId
            });
        }
        return fields;
    }
    sendMultibrandingOauthAdded({ screen, fields }) {
        void this.registrationStatsCollector.logEvent(screen, {
            event_type: 'multibranding_oauth_added',
            fields: [
                ...this.getFields(),
                ...fields
            ]
        });
    }
    sendOkButtonShow({ screen, isIcon }) {
        void this.registrationStatsCollector.logEvent(screen, {
            event_type: 'ok_button_show',
            fields: [
                ...this.getFields(),
                {
                    name: 'button_type',
                    value: isIcon ? 'icon' : 'default'
                }
            ]
        });
    }
    sendVkButtonShow({ screen, isIcon }) {
        void this.registrationStatsCollector.logEvent(screen, {
            event_type: 'vk_button_show',
            fields: [
                ...this.getFields(),
                {
                    name: 'button_type',
                    value: isIcon ? 'icon' : 'default'
                }
            ]
        });
    }
    sendMailButtonShow({ screen, isIcon }) {
        void this.registrationStatsCollector.logEvent(screen, {
            event_type: 'mail_button_show',
            fields: [
                ...this.getFields(),
                {
                    name: 'button_type',
                    value: isIcon ? 'icon' : 'default'
                }
            ]
        });
    }
    sendVkButtonTap({ screen, isIcon }) {
        return this.registrationStatsCollector.logEvent(screen, {
            event_type: 'vk_button_tap',
            fields: [
                ...this.getFields(),
                {
                    name: 'button_type',
                    value: isIcon ? 'icon' : 'default'
                }
            ]
        });
    }
    sendOkButtonTap({ screen, isIcon }) {
        return this.registrationStatsCollector.logEvent(screen, {
            event_type: 'ok_button_tap',
            fields: [
                ...this.getFields(),
                {
                    name: 'button_type',
                    value: isIcon ? 'icon' : 'default'
                }
            ]
        });
    }
    sendMailButtonTap({ screen, isIcon }) {
        return this.registrationStatsCollector.logEvent(screen, {
            event_type: 'mail_button_tap',
            fields: [
                ...this.getFields(),
                {
                    name: 'button_type',
                    value: isIcon ? 'icon' : 'default'
                }
            ]
        });
    }
}




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oauthList/analytics/types.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oauthList/analytics/types.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MultibrandingStatsProviders: () => (/* binding */ MultibrandingStatsProviders)
/* harmony export */ });
var MultibrandingStatsProviders;
(function(MultibrandingStatsProviders) {
    MultibrandingStatsProviders["VK"] = 'vk';
    MultibrandingStatsProviders["OK"] = 'ok_ru';
    MultibrandingStatsProviders["MAIL"] = 'mail_ru';
})(MultibrandingStatsProviders || (MultibrandingStatsProviders = {}));




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oauthList/constants.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oauthList/constants.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OAuthNameText: () => (/* binding */ OAuthNameText)
/* harmony export */ });
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oauthList/types.js");


const OAuthNameText = {
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.OAuthName.OK]: 'OK',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.OAuthName.MAIL]: 'Mail',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.OAuthName.VK]: 'VK ID'
};




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oauthList/events.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oauthList/events.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OAuthListInternalEvents: () => (/* binding */ OAuthListInternalEvents)
/* harmony export */ });
var OAuthListInternalEvents;
(function(OAuthListInternalEvents) {
    OAuthListInternalEvents["LOGIN_SUCCESS"] = 'oauthlist: success login';
})(OAuthListInternalEvents || (OAuthListInternalEvents = {}));




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oauthList/lang.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oauthList/lang.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   linkTextLang: () => (/* binding */ linkTextLang),
/* harmony export */   singleButtonText: () => (/* binding */ singleButtonText)
/* harmony export */ });
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/types.js");
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oauthList/types.js");



const linkTextLang = {
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.RUS]: 'или войти через VK ID с использованием данных из сервиса',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UKR]: 'або увійти через VK ID з використанням даних із сервісу',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.BEL]: 'ці ўвайсці праз VK ID з выкарыстаннем даных з сэрвісу',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.KAZ]: 'сервистегі деректерді пайдаланып VK ID арқылы кіру',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UZB]: 'yoki xizmatning maʼlumotlaridan foydalangan holda VK ID orqali kirish',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.ENG]: 'or sign in with VK ID using information from a service',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.SPA]: 'o iniciar sesión con VK ID utilizando la información de un servicio',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.GERMAN]: 'oder melden Sie sich mit Ihrer VK-ID an, indem Sie Informationen aus dem Dienst verwenden',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.POL]: 'lub wejdź poprzez VK ID przy użyciu danych z serwisu',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.FRA]: 'ou se connecter avec VK ID en utilisant les informations d\'un service',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.TURKEY]: 'Ya da hizmetteki verileri kullanarak VK ID hizmeti yardımıyla gir'
};
const singleButtonText = {
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.RUS]: {
        [_types_js__WEBPACK_IMPORTED_MODULE_1__.OAuthName.OK]: 'Войти через OK',
        [_types_js__WEBPACK_IMPORTED_MODULE_1__.OAuthName.MAIL]: 'Войти с Почтой Mail',
        [_types_js__WEBPACK_IMPORTED_MODULE_1__.OAuthName.VK]: 'Войти с VK ID'
    },
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UKR]: 'Увійти з {provider}',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.BEL]: 'Увайсці з {provider}',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.KAZ]: '{provider} кіру',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UZB]: '{provider} orqali kirish',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.ENG]: 'Sign in with {provider}',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.SPA]: 'Iniciar sesión con {provider}',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.GERMAN]: 'Mit {provider} anmelden',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.POL]: 'Zaloguj się z {provider}',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.FRA]: 'Se connecter avec {provider}',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.TURKEY]: '{provider}\'den gir'
};




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oauthList/oauthList.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oauthList/oauthList.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OAuthList: () => (/* binding */ OAuthList)
/* harmony export */ });
/* harmony import */ var _auth_types_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../auth/types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/auth/types.js");
/* harmony import */ var _core_analytics_types_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/analytics/types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/analytics/types.js");
/* harmony import */ var _core_config_types_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../core/config/types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/config/types.js");
/* harmony import */ var _core_validator_validator_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../core/validator/validator.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/validator/validator.js");
/* harmony import */ var _core_validator_rules_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../core/validator/rules.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/validator/rules.js");
/* harmony import */ var _core_widget_widget_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/widget/widget.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/widget/widget.js");
/* harmony import */ var _core_widget_events_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../core/widget/events.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/widget/events.js");
/* harmony import */ var _core_widget_types_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../core/widget/types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/widget/types.js");
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/types.js");
/* harmony import */ var _analytics_OAuthListStatsCollector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./analytics/OAuthListStatsCollector.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oauthList/analytics/OAuthListStatsCollector.js");
/* harmony import */ var _analytics_types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./analytics/types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oauthList/analytics/types.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./events.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oauthList/events.js");
/* harmony import */ var _template_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./template.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oauthList/template.js");
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oauthList/types.js");
















function _ts_decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}
class OAuthList extends _core_widget_widget_js__WEBPACK_IMPORTED_MODULE_0__.Widget {
    analytics;
    providers;
    flowSource;
    uniqueSessionId;
    constructor(){
        super();
        this.analytics = new _analytics_OAuthListStatsCollector_js__WEBPACK_IMPORTED_MODULE_1__.OAuthListStatsCollector(this.config);
    }
    sendStartAnalytics() {
        const providers = new Set(this.providers);
        this.analytics.sendMultibrandingOauthAdded({
            screen: this.flowSource,
            fields: [
                {
                    name: _analytics_types_js__WEBPACK_IMPORTED_MODULE_2__.MultibrandingStatsProviders.VK,
                    value: (+providers.has(_types_js__WEBPACK_IMPORTED_MODULE_3__.OAuthName.VK)).toString()
                },
                {
                    name: _analytics_types_js__WEBPACK_IMPORTED_MODULE_2__.MultibrandingStatsProviders.OK,
                    value: (+providers.has(_types_js__WEBPACK_IMPORTED_MODULE_3__.OAuthName.OK)).toString()
                },
                {
                    name: _analytics_types_js__WEBPACK_IMPORTED_MODULE_2__.MultibrandingStatsProviders.MAIL,
                    value: (+providers.has(_types_js__WEBPACK_IMPORTED_MODULE_3__.OAuthName.MAIL)).toString()
                }
            ]
        });
        if (providers.has(_types_js__WEBPACK_IMPORTED_MODULE_3__.OAuthName.VK)) {
            this.analytics.sendVkButtonShow({
                screen: this.flowSource,
                isIcon: providers.size > 1
            });
        }
        if (providers.has(_types_js__WEBPACK_IMPORTED_MODULE_3__.OAuthName.OK)) {
            this.analytics.sendOkButtonShow({
                screen: this.flowSource,
                isIcon: providers.size > 1
            });
        }
        if (providers.has(_types_js__WEBPACK_IMPORTED_MODULE_3__.OAuthName.MAIL)) {
            this.analytics.sendMailButtonShow({
                screen: this.flowSource,
                isIcon: providers.size > 1
            });
        }
    }
    render(params) {
        this.lang = params?.lang || _types_js__WEBPACK_IMPORTED_MODULE_4__.Languages.RUS;
        this.scheme = params?.scheme || _types_js__WEBPACK_IMPORTED_MODULE_4__.Scheme.LIGHT;
        this.providers = params.oauthList;
        this.flowSource = params?.flowSource || _core_analytics_types_js__WEBPACK_IMPORTED_MODULE_5__.ProductionStatsEventScreen.MULTIBRANDING;
        this.uniqueSessionId = params?.uniqueSessionId || this.id;
        this.analytics.setUniqueSessionId(this.uniqueSessionId);
        this.templateRenderer = (0,_template_js__WEBPACK_IMPORTED_MODULE_6__.getOAuthListTemplate)({
            lang: this.lang,
            oauthList: params.oauthList,
            height: params.styles?.height,
            borderRadius: params.styles?.borderRadius,
            scheme: this.scheme
        });
        this.container = params.container;
        this.renderTemplate();
        this.registerElements();
        this.setState(_core_widget_types_js__WEBPACK_IMPORTED_MODULE_7__.WidgetState.LOADED);
        this.sendStartAnalytics();
        this.elements.root.addEventListener('click', this.handleClick.bind(this));
        return this;
    }
    handleClick(e) {
        const target = e.target.closest('[data-oauth]');
        if (!target) {
            return;
        }
        const oauth = target.getAttribute('data-oauth');
        const params = {
            lang: this.lang,
            scheme: this.scheme,
            provider: oauth,
            statsFlowSource: _auth_types_js__WEBPACK_IMPORTED_MODULE_8__.AuthStatsFlowSource.MULTIBRANDING,
            uniqueSessionId: this.uniqueSessionId
        };
        let sendProviderButtonTap;
        switch(oauth){
            case _types_js__WEBPACK_IMPORTED_MODULE_3__.OAuthName.VK:
                sendProviderButtonTap = this.analytics.sendVkButtonTap.bind(this.analytics);
                break;
            case _types_js__WEBPACK_IMPORTED_MODULE_3__.OAuthName.OK:
                sendProviderButtonTap = this.analytics.sendOkButtonTap.bind(this.analytics);
                break;
            case _types_js__WEBPACK_IMPORTED_MODULE_3__.OAuthName.MAIL:
                sendProviderButtonTap = this.analytics.sendMailButtonTap.bind(this.analytics);
                break;
        }
        const openFullAuth = ()=>{
            OAuthList.auth.login(params).then((res)=>{
                this.events.emit(_events_js__WEBPACK_IMPORTED_MODULE_9__.OAuthListInternalEvents.LOGIN_SUCCESS, res);
            }).catch((error)=>{
                this.events.emit(_core_widget_events_js__WEBPACK_IMPORTED_MODULE_10__.WidgetEvents.ERROR, {
                    code: _core_widget_types_js__WEBPACK_IMPORTED_MODULE_7__.WidgetErrorCode.AuthError,
                    text: error.error
                });
            });
        };
        const sendProviderButtonTapParams = {
            screen: this.flowSource,
            isIcon: this.providers.length > 1
        };
        if (this.config.get().mode === _core_config_types_js__WEBPACK_IMPORTED_MODULE_11__.ConfigAuthMode.Redirect) {
            sendProviderButtonTap(sendProviderButtonTapParams).finally(openFullAuth);
        } else {
            void sendProviderButtonTap(sendProviderButtonTapParams);
            openFullAuth();
        }
    }
}
_ts_decorate([
    (0,_core_validator_validator_js__WEBPACK_IMPORTED_MODULE_12__.validator)({
        oauthList: [
            _core_validator_rules_js__WEBPACK_IMPORTED_MODULE_13__.isNotEmptyOAuthList
        ]
    })
], OAuthList.prototype, "render", null);




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oauthList/template.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oauthList/template.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getOAuthListTemplate: () => (/* binding */ getOAuthListTemplate)
/* harmony export */ });
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/types.js");
/* harmony import */ var _utils_url_nullOrUndefined_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/url/nullOrUndefined.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/utils/url/nullOrUndefined.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constants.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oauthList/constants.js");
/* harmony import */ var _lang_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lang.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oauthList/lang.js");
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oauthList/types.js");






const spinnerSvg = `
  <svg width="28" height="28" viewBox="0 0 28 28" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M14 22C13.4477 22 13 21.5523 13 21C13 20.4477 13.4477 20 14 20C17.3137 20 20 17.3137 20 14C20 10.6863 17.3137 8 14 8C10.6863 8 8 10.6863 8 14C8 14.6472 8.10214 15.2793 8.3002 15.8802C8.4731 16.4047 8.18807 16.9701 7.66355 17.143C7.13902 17.3159 6.57365 17.0308 6.40074 16.5063C6.13628 15.7041 6 14.8606 6 14C6 9.58172 9.58172 6 14 6C18.4183 6 22 9.58172 22 14C22 18.4183 18.4183 22 14 22Z" fill="currentColor"/>
  </svg>
`;
const OAuthIconMap = {
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.OAuthName.VK]: (size)=>`
<svg width="${size + 1}" height="${size}" viewBox="0 0 29 28" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M3.33331 13.56C3.33331 8.58197 3.33331 6.09295 4.87979 4.54648C6.42627 3 8.91528 3 13.8933 3H14.7733C19.7513 3 22.2404 3 23.7868 4.54648C25.3333 6.09295 25.3333 8.58197 25.3333 13.56V14.44C25.3333 19.418 25.3333 21.907 23.7868 23.4535C22.2404 25 19.7513 25 14.7733 25H13.8933C8.91528 25 6.42627 25 4.87979 23.4535C3.33331 21.907 3.33331 19.418 3.33331 14.44V13.56Z" fill="#0077FF" style="fill:#0077FF;fill:color(display-p3 0.0000 0.4667 1.0000);fill-opacity:1;"/>
  <path d="M15.0398 18.9C10.0174 18.9 7.15269 15.4466 7.03333 9.70001H9.54912C9.63175 13.9178 11.4864 15.7044 12.9555 16.0728V9.70001H15.3245V13.3376C16.7752 13.1811 18.2992 11.5234 18.8134 9.70001H21.1823C20.7875 11.9471 19.1348 13.6047 17.9595 14.2862C19.1348 14.8387 21.0171 16.2846 21.7333 18.9H19.1256C18.5655 17.1503 17.17 15.7965 15.3245 15.6123V18.9H15.0398Z" fill="white" style="fill:white;fill:white;fill-opacity:1;"/>
</svg>
  `,
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.OAuthName.OK]: (size)=>`
<svg width="${size}" height="${size}" viewBox="0 0 28 28" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path fill-rule="evenodd" clip-rule="evenodd" d="M3.67554 3.67638C2 5.36482 2 8.09045 2 13.5176V14.4824C2 19.9216 2 22.6352 3.68759 24.3236C5.37519 26 8.09944 26 13.5238 26H14.4882C19.9126 26 22.6489 26 24.3245 24.3236C26 22.6352 26 19.9095 26 14.4824V13.5176C26 8.09045 26 5.35276 24.3245 3.67638C22.6369 2 19.9126 2 14.4882 2H13.5239C8.08739 2 5.37519 2 3.67554 3.67638Z" fill="#EE8208" style="fill:#EE8208;fill:color(display-p3 0.9333 0.5098 0.0314);fill-opacity:1;"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M17.1157 12.621C16.3239 13.4108 15.218 13.9122 13.999 13.9122C12.7926 13.9122 11.6741 13.4108 10.8823 12.621C10.0906 11.8313 9.58793 10.7407 9.58793 9.51224C9.58793 8.28377 10.0906 7.18065 10.8823 6.40345C11.6741 5.61372 12.78 5.1123 13.999 5.1123C15.218 5.1123 16.3239 5.61372 17.1157 6.40345C17.9074 7.19319 18.4101 8.2963 18.4101 9.51224C18.4101 10.7282 17.9074 11.8313 17.1157 12.621ZM14.0116 7.49404C13.4586 7.49404 12.9559 7.71967 12.5915 8.0832C12.2396 8.44673 12.0008 8.94814 12.0008 9.4997C12.0008 10.0513 12.227 10.5527 12.5915 10.9162C12.9559 11.2797 13.446 11.5054 14.0116 11.5054C14.5645 11.5054 15.0672 11.2797 15.4317 10.9162C15.7961 10.5527 16.0223 10.0638 16.0223 9.4997C16.0223 8.94814 15.7961 8.44673 15.4317 8.0832C15.0672 7.71967 14.5771 7.49404 14.0116 7.49404Z" fill="white" style="fill:white;fill:white;fill-opacity:1;"/>
  <path d="M18.6614 13.9247L19.9558 15.6922C20.0312 15.7799 20.0187 15.8927 19.8553 15.968C18.762 16.8705 17.4927 17.4471 16.1731 17.7605L18.9128 22.5741C18.9882 22.7246 18.9002 22.8875 18.7368 22.8875H16.06C15.9721 22.8875 15.8967 22.8248 15.8715 22.7496L13.9613 18.4876L12.0511 22.7496C12.026 22.8374 11.9506 22.8875 11.8626 22.8875H9.1858C9.03499 22.8875 8.93445 22.712 9.00986 22.5741L11.7495 17.7605C10.4299 17.4471 9.16066 16.8454 8.06732 15.968C7.99192 15.8927 7.97935 15.7799 8.04219 15.6922L9.3366 13.9247C9.412 13.8369 9.56281 13.8244 9.65078 13.8996C10.8824 14.9401 12.3779 15.617 13.999 15.617C15.6202 15.617 17.1282 14.9401 18.3472 13.8996C18.4352 13.8119 18.586 13.8244 18.6614 13.9247Z" fill="white" style="fill:white;fill:white;fill-opacity:1;"/>
</svg>
  `,
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.OAuthName.MAIL]: (size)=>`
<svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" fill="none" viewBox="0 0 28 28">
    <path fill="#07F" d="M17.61 14a3.61 3.61 0 0 1-7.22 0A3.61 3.61 0 0 1 14 10.39a3.62 3.62 0 0 1 3.61 3.6Zm-3.6-12C7.37 2 2 7.38 2 14a12.01 12.01 0 0 0 18.77 9.91l.03-.02L19.2 22l-.03.01A9.54 9.54 0 0 1 14 23.53a9.55 9.55 0 0 1 0-19.07 9.55 9.55 0 0 1 9.31 11.59c-.3 1.24-1.16 1.62-1.82 1.56-.65-.05-1.42-.51-1.43-1.66V14A6.08 6.08 0 0 0 14 7.93 6.08 6.08 0 0 0 7.93 14 6.08 6.08 0 0 0 14 20.07c1.62 0 3.15-.64 4.3-1.8a3.9 3.9 0 0 0 3 1.8l.32.01a4.08 4.08 0 0 0 2.44-.82 4.5 4.5 0 0 0 1.55-2.28l.13-.5v-.02A12 12 0 0 0 14 2Z"/>
</svg>
  `
};
const defaultStylesParams = {
    height: 44,
    borderRadius: 8
};
const getOAuthListTemplate = (params)=>(id)=>{
        const lang = params.lang || _types_js__WEBPACK_IMPORTED_MODULE_1__.Languages.RUS;
        const scheme = params.scheme || 'light';
        const borderRadius = !(0,_utils_url_nullOrUndefined_js__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(params.borderRadius) ? params.borderRadius : defaultStylesParams.borderRadius;
        const height = params.height || defaultStylesParams.height;
        const isonSize = height < 40 ? 24 : 28;
        const paddingSize = height < 40 ? 6 : height < 48 ? 8 : 12;
        const oauthListItems = params.oauthList.map((oauth)=>{
            const singleButtonTextLang = lang === _types_js__WEBPACK_IMPORTED_MODULE_1__.Languages.RUS ? _lang_js__WEBPACK_IMPORTED_MODULE_3__.singleButtonText[lang][oauth] : `${_lang_js__WEBPACK_IMPORTED_MODULE_3__.singleButtonText[lang].replace('{provider}', _constants_js__WEBPACK_IMPORTED_MODULE_4__.OAuthNameText[oauth])}`;
            return `
      <div class="VkIdSdk_oauth_item" data-oauth="${oauth}">
        ${OAuthIconMap[oauth](isonSize)}
        <div class="VkIdSdk_oauth_button_text">${singleButtonTextLang}</div>
      </div>
    `;
        }).join('');
        const handleLoaded = ()=>{
            const textDiv = document.querySelector(`#${id} .VkIdSdk_oauth_button_text`);
            const oauthItemDiv = document.querySelector(`#${id} .VkIdSdk_oauth_item`);
            if (!textDiv || !oauthItemDiv) {
                return;
            }
            const shouldHideText = textDiv.clientWidth >= oauthItemDiv.clientWidth - isonSize * 2 - 32 - paddingSize * 2;
            if (shouldHideText) {
                document.querySelector(`#${id} .VkIdSdk_oauth_list`)?.removeAttribute('data-single-mode');
            }
        };
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', handleLoaded);
        } else {
            setTimeout(handleLoaded, 0);
        }
        const isSingleMode = params.oauthList.length === 1 ? 'data-single-mode' : '';
        const linkText = _lang_js__WEBPACK_IMPORTED_MODULE_3__.linkTextLang[lang];
        return `
    <div id="${id}" class="VkIdSdk_oauth_container" data-test-id="oauthList" data-scheme="${scheme}">
      <style>
        :root #${id}[data-scheme=light] {
          --oauthlist--item_border_color: rgba(0, 0, 0, .12);
          --oauthlist--color_text_secondary: #818c99;
          --oauthlist--color_text_primary: #000;
          --oauthlist--item_background_color: #fff;
        }

        :root #${id}[data-scheme=dark] {
          --oauthlist--item_border_color: rgba(255, 255, 255, 0.12);
          --oauthlist--color_text_secondary: #76787a;
          --oauthlist--color_text_primary: #e1e3e6;
          --oauthlist--item_background_color: unset;
        }

        #${id}.VkIdSdk_oauth_container {
          position: relative;
        }

        #${id} .VkIdSdk_oauth_list {
          display: flex;
          height: ${height}px;
        }

        #${id} .VkIdSdk_oauth_item {
          position: relative;
          display: flex;
          justify-content: center;
          align-items: center;
          padding: ${paddingSize}px;
          margin-right: 12px;
          width: 100%;
          border: 1px solid var(--oauthlist--item_border_color);
          background: var(--oauthlist--item_background_color);
          border-radius: ${borderRadius}px;
          cursor: pointer;
        }

        #${id} .VkIdSdk_oauth_item:last-child {
          margin-right: 0;
        }

        #${id} .VkIdSdk_oauth_link_text {
          display: flex;
          font-family: -apple-system, system-ui, "Helvetica Neue", Roboto, sans-serif;
          color: var(--oauthlist--color_text_secondary);
          font-size: 13px;
          line-height: 16px;
          margin-bottom: 16px;
          justify-content: center;
          text-align: center;
        }

        #${id} .VkIdSdk_spinner {
          position: absolute;
          display: flex;
          justify-content: center;
          align-items: center;
          width: 100%;
          height: 100%;
          background: #fff;
        }

        #${id}[data-state=loaded] .VkIdSdk_spinner {
          transition: .2s;
          opacity: 0;
          pointer-events: none;
        }

        #${id} .VkIdSdk_spinner > svg {
          animation: vkIdSdkButtonSpinner 0.7s linear infinite;
        }

        #${id} .VkIdSdk_oauth_button_text {
          display: none;
          font-family: -apple-system, system-ui, "Helvetica Neue", Roboto, sans-serif;
          color: var(--oauthlist--color_text_primary);
          padding-left: 8px;
        }

        #${id} .VkIdSdk_oauth_list[data-single-mode] .VkIdSdk_oauth_button_text {
          display: block;
        }

        @keyframes vkIdSdkButtonSpinner {
          0% {
            transform: rotate(0deg);
          }
          100% {
            transform: rotate(360deg);
          }
        }
      </style>
      <div class="VkIdSdk_spinner">
        ${spinnerSvg}
      </div>
      <div class="VkIdSdk_oauth_link_text">${linkText}</div>
      <div class="VkIdSdk_oauth_list" ${isSingleMode}>${oauthListItems}</div>
    </div>
  `;
    };




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oauthList/types.js":
/*!************************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oauthList/types.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ExternalOAuthName: () => (/* binding */ ExternalOAuthName),
/* harmony export */   OAuthName: () => (/* binding */ OAuthName)
/* harmony export */ });
var OAuthName;
(function(OAuthName) {
    OAuthName["OK"] = 'ok_ru';
    OAuthName["MAIL"] = 'mail_ru';
    OAuthName["VK"] = 'vkid';
})(OAuthName || (OAuthName = {}));
var ExternalOAuthName;
(function(ExternalOAuthName) {
    ExternalOAuthName[ExternalOAuthName["OK"] = OAuthName.OK] = "OK";
    ExternalOAuthName[ExternalOAuthName["MAIL"] = OAuthName.MAIL] = "MAIL";
})(ExternalOAuthName || (ExternalOAuthName = {}));




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oneTap/analytics/OneTapStatsCollector.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oneTap/analytics/OneTapStatsCollector.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OneTapStatsCollector: () => (/* binding */ OneTapStatsCollector)
/* harmony export */ });
/* harmony import */ var _core_analytics_RegistrationStatsCollector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/analytics/RegistrationStatsCollector.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/analytics/RegistrationStatsCollector.js");
/* harmony import */ var _core_analytics_types_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/analytics/types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/analytics/types.js");
/* harmony import */ var _core_analytics_ProductionStatsCollector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/analytics/ProductionStatsCollector.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/analytics/ProductionStatsCollector.js");
/* harmony import */ var _core_analytics_ActionStatsCollector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/analytics/ActionStatsCollector.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/analytics/ActionStatsCollector.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constants.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oneTap/analytics/constants.js");






class OneTapStatsCollector {
    registrationStatsCollector;
    uniqueSessionId;
    constructor(config){
        const productStatsCollector = new _core_analytics_ProductionStatsCollector_js__WEBPACK_IMPORTED_MODULE_0__.ProductionStatsCollector(config);
        const actionStatsCollector = new _core_analytics_ActionStatsCollector_js__WEBPACK_IMPORTED_MODULE_1__.ActionStatsCollector(productStatsCollector);
        this.registrationStatsCollector = new _core_analytics_RegistrationStatsCollector_js__WEBPACK_IMPORTED_MODULE_2__.RegistrationStatsCollector(actionStatsCollector);
    }
    setUniqueSessionId(id) {
        this.uniqueSessionId = id;
    }
    getFields() {
        const fields = [
            {
                name: 'sdk_type',
                value: 'vkid'
            }
        ];
        if (this.uniqueSessionId) {
            fields.push({
                name: 'unique_session_id',
                value: this.uniqueSessionId
            });
        }
        return fields;
    }
    sendFrameLoadingFailed() {
        void this.registrationStatsCollector.logEvent(_core_analytics_types_js__WEBPACK_IMPORTED_MODULE_3__.ProductionStatsEventScreen.NOWHERE, {
            event_type: 'iframe_loading_failed',
            fields: this.getFields()
        });
    }
    sendNoSessionFound() {
        void this.registrationStatsCollector.logEvent(_core_analytics_types_js__WEBPACK_IMPORTED_MODULE_3__.ProductionStatsEventScreen.NOWHERE, {
            event_type: 'no_session_found',
            fields: this.getFields()
        });
    }
    sendOneTapButtonNoUserShow(buttonType = 'default') {
        void this.registrationStatsCollector.logEvent(_core_analytics_types_js__WEBPACK_IMPORTED_MODULE_3__.ProductionStatsEventScreen.NOWHERE, {
            event_type: 'onetap_button_no_user_show',
            fields: [
                ...this.getFields(),
                {
                    name: 'button_type',
                    value: buttonType
                }
            ]
        });
    }
    sendOneTapButtonNoUserTap(buttonType = 'default') {
        return this.registrationStatsCollector.logEvent(_core_analytics_types_js__WEBPACK_IMPORTED_MODULE_3__.ProductionStatsEventScreen.NOWHERE, {
            event_type: 'onetap_button_no_user_tap',
            fields: [
                ...this.getFields(),
                {
                    name: 'button_type',
                    value: buttonType
                }
            ]
        });
    }
    sendScreenProceed(params) {
        void this.registrationStatsCollector.logEvent(_core_analytics_types_js__WEBPACK_IMPORTED_MODULE_3__.ProductionStatsEventScreen.NOWHERE, {
            event_type: 'screen_proceed',
            fields: [
                ...this.getFields(),
                {
                    name: 'theme_type',
                    value: params.scheme
                },
                {
                    name: 'style_type',
                    value: params.skin
                },
                {
                    name: 'language',
                    value: params.lang.toString()
                },
                {
                    name: 'text_type',
                    value: _constants_js__WEBPACK_IMPORTED_MODULE_4__.TEXT_TYPE[params.contentId]
                }
            ]
        });
    }
}




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oneTap/analytics/constants.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oneTap/analytics/constants.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TEXT_TYPE: () => (/* binding */ TEXT_TYPE)
/* harmony export */ });
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oneTap/types.js");


const TEXT_TYPE = {
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.OneTapContentId.SIGN_IN]: 'default',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.OneTapContentId.SIGN_UP]: 'appoint',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.OneTapContentId.GET]: 'receive',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.OneTapContentId.OPEN]: 'open',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.OneTapContentId.CALCULATE]: 'calculate',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.OneTapContentId.ORDER]: 'order',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.OneTapContentId.PLACE_ORDER]: 'service_order_placing',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.OneTapContentId.SUBMIT_REQUEST]: 'request',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.OneTapContentId.PARTICIPATE]: 'take_part'
};




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oneTap/events.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oneTap/events.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OneTapInternalEvents: () => (/* binding */ OneTapInternalEvents)
/* harmony export */ });
var OneTapInternalEvents;
(function(OneTapInternalEvents) {
    OneTapInternalEvents["LOGIN_SUCCESS"] = 'onetap: success login';
    OneTapInternalEvents["SHOW_FULL_AUTH"] = 'onetap: show full auth';
    OneTapInternalEvents["START_AUTHORIZE"] = 'onetap: start authorize';
    OneTapInternalEvents["NOT_AUTHORIZED"] = 'onetap: not authorized';
    OneTapInternalEvents[/**
   * Событие вызывается при наличии аутентификации пользователя.
   * В качестве payload передается флаг is_online: boolean.
   */ "AUTHENTICATION_INFO"] = 'onetap: authentication_info';
})(OneTapInternalEvents || (OneTapInternalEvents = {}));




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oneTap/langs/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oneTap/langs/index.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getLongLang: () => (/* reexport safe */ _long_js__WEBPACK_IMPORTED_MODULE_0__.getLongLang),
/* harmony export */   getShortLang: () => (/* reexport safe */ _short_js__WEBPACK_IMPORTED_MODULE_1__.getShortLang),
/* harmony export */   providerLang: () => (/* binding */ providerLang)
/* harmony export */ });
/* harmony import */ var _long_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./long.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oneTap/langs/long.js");
/* harmony import */ var _short_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./short.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oneTap/langs/short.js");



const providerLang = 'VK ID';




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oneTap/langs/long.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oneTap/langs/long.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getLongLang: () => (/* binding */ getLongLang)
/* harmony export */ });
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/types.js");
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oneTap/types.js");



const SIGN_IN_LONG = {
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.RUS]: 'Войти с VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UKR]: 'Увійти з VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.BEL]: 'Увайсці з VК ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.KAZ]: 'VK ID арқылы кіру',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UZB]: 'VK ID dan kirish',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.ENG]: 'Sign in with VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.SPA]: 'Iniciar sesión con VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.GERMAN]: 'Mit VK-ID anmelden',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.POL]: 'Wejdź z VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.FRA]: 'Se connecter avec VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.TURKEY]: 'VK ID aracılığıyla gir'
};
const SIGN_UP_LONG = {
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.RUS]: 'Записаться с VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UKR]: 'Записатися з VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.BEL]: 'Запісацца з VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.KAZ]: 'VK ID арқылы жазылу',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UZB]: 'VK ID bilan yozilish',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.ENG]: 'Sign up with VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.SPA]: 'Registrarse con VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.GERMAN]: 'Mit VK ID anmelden',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.POL]: 'Zapisz się z VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.FRA]: 'Prendre RDV avec VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.TURKEY]: 'VK ID ile kaydol'
};
const GET_LONG = {
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.RUS]: 'Получить с VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UKR]: 'Отримати з VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.BEL]: 'Атрымаць з VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.KAZ]: 'VK ID арқылы алу',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UZB]: 'VK ID bilan olish',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.ENG]: 'Get with VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.SPA]: 'Obtener con VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.GERMAN]: 'Mit VK ID erhalten',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.POL]: 'Otrzymaj z VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.FRA]: 'Obtenir avec VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.TURKEY]: 'VK ID ile al'
};
const OPEN_LONG = {
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.RUS]: 'Открыть с VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UKR]: 'Відкрити з VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.BEL]: 'Адкрыць з VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.KAZ]: 'VK ID арқылы ашу',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UZB]: 'VK ID bilan ochish',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.ENG]: 'Open with VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.SPA]: 'Abrir con VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.GERMAN]: 'Mit VK ID öffnen',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.POL]: 'Otwórz z VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.FRA]: 'Ouvrir avec VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.TURKEY]: 'VK ID ile aç'
};
const CALCULATE_LONG = {
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.RUS]: 'Рассчитать с VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UKR]: 'Розрахувати з VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.BEL]: 'Разлічыць з VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.KAZ]: 'VK ID арқылы есептеу',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UZB]: 'VK ID yordamida hisoblash',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.ENG]: 'Calculate with VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.SPA]: 'Calcular con VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.GERMAN]: 'Mit VK ID berechnen',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.POL]: 'Oblicz z VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.FRA]: 'Calculer avec VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.TURKEY]: 'VK ID ile hesapla'
};
const ORDER_LONG = {
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.RUS]: 'Заказать с VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UKR]: 'Замовити з VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.BEL]: 'Заказаць з VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.KAZ]: 'VK ID арқылы тапсырыс беру',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UZB]: 'VK ID bilan buyurtma berish',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.ENG]: 'Order with VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.SPA]: 'Pedir con VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.GERMAN]: 'Mit VK ID bestellen',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.POL]: 'Zamów z VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.FRA]: 'Commander avec VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.TURKEY]: 'VK ID ile sipariş ver'
};
const PLACE_ORDER_LONG = {
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.RUS]: 'Оформить с VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UKR]: 'Оформити з VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.BEL]: 'Аформіць з VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.KAZ]: 'VK ID арқылы рәсімдеу',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UZB]: 'VK ID bilan shakllantirish',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.ENG]: 'Order with VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.SPA]: 'Pedir con VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.GERMAN]: 'Mit VK ID Bestellung aufgeben',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.POL]: 'Wypełnij z VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.FRA]: 'Commander avec VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.TURKEY]: 'VK ID ile yap'
};
const SUBMIT_REQUEST_LONG = {
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.RUS]: 'Оставить заявку с VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UKR]: 'Залишити запит з VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.BEL]: 'Пакінуць заяўку з VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.KAZ]: 'VK ID арқылы өтінім қалдыру',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UZB]: 'VK ID bilan talabnoma qoldirish',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.ENG]: 'Send request with VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.SPA]: 'Enviar solicitud con VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.GERMAN]: 'Mit VK ID Anfrage stellen',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.POL]: 'Zostaw wniosek z VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.FRA]: 'Envoyer demande avec VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.TURKEY]: 'VK ID ile başvuru yap'
};
const PARTICIPATE_LONG = {
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.RUS]: 'Участвовать с VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UKR]: 'Брати участь з VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.BEL]: 'Удзельнічаць з VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.KAZ]: 'VK ID арқылы қатысу',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UZB]: 'VK ID ilan ishtirok etish',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.ENG]: 'Participate with VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.SPA]: 'Participar con VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.GERMAN]: 'Mit VK ID teilnehmen',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.POL]: 'Uczestnicz z VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.FRA]: 'Participer avec VK ID',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.TURKEY]: 'VK ID ile katıl'
};
const texts = {
    [_types_js__WEBPACK_IMPORTED_MODULE_1__.OneTapContentId.SIGN_IN]: SIGN_IN_LONG,
    [_types_js__WEBPACK_IMPORTED_MODULE_1__.OneTapContentId.SIGN_UP]: SIGN_UP_LONG,
    [_types_js__WEBPACK_IMPORTED_MODULE_1__.OneTapContentId.GET]: GET_LONG,
    [_types_js__WEBPACK_IMPORTED_MODULE_1__.OneTapContentId.OPEN]: OPEN_LONG,
    [_types_js__WEBPACK_IMPORTED_MODULE_1__.OneTapContentId.CALCULATE]: CALCULATE_LONG,
    [_types_js__WEBPACK_IMPORTED_MODULE_1__.OneTapContentId.ORDER]: ORDER_LONG,
    [_types_js__WEBPACK_IMPORTED_MODULE_1__.OneTapContentId.PLACE_ORDER]: PLACE_ORDER_LONG,
    [_types_js__WEBPACK_IMPORTED_MODULE_1__.OneTapContentId.SUBMIT_REQUEST]: SUBMIT_REQUEST_LONG,
    [_types_js__WEBPACK_IMPORTED_MODULE_1__.OneTapContentId.PARTICIPATE]: PARTICIPATE_LONG
};
const getLongLang = (contentId, lang)=>{
    const content = texts[contentId] || texts[_types_js__WEBPACK_IMPORTED_MODULE_1__.OneTapContentId.SIGN_IN];
    return content[lang] || content[_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.RUS];
};




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oneTap/langs/short.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oneTap/langs/short.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getShortLang: () => (/* binding */ getShortLang)
/* harmony export */ });
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/types.js");
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oneTap/types.js");



const SIGN_IN_SHORT = {
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.RUS]: 'Продолжить',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UKR]: 'Продовжити',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.BEL]: 'Працягнуць',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.KAZ]: 'Жалғастыру',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UZB]: 'Davom etish',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.ENG]: 'Continue',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.SPA]: 'Continuar',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.GERMAN]: 'Fortfahren',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.POL]: 'Kontynuuj',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.FRA]: 'Continuer',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.TURKEY]: 'Devam'
};
const SIGN_UP_SHORT = {
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.RUS]: 'Записаться',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UKR]: 'Записатися',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.BEL]: 'Запісацца',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.KAZ]: 'Жазылу',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UZB]: 'Yozilish',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.ENG]: 'Sign up',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.SPA]: 'Registrarse',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.GERMAN]: 'Anmelden',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.POL]: 'Zapisz się',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.FRA]: 'Prendre RDV',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.TURKEY]: 'Kaydol'
};
const GET_SHORT = {
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.RUS]: 'Получить',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UKR]: 'Отримати',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.BEL]: 'Атрымаць',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.KAZ]: 'Алу',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UZB]: 'Olish',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.ENG]: 'Get',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.SPA]: 'Obtener',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.GERMAN]: 'Erhalten',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.POL]: 'Otrzymaj',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.FRA]: 'Obtenir',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.TURKEY]: 'Al'
};
const OPEN_SHORT = {
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.RUS]: 'Открыть',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UKR]: 'Відкрити',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.BEL]: 'Адкрыць',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.KAZ]: 'Ашу',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UZB]: 'Ochish',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.ENG]: 'Open',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.SPA]: 'Abrir',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.GERMAN]: 'Öffnen',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.POL]: 'Otwórz',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.FRA]: 'Ouvrir',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.TURKEY]: 'Aç'
};
const CALCULATE_SHORT = {
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.RUS]: 'Рассчитать',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UKR]: 'Розрахувати',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.BEL]: 'Разлічыць',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.KAZ]: 'Есептеу',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UZB]: 'Hisoblash',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.ENG]: 'Calculate',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.SPA]: 'Calcular',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.GERMAN]: 'Berechnen',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.POL]: 'Oblicz',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.FRA]: 'Calculer',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.TURKEY]: 'Hesapla'
};
const ORDER_SHORT = {
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.RUS]: 'Заказать',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UKR]: 'Замовити',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.BEL]: 'Заказаць',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.KAZ]: 'Тапсырыс беру',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UZB]: 'Buyurtma berish',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.ENG]: 'Order',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.SPA]: 'Pedir',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.GERMAN]: 'Bestellen',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.POL]: 'Zamów',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.FRA]: 'Commander',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.TURKEY]: 'Sipariş ver'
};
const PLACE_ORDER_SHORT = {
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.RUS]: 'Оформить заказ',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UKR]: 'Оформити замовлення',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.BEL]: 'Аформіць заказ',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.KAZ]: 'Тапсырысты рәсімдеу',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UZB]: 'Buyurtmani shakllantirish',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.ENG]: 'Place order',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.SPA]: 'Hacer pedido',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.GERMAN]: 'Bestellung aufgeben',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.POL]: 'Wypełnij zamówienie',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.FRA]: 'Passer commande',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.TURKEY]: 'Siparişi tamamlar'
};
const SUBMIT_REQUEST_SHORT = {
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.RUS]: 'Оставить заявку',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UKR]: 'Залишити запит',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.BEL]: 'Пакінуць заяўку',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.KAZ]: 'Өтінім қалдыру',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UZB]: 'Talabnoma qoldirish',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.ENG]: 'Send request',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.SPA]: 'Enviar solicitud',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.GERMAN]: 'Anfrage stellen',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.POL]: 'Pozostaw wniosek',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.FRA]: 'Envoyer demande',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.TURKEY]: 'Başvuru bırak'
};
const PARTICIPATE_SHORT = {
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.RUS]: 'Участвовать',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UKR]: 'Брати участь',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.BEL]: 'Удзельнічаць',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.KAZ]: 'Қатысу',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.UZB]: 'Ishtirok etish',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.ENG]: 'Participate',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.SPA]: 'Participar',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.GERMAN]: 'Teilnehmen',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.POL]: 'Uczestnicz',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.FRA]: 'Participer',
    [_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.TURKEY]: 'Katıl'
};
const texts = {
    [_types_js__WEBPACK_IMPORTED_MODULE_1__.OneTapContentId.SIGN_IN]: SIGN_IN_SHORT,
    [_types_js__WEBPACK_IMPORTED_MODULE_1__.OneTapContentId.SIGN_UP]: SIGN_UP_SHORT,
    [_types_js__WEBPACK_IMPORTED_MODULE_1__.OneTapContentId.GET]: GET_SHORT,
    [_types_js__WEBPACK_IMPORTED_MODULE_1__.OneTapContentId.OPEN]: OPEN_SHORT,
    [_types_js__WEBPACK_IMPORTED_MODULE_1__.OneTapContentId.CALCULATE]: CALCULATE_SHORT,
    [_types_js__WEBPACK_IMPORTED_MODULE_1__.OneTapContentId.ORDER]: ORDER_SHORT,
    [_types_js__WEBPACK_IMPORTED_MODULE_1__.OneTapContentId.PLACE_ORDER]: PLACE_ORDER_SHORT,
    [_types_js__WEBPACK_IMPORTED_MODULE_1__.OneTapContentId.SUBMIT_REQUEST]: SUBMIT_REQUEST_SHORT,
    [_types_js__WEBPACK_IMPORTED_MODULE_1__.OneTapContentId.PARTICIPATE]: PARTICIPATE_SHORT
};
const getShortLang = (contentId, lang)=>{
    const content = texts[contentId] || texts[_types_js__WEBPACK_IMPORTED_MODULE_1__.OneTapContentId.SIGN_IN];
    return content[lang] || content[_types_js__WEBPACK_IMPORTED_MODULE_0__.Languages.RUS];
};




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oneTap/oneTap.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oneTap/oneTap.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OneTap: () => (/* binding */ OneTap)
/* harmony export */ });
/* harmony import */ var _auth_types_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../auth/types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/auth/types.js");
/* harmony import */ var _core_analytics_types_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../core/analytics/types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/analytics/types.js");
/* harmony import */ var _core_config_types_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../core/config/types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/config/types.js");
/* harmony import */ var _core_validator_validator_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../core/validator/validator.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/validator/validator.js");
/* harmony import */ var _core_validator_rules_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../core/validator/rules.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/validator/rules.js");
/* harmony import */ var _core_widget_widget_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/widget/widget.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/widget/widget.js");
/* harmony import */ var _core_widget_events_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/widget/events.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/widget/events.js");
/* harmony import */ var _core_widget_types_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/widget/types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/core/widget/types.js");
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/types.js");
/* harmony import */ var _utils_url_nullOrUndefined_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../utils/url/nullOrUndefined.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/utils/url/nullOrUndefined.js");
/* harmony import */ var _oauthList_oauthList_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../oauthList/oauthList.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oauthList/oauthList.js");
/* harmony import */ var _oauthList_types_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../oauthList/types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oauthList/types.js");
/* harmony import */ var _oauthList_events_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../oauthList/events.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oauthList/events.js");
/* harmony import */ var _analytics_OneTapStatsCollector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./analytics/OneTapStatsCollector.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oneTap/analytics/OneTapStatsCollector.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oneTap/events.js");
/* harmony import */ var _template_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./template.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oneTap/template.js");
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./types.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oneTap/types.js");



















function _ts_decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}
const defaultStylesParams = {
    width: 0,
    height: 44,
    borderRadius: 8
};
const BUTTON_SPACING = 12;
class OneTap extends _core_widget_widget_js__WEBPACK_IMPORTED_MODULE_0__.Widget {
    analytics;
    vkidAppName = 'button_one_tap_auth';
    statsBtnType;
    fastAuthDisabled;
    constructor(){
        super();
        this.analytics = new _analytics_OneTapStatsCollector_js__WEBPACK_IMPORTED_MODULE_1__.OneTapStatsCollector(OneTap.config);
    }
    setStatsButtonType = (type)=>{
        if (!this.statsBtnType) {
            this.statsBtnType = type;
            if (this.fastAuthDisabled) {
                this.statsBtnType && this.analytics.sendOneTapButtonNoUserShow(this.statsBtnType);
            }
        }
    };
    sendSuccessLoginEvent = (params)=>{
        this.events.emit(_events_js__WEBPACK_IMPORTED_MODULE_2__.OneTapInternalEvents.LOGIN_SUCCESS, params);
    };
    onBridgeMessageHandler(event) {
        switch(event.handler){
            case _events_js__WEBPACK_IMPORTED_MODULE_2__.OneTapInternalEvents.SHOW_FULL_AUTH:
                {
                    const params = event.params;
                    const authParams = {};
                    if (params.screen) {
                        authParams.screen = params.screen;
                    }
                    if (params.sdk_oauth) {
                        authParams.provider = params.sdk_oauth;
                        authParams.statsFlowSource = _auth_types_js__WEBPACK_IMPORTED_MODULE_3__.AuthStatsFlowSource.MULTIBRANDING;
                    }
                    this.openFullAuth(authParams);
                    break;
                }
            case _events_js__WEBPACK_IMPORTED_MODULE_2__.OneTapInternalEvents.NOT_AUTHORIZED:
                {
                    this.analytics.sendNoSessionFound();
                    this.setState(_core_widget_types_js__WEBPACK_IMPORTED_MODULE_4__.WidgetState.NOT_LOADED);
                    clearTimeout(this.timeoutTimer);
                    this.elements?.iframe?.remove();
                    break;
                }
            case _events_js__WEBPACK_IMPORTED_MODULE_2__.OneTapInternalEvents.AUTHENTICATION_INFO:
                {
                    this.events.emit(_events_js__WEBPACK_IMPORTED_MODULE_2__.OneTapInternalEvents.AUTHENTICATION_INFO, event.params);
                    break;
                }
            default:
                {
                    super.onBridgeMessageHandler(event);
                    break;
                }
        }
    }
    onErrorHandler(error) {
        this.analytics.sendFrameLoadingFailed();
        this.analytics.sendOneTapButtonNoUserShow(this.statsBtnType);
        super.onErrorHandler(error);
    }
    openFullAuth(value) {
        const params = {
            statsFlowSource: _auth_types_js__WEBPACK_IMPORTED_MODULE_3__.AuthStatsFlowSource.BUTTON_ONE_TAP,
            ...value,
            uniqueSessionId: this.id,
            lang: this.lang,
            scheme: this.scheme
        };
        OneTap.auth.login(params).then(this.sendSuccessLoginEvent).catch((error)=>{
            this.events.emit(_core_widget_events_js__WEBPACK_IMPORTED_MODULE_5__.WidgetEvents.ERROR, {
                code: _core_widget_types_js__WEBPACK_IMPORTED_MODULE_4__.WidgetErrorCode.AuthError,
                text: error.error
            });
        });
    }
    login(value) {
        if (this.config.get().mode === _core_config_types_js__WEBPACK_IMPORTED_MODULE_6__.ConfigAuthMode.Redirect) {
            this.analytics.sendOneTapButtonNoUserTap(this.statsBtnType).finally(()=>{
                this.openFullAuth(value);
            });
        } else {
            void this.analytics.sendOneTapButtonNoUserTap(this.statsBtnType);
            this.openFullAuth(value);
        }
    }
    renderOAuthList(params) {
        if (!params.oauthList.length) {
            return;
        }
        const oauthList = new _oauthList_oauthList_js__WEBPACK_IMPORTED_MODULE_7__.OAuthList();
        oauthList.on(_oauthList_events_js__WEBPACK_IMPORTED_MODULE_8__.OAuthListInternalEvents.LOGIN_SUCCESS, this.sendSuccessLoginEvent).render({
            ...params,
            flowSource: _core_analytics_types_js__WEBPACK_IMPORTED_MODULE_9__.ProductionStatsEventScreen.NOWHERE,
            uniqueSessionId: this.id
        });
    }
    render(params) {
        this.lang = params?.lang || _types_js__WEBPACK_IMPORTED_MODULE_10__.Languages.RUS;
        this.scheme = params?.scheme || _types_js__WEBPACK_IMPORTED_MODULE_10__.Scheme.LIGHT;
        this.fastAuthDisabled = params.fastAuthEnabled === false;
        const providers = (params.oauthList || []).filter((provider)=>provider !== _oauthList_types_js__WEBPACK_IMPORTED_MODULE_11__.OAuthName.VK);
        const oneTapParams = {
            style_height: params.styles?.height || defaultStylesParams.height,
            style_border_radius: !(0,_utils_url_nullOrUndefined_js__WEBPACK_IMPORTED_MODULE_12__.isNullOrUndefined)(params.styles?.borderRadius) ? params.styles?.borderRadius : defaultStylesParams.borderRadius,
            show_alternative_login: params?.showAlternativeLogin ? 1 : 0,
            button_skin: params.skin || _types_js__WEBPACK_IMPORTED_MODULE_13__.OneTapSkin.Primary,
            content_id: params?.contentId || _types_js__WEBPACK_IMPORTED_MODULE_13__.OneTapContentId.SIGN_IN,
            scheme: this.scheme,
            lang_id: this.lang,
            providers: providers.join(','),
            uuid: this.id
        };
        this.analytics.setUniqueSessionId(this.id);
        this.templateRenderer = (0,_template_js__WEBPACK_IMPORTED_MODULE_14__.getOneTapTemplate)({
            width: params.styles?.width || defaultStylesParams.width,
            iframeHeight: oneTapParams.show_alternative_login ? oneTapParams.style_height * 2 + BUTTON_SPACING : oneTapParams.style_height,
            height: oneTapParams.style_height,
            borderRadius: oneTapParams.style_border_radius,
            login: this.login.bind(this),
            skin: oneTapParams.button_skin,
            scheme: oneTapParams.scheme,
            lang: oneTapParams.lang_id,
            contentId: oneTapParams.content_id,
            renderOAuthList: this.renderOAuthList.bind(this),
            providers,
            setStatsButtonType: this.setStatsButtonType.bind(this)
        });
        this.analytics.sendScreenProceed({
            scheme: this.scheme,
            lang: this.lang,
            skin: oneTapParams.button_skin,
            contentId: oneTapParams.content_id
        });
        if (this.fastAuthDisabled) {
            oneTapParams.fastAuthDisabled = true;
        }
        return super.render({
            container: params.container,
            ...oneTapParams
        });
    }
}
_ts_decorate([
    (0,_core_validator_validator_js__WEBPACK_IMPORTED_MODULE_15__.validator)({
        styles: [
            _core_validator_rules_js__WEBPACK_IMPORTED_MODULE_16__.isValidHeight
        ]
    })
], OneTap.prototype, "render", null);




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oneTap/template.js":
/*!************************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oneTap/template.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getOneTapTemplate: () => (/* binding */ getOneTapTemplate)
/* harmony export */ });
/* harmony import */ var _lib_vkontakte_vkjs_lib_es6_functions_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./../../lib/@vkontakte/vkjs/lib/es6/functions.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/lib/@vkontakte/vkjs/lib/es6/functions.js");
/* harmony import */ var _lib_resize_observer_polyfill_dist_ResizeObserver_es_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./../../lib/resize-observer-polyfill/dist/ResizeObserver.es.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/lib/resize-observer-polyfill/dist/ResizeObserver.es.js");
/* harmony import */ var _utils_styles_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/styles.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/utils/styles.js");
/* harmony import */ var _langs_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./langs/index.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oneTap/langs/index.js");
/* harmony import */ var _langs_short_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./langs/short.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oneTap/langs/short.js");
/* harmony import */ var _langs_long_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./langs/long.js */ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oneTap/langs/long.js");








const logoSvg = `
  <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path id="logoBg" fill-rule="evenodd" clip-rule="evenodd" d="M4.2653 4.2653C3 5.5306 3 7.56707 3 11.64V12.36C3 16.4329 3 18.4694 4.2653 19.7347C5.5306 21 7.56706 21 11.64 21H12.36C16.4329 21 18.4694 21 19.7347 19.7347C21 18.4694 21 16.4329 21 12.36V11.64C21 7.56707 21 5.5306 19.7347 4.2653C18.4694 3 16.4329 3 12.36 3H11.64C7.56706 3 5.5306 3 4.2653 4.2653Z" fill="white"/>
    <path id="logoIcon" d="M12.6095 16C8.55576 16 6.09636 13.1823 6 8.5H8.05309C8.1171 11.9395 9.67903 13.397 10.8764 13.6967V8.5H12.8439V11.4683C13.9988 11.3401 15.2076 9.98991 15.614 8.5H17.5505C17.2406 10.3321 15.9246 11.6823 14.9948 12.2392C15.9253 12.6895 17.4225 13.8682 18 16H15.8714C15.4219 14.5749 14.321 13.4712 12.8446 13.3213V16H12.6095Z" fill="#0077FF"/>
  </svg>
`;
const spinnerSvg = `
  <svg width="28" height="28" viewBox="0 0 28 28" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M14 22C13.4477 22 13 21.5523 13 21C13 20.4477 13.4477 20 14 20C17.3137 20 20 17.3137 20 14C20 10.6863 17.3137 8 14 8C10.6863 8 8 10.6863 8 14C8 14.6472 8.10214 15.2793 8.3002 15.8802C8.4731 16.4047 8.18807 16.9701 7.66355 17.143C7.13902 17.3159 6.57365 17.0308 6.40074 16.5063C6.13628 15.7041 6 14.8606 6 14C6 9.58172 9.58172 6 14 6C18.4183 6 22 9.58172 22 14C22 18.4183 18.4183 22 14 22Z" fill="currentColor"/>
  </svg>
`;
const getOneTapTemplate = ({ width, height, iframeHeight, borderRadius, login, skin, scheme, contentId, lang, renderOAuthList, providers, setStatsButtonType })=>(id)=>{
        let textIconLimit = 0;
        let textLongLimit = 0;
        let textShortWidth = 0;
        let textLongWidth = 0;
        const initialText = (0,_langs_short_js__WEBPACK_IMPORTED_MODULE_0__.getShortLang)(contentId, lang);
        const shortText = _langs_index_js__WEBPACK_IMPORTED_MODULE_1__.providerLang;
        const longText = (0,_langs_long_js__WEBPACK_IMPORTED_MODULE_2__.getLongLang)(contentId, lang);
        const textPadding = 8;
        const padding = (0,_utils_styles_js__WEBPACK_IMPORTED_MODULE_3__.getButtonPadding)(height);
        const fontSize = (0,_utils_styles_js__WEBPACK_IMPORTED_MODULE_3__.getButtonFontSize)(height);
        const logoSize = (0,_utils_styles_js__WEBPACK_IMPORTED_MODULE_3__.getButtonLogoSize)(height);
        const containerEl = document.createElement('div');
        const buttonEl = document.createElement('button');
        setTimeout(()=>{
            buttonEl.classList.add(`VkIdWebSdk__button_animation_${id}`);
        }, 100);
        buttonEl.classList.add(`VkIdWebSdk__button_${id}`);
        buttonEl.classList.add(`VkIdWebSdk__button_reset_${id}`);
        login && (buttonEl.onclick = login);
        const btnInEl = document.createElement('span');
        btnInEl.classList.add(`VkIdWebSdk__button_in_${id}`);
        const contentEl = document.createElement('span');
        contentEl.classList.add(`VkIdWebSdk__button_content_${id}`);
        const logoEl = document.createElement('span');
        logoEl.classList.add(`VkIdWebSdk__button_logo_${id}`);
        logoEl.innerHTML = logoSvg;
        const textContainerEl = document.createElement('span');
        textContainerEl.classList.add(`VkIdWebSdk__button_text_${id}`);
        const textEl = document.createElement('span');
        textEl.innerText = initialText;
        const textLongEl = document.createElement('span');
        textLongEl.innerText = longText;
        const textShortEl = document.createElement('span');
        textShortEl.innerText = shortText;
        const spinnerEl = document.createElement('span');
        spinnerEl.classList.add(`VkIdWebSdk__button_spinner_${id}`);
        spinnerEl.innerHTML = spinnerSvg;
        const oauthListEl = document.createElement('div');
        oauthListEl.classList.add(`VkIdWebSdk__oauthList_container_${id}`);
        const getTextWidth = (clientWidth)=>{
            return clientWidth + 2 * textPadding + 2 * padding + 2 * logoSize;
        };
        const handleLoaded = ()=>{
            let ANIMATION_TIMEOUT = 0;
            let renderedOauthList = false;
            const addOauthList = ()=>{
                if (providers?.length && !containerEl.contains(oauthListEl)) {
                    containerEl.appendChild(oauthListEl);
                    !renderedOauthList && renderOAuthList({
                        lang,
                        scheme,
                        container: oauthListEl,
                        oauthList: providers,
                        styles: {
                            borderRadius,
                            height
                        }
                    });
                    renderedOauthList = true;
                }
            };
            const observeCallback = ()=>{
                const hasTextContainer = contentEl.contains(textContainerEl);
                const hasShortText = textContainerEl.contains(textShortEl);
                const hasLongText = textContainerEl.contains(textLongEl);
                const containerWidth = containerEl.clientWidth;
                if (hasTextContainer && containerWidth < textIconLimit) {
                    if (containerEl.contains(oauthListEl)) {
                        containerEl.removeChild(oauthListEl);
                    }
                    setStatsButtonType('icon');
                    buttonEl.setAttribute('style', `width: ${height}px;`);
                    textContainerEl.remove();
                    spinnerEl.remove();
                }
                if (!hasTextContainer && containerWidth >= textIconLimit) {
                    buttonEl.removeAttribute('style');
                    contentEl.appendChild(textContainerEl);
                    contentEl.appendChild(spinnerEl);
                }
                if (!hasShortText && containerWidth < textLongLimit) {
                    textContainerEl.style.width = `${textShortWidth}px`;
                    textLongEl.dataset.active = '';
                    textShortEl.dataset.active = 'true';
                    setTimeout(()=>{
                        // Дожидаемся анимации и меняем элементы
                        textLongEl.remove();
                        textContainerEl.appendChild(textShortEl);
                    }, ANIMATION_TIMEOUT);
                }
                if (!hasLongText && containerWidth >= textLongLimit) {
                    textContainerEl.style.width = `${textLongWidth}px`;
                    textShortEl.dataset.active = '';
                    textLongEl.dataset.active = 'true';
                    setTimeout(()=>{
                        // Дожидаемся анимации и меняем элементы
                        textShortEl.remove();
                        textContainerEl.appendChild(textLongEl);
                    }, ANIMATION_TIMEOUT);
                    addOauthList();
                }
                setStatsButtonType('default');
            };
            const observer = new _lib_resize_observer_polyfill_dist_ResizeObserver_es_js__WEBPACK_IMPORTED_MODULE_4__["default"]((0,_lib_vkontakte_vkjs_lib_es6_functions_js__WEBPACK_IMPORTED_MODULE_5__.debounce)(observeCallback, 500));
            observer.observe(containerEl);
            const oneTap = document.getElementById(id);
            if (oneTap) {
                oneTap.appendChild(containerEl);
                containerEl.appendChild(buttonEl);
                buttonEl.appendChild(btnInEl);
                btnInEl.appendChild(contentEl);
                contentEl.appendChild(logoEl);
                contentEl.appendChild(textContainerEl);
                contentEl.appendChild(spinnerEl);
                textContainerEl.appendChild(textEl);
                textContainerEl.appendChild(textLongEl);
                textContainerEl.appendChild(textShortEl);
                textShortWidth = textShortEl.clientWidth;
                textLongWidth = textLongEl.clientWidth;
                textIconLimit = getTextWidth(textEl.clientWidth);
                textLongLimit = getTextWidth(textLongWidth);
                textEl.remove();
                textLongEl.remove();
                textShortEl.remove();
                observeCallback();
                ANIMATION_TIMEOUT = 250;
            }
        };
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', handleLoaded);
        } else {
            setTimeout(handleLoaded, 0);
        }
        return `
<div id="${id}" data-test-id="oneTap" data-scheme="${scheme}" data-skin="${skin}">
  <style>
    :root #${id} {
      --onetap--button_background: #0077FF;
      --onetap--button_border: none;
      --onetap--background_hover: #0071F2;
      --onetap--text_and_spinner: #FFF;
      --onetap--logo_icon: #0077FF;
      --onetap--logo_background: #FFF;
    }

    :root #${id}[data-scheme=light][data-skin=primary] {
      --onetap--background_hover: #0071F2;
      --onetap--background_active: #0069E1;
    }

    :root #${id}[data-scheme=dark][data-skin=primary] {
      --onetap--background_hover: #097EFF;
      --onetap--background_active: #1385FF;
    }

    :root #${id}[data-scheme=light][data-skin=secondary] {
      --onetap--button_background: rgba(255, 255, 255, 0.12);
      --onetap--button_border: 1px solid rgba(0, 0, 0, 0.12);
      --onetap--background_hover: #F5F5F7;
      --onetap--background_active: #EBECEF;
      --onetap--text_and_spinner: #000;
      --onetap--logo_icon: #FFF;
      --onetap--logo_background: #0077FF;
    }

    :root #${id}[data-scheme=dark][data-skin=secondary] {
      --onetap--button_background: transparent;
      --onetap--button_border: 1px solid rgba(255, 255, 255, 0.12);
      --onetap--background_hover: rgba(255, 255, 255, 0.06);
      --onetap--background_active: rgba(255, 255, 255, 0.1);
      --onetap--logo_icon: #FFF;
      --onetap--logo_background: #0077FF;
    }

    #${id} {
      position: relative;
      width: ${width ? `${width}px` : '100%'};
      min-width: ${height}px;
    }

    #${id}[data-state=loaded] {
      height: ${iframeHeight}px;
    }

    #${id} iframe {
      position: absolute;
      top: 0;
      left: 0;
      opacity: 0;
      pointer-events: none;
      border: none;
      color-scheme: auto;
    }

    #${id} .VkIdWebSdk__button_reset_${id} {
      border: none;
      margin: 0;
      padding: 0;
      width: auto;
      overflow: visible;
      background: transparent;
      color: inherit;
      font: inherit;
      line-height: normal;
      -webkit-font-smoothing: inherit;
      -moz-osx-font-smoothing: inherit;
      -webkit-appearance: none;
    }

    #${id} .VkIdWebSdk__button_${id} {
      padding: ${padding}px;
      height: ${height}px;
      width: 100%;
      border-radius: ${borderRadius}px;
      box-sizing: border-box;
      overflow: hidden;
    }

    #${id} .VkIdWebSdk__button_animation_${id} {
      transition: .2s ease;
    }

    #${id} .VkIdWebSdk__button_${id}:hover {
      cursor: pointer;
    }

    #${id} .VkIdWebSdk__button_${id} {
      background: var(--onetap--button_background);
      border: var(--onetap--button_border);
    }

    #${id} .VkIdWebSdk__button_${id}:focus,
    #${id} .VkIdWebSdk__button_${id}:hover {
      background: var(--onetap--background_hover);
    }

    #${id} .VkIdWebSdk__button_${id}:active {
      background: var(--onetap--background_active);
    }

    #${id} .VkIdWebSdk__button_in_${id} {
      display: inline-block;
      width: 100%;
      height: 100%;
      min-width: max-content;
      transition: width 0.5s;
    }

    #${id} .VkIdWebSdk__button_content_${id} {
      display: flex;
      align-items: center;
      justify-content: space-between;
      height: 100%;
    }

    #${id} .VkIdWebSdk__button_logo_${id},
    #${id} .VkIdWebSdk__button_spinner_${id},
    #${id} .VkIdWebSdk__button_logo_${id} > svg,
    #${id} .VkIdWebSdk__button_spinner_${id} > svg {
      width: ${logoSize}px;
      height: ${logoSize}px;
    }

    #${id} .VkIdWebSdk__button_spinner_${id} > svg {
      position: absolute;
      right: ${padding}px;
      animation: vkIdSdkButtonSpinner 0.7s linear infinite;
    }

    #${id} .VkIdWebSdk__button_text_${id} {
      font-family: -apple-system, system-ui, "Helvetica Neue", Roboto, sans-serif;
      font-weight: 500;
      font-size: ${fontSize}px;
      transition: .2s;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
    }

    #${id} .VkIdWebSdk__button_text_${id} > span {
      opacity: 0;
      display: inline-block;
      padding: 0 ${textPadding}px;
      transition: .5s;
    }

    #${id} .VkIdWebSdk__button_text_${id} > span[data-active=true] {
      opacity: 1;
    }

    #${id} .VkIdWebSdk__button_text_${id},
    #${id} .VkIdWebSdk__button_spinner_${id} {
      color: var(--onetap--text_and_spinner);
    }

    .VkIdWebSdk__oauthList_container_${id} {
      margin-top: 16px;
    }

    #${id} #logoBg {
      fill: var(--onetap--logo_background);
    }

    #${id} #logoIcon {
      fill: var(--onetap--logo_icon);
    }

    #${id}[data-state=not_loaded] .VkIdWebSdk__button_in_${id} {
      width: 0;
    }

    #${id}[data-state=not_loaded] .VkIdWebSdk__button_spinner_${id} {
      transition: .2s;
      opacity: 0;
      pointer-events: none;
      width: 0;
    }

    #${id}[data-state=loaded] .VkIdWebSdk__oauthList_container_${id} {
      display: none;
    }

    #${id}[data-state=loaded] iframe {
      position: initial;
      opacity: 100;
      pointer-events: all;
    }

    #${id}[data-state=loaded] .VkIdWebSdk__button_${id} {
      display: none;
    }

    @keyframes vkIdSdkButtonSpinner {
      0% {
        transform: rotate(0deg);
      }
      100% {
        transform: rotate(360deg);
      }
    }
  </style>
  <iframe width="100%" height="100%" />
</div>
  `;
    };




/***/ }),

/***/ "./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oneTap/types.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@vkid/sdk/dist-sdk/esm/widgets/oneTap/types.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OneTapContentId: () => (/* binding */ OneTapContentId),
/* harmony export */   OneTapSkin: () => (/* binding */ OneTapSkin)
/* harmony export */ });
var OneTapSkin;
(function(OneTapSkin) {
    OneTapSkin["Primary"] = 'primary';
    OneTapSkin["Secondary"] = 'secondary';
})(OneTapSkin || (OneTapSkin = {}));
var OneTapContentId;
(function(OneTapContentId) {
    OneTapContentId[OneTapContentId[/**
   * Войти
   */ "SIGN_IN"] = 0] = "SIGN_IN";
    OneTapContentId[OneTapContentId[/**
   * Записаться
   */ "SIGN_UP"] = 1] = "SIGN_UP";
    OneTapContentId[OneTapContentId[/**
   * Получить
   */ "GET"] = 2] = "GET";
    OneTapContentId[OneTapContentId[/**
   * Открыть
   */ "OPEN"] = 3] = "OPEN";
    OneTapContentId[OneTapContentId[/**
   * Рассчитать
   */ "CALCULATE"] = 4] = "CALCULATE";
    OneTapContentId[OneTapContentId[/**
   * Заказать
   */ "ORDER"] = 5] = "ORDER";
    OneTapContentId[OneTapContentId[/**
   * Оформить заказ
   */ "PLACE_ORDER"] = 6] = "PLACE_ORDER";
    OneTapContentId[OneTapContentId[/**
   * Оставить заявку
   */ "SUBMIT_REQUEST"] = 7] = "SUBMIT_REQUEST";
    OneTapContentId[OneTapContentId[/**
   * Участвовать
   */ "PARTICIPATE"] = 8] = "PARTICIPATE";
})(OneTapContentId || (OneTapContentId = {}));




/***/ }),

/***/ "./node_modules/crypto-js/core.js":
/*!****************************************!*\
  !*** ./node_modules/crypto-js/core.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory();
	}
	else {}
}(this, function () {

	/*globals window, global, require*/

	/**
	 * CryptoJS core components.
	 */
	var CryptoJS = CryptoJS || (function (Math, undefined) {

	    var crypto;

	    // Native crypto from window (Browser)
	    if (typeof window !== 'undefined' && window.crypto) {
	        crypto = window.crypto;
	    }

	    // Native crypto in web worker (Browser)
	    if (typeof self !== 'undefined' && self.crypto) {
	        crypto = self.crypto;
	    }

	    // Native crypto from worker
	    if (typeof globalThis !== 'undefined' && globalThis.crypto) {
	        crypto = globalThis.crypto;
	    }

	    // Native (experimental IE 11) crypto from window (Browser)
	    if (!crypto && typeof window !== 'undefined' && window.msCrypto) {
	        crypto = window.msCrypto;
	    }

	    // Native crypto from global (NodeJS)
	    if (!crypto && typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g.crypto) {
	        crypto = __webpack_require__.g.crypto;
	    }

	    // Native crypto import via require (NodeJS)
	    if (!crypto && "function" === 'function') {
	        try {
	            crypto = __webpack_require__(/*! crypto */ "?9157");
	        } catch (err) {}
	    }

	    /*
	     * Cryptographically secure pseudorandom number generator
	     *
	     * As Math.random() is cryptographically not safe to use
	     */
	    var cryptoSecureRandomInt = function () {
	        if (crypto) {
	            // Use getRandomValues method (Browser)
	            if (typeof crypto.getRandomValues === 'function') {
	                try {
	                    return crypto.getRandomValues(new Uint32Array(1))[0];
	                } catch (err) {}
	            }

	            // Use randomBytes method (NodeJS)
	            if (typeof crypto.randomBytes === 'function') {
	                try {
	                    return crypto.randomBytes(4).readInt32LE();
	                } catch (err) {}
	            }
	        }

	        throw new Error('Native crypto module could not be used to get secure random number.');
	    };

	    /*
	     * Local polyfill of Object.create

	     */
	    var create = Object.create || (function () {
	        function F() {}

	        return function (obj) {
	            var subtype;

	            F.prototype = obj;

	            subtype = new F();

	            F.prototype = null;

	            return subtype;
	        };
	    }());

	    /**
	     * CryptoJS namespace.
	     */
	    var C = {};

	    /**
	     * Library namespace.
	     */
	    var C_lib = C.lib = {};

	    /**
	     * Base object for prototypal inheritance.
	     */
	    var Base = C_lib.Base = (function () {


	        return {
	            /**
	             * Creates a new object that inherits from this object.
	             *
	             * @param {Object} overrides Properties to copy into the new object.
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         field: 'value',
	             *
	             *         method: function () {
	             *         }
	             *     });
	             */
	            extend: function (overrides) {
	                // Spawn
	                var subtype = create(this);

	                // Augment
	                if (overrides) {
	                    subtype.mixIn(overrides);
	                }

	                // Create default initializer
	                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
	                    subtype.init = function () {
	                        subtype.$super.init.apply(this, arguments);
	                    };
	                }

	                // Initializer's prototype is the subtype object
	                subtype.init.prototype = subtype;

	                // Reference supertype
	                subtype.$super = this;

	                return subtype;
	            },

	            /**
	             * Extends this object and runs the init method.
	             * Arguments to create() will be passed to init().
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var instance = MyType.create();
	             */
	            create: function () {
	                var instance = this.extend();
	                instance.init.apply(instance, arguments);

	                return instance;
	            },

	            /**
	             * Initializes a newly created object.
	             * Override this method to add some logic when your objects are created.
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         init: function () {
	             *             // ...
	             *         }
	             *     });
	             */
	            init: function () {
	            },

	            /**
	             * Copies properties into this object.
	             *
	             * @param {Object} properties The properties to mix in.
	             *
	             * @example
	             *
	             *     MyType.mixIn({
	             *         field: 'value'
	             *     });
	             */
	            mixIn: function (properties) {
	                for (var propertyName in properties) {
	                    if (properties.hasOwnProperty(propertyName)) {
	                        this[propertyName] = properties[propertyName];
	                    }
	                }

	                // IE won't copy toString using the loop above
	                if (properties.hasOwnProperty('toString')) {
	                    this.toString = properties.toString;
	                }
	            },

	            /**
	             * Creates a copy of this object.
	             *
	             * @return {Object} The clone.
	             *
	             * @example
	             *
	             *     var clone = instance.clone();
	             */
	            clone: function () {
	                return this.init.prototype.extend(this);
	            }
	        };
	    }());

	    /**
	     * An array of 32-bit words.
	     *
	     * @property {Array} words The array of 32-bit words.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var WordArray = C_lib.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of 32-bit words.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.create();
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 4;
	            }
	        },

	        /**
	         * Converts this word array to a string.
	         *
	         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
	         *
	         * @return {string} The stringified word array.
	         *
	         * @example
	         *
	         *     var string = wordArray + '';
	         *     var string = wordArray.toString();
	         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
	         */
	        toString: function (encoder) {
	            return (encoder || Hex).stringify(this);
	        },

	        /**
	         * Concatenates a word array to this word array.
	         *
	         * @param {WordArray} wordArray The word array to append.
	         *
	         * @return {WordArray} This word array.
	         *
	         * @example
	         *
	         *     wordArray1.concat(wordArray2);
	         */
	        concat: function (wordArray) {
	            // Shortcuts
	            var thisWords = this.words;
	            var thatWords = wordArray.words;
	            var thisSigBytes = this.sigBytes;
	            var thatSigBytes = wordArray.sigBytes;

	            // Clamp excess bits
	            this.clamp();

	            // Concat
	            if (thisSigBytes % 4) {
	                // Copy one byte at a time
	                for (var i = 0; i < thatSigBytes; i++) {
	                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
	                }
	            } else {
	                // Copy one word at a time
	                for (var j = 0; j < thatSigBytes; j += 4) {
	                    thisWords[(thisSigBytes + j) >>> 2] = thatWords[j >>> 2];
	                }
	            }
	            this.sigBytes += thatSigBytes;

	            // Chainable
	            return this;
	        },

	        /**
	         * Removes insignificant bits.
	         *
	         * @example
	         *
	         *     wordArray.clamp();
	         */
	        clamp: function () {
	            // Shortcuts
	            var words = this.words;
	            var sigBytes = this.sigBytes;

	            // Clamp
	            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
	            words.length = Math.ceil(sigBytes / 4);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = wordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone.words = this.words.slice(0);

	            return clone;
	        },

	        /**
	         * Creates a word array filled with random bytes.
	         *
	         * @param {number} nBytes The number of random bytes to generate.
	         *
	         * @return {WordArray} The random word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.random(16);
	         */
	        random: function (nBytes) {
	            var words = [];

	            for (var i = 0; i < nBytes; i += 4) {
	                words.push(cryptoSecureRandomInt());
	            }

	            return new WordArray.init(words, nBytes);
	        }
	    });

	    /**
	     * Encoder namespace.
	     */
	    var C_enc = C.enc = {};

	    /**
	     * Hex encoding strategy.
	     */
	    var Hex = C_enc.Hex = {
	        /**
	         * Converts a word array to a hex string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The hex string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var hexChars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                hexChars.push((bite >>> 4).toString(16));
	                hexChars.push((bite & 0x0f).toString(16));
	            }

	            return hexChars.join('');
	        },

	        /**
	         * Converts a hex string to a word array.
	         *
	         * @param {string} hexStr The hex string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
	         */
	        parse: function (hexStr) {
	            // Shortcut
	            var hexStrLength = hexStr.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < hexStrLength; i += 2) {
	                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
	            }

	            return new WordArray.init(words, hexStrLength / 2);
	        }
	    };

	    /**
	     * Latin1 encoding strategy.
	     */
	    var Latin1 = C_enc.Latin1 = {
	        /**
	         * Converts a word array to a Latin1 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Latin1 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var latin1Chars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                latin1Chars.push(String.fromCharCode(bite));
	            }

	            return latin1Chars.join('');
	        },

	        /**
	         * Converts a Latin1 string to a word array.
	         *
	         * @param {string} latin1Str The Latin1 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
	         */
	        parse: function (latin1Str) {
	            // Shortcut
	            var latin1StrLength = latin1Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < latin1StrLength; i++) {
	                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
	            }

	            return new WordArray.init(words, latin1StrLength);
	        }
	    };

	    /**
	     * UTF-8 encoding strategy.
	     */
	    var Utf8 = C_enc.Utf8 = {
	        /**
	         * Converts a word array to a UTF-8 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-8 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            try {
	                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
	            } catch (e) {
	                throw new Error('Malformed UTF-8 data');
	            }
	        },

	        /**
	         * Converts a UTF-8 string to a word array.
	         *
	         * @param {string} utf8Str The UTF-8 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
	         */
	        parse: function (utf8Str) {
	            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
	        }
	    };

	    /**
	     * Abstract buffered block algorithm template.
	     *
	     * The property blockSize must be implemented in a concrete subtype.
	     *
	     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
	     */
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
	        /**
	         * Resets this block algorithm's data buffer to its initial state.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm.reset();
	         */
	        reset: function () {
	            // Initial values
	            this._data = new WordArray.init();
	            this._nDataBytes = 0;
	        },

	        /**
	         * Adds new data to this block algorithm's buffer.
	         *
	         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm._append('data');
	         *     bufferedBlockAlgorithm._append(wordArray);
	         */
	        _append: function (data) {
	            // Convert string to WordArray, else assume WordArray already
	            if (typeof data == 'string') {
	                data = Utf8.parse(data);
	            }

	            // Append
	            this._data.concat(data);
	            this._nDataBytes += data.sigBytes;
	        },

	        /**
	         * Processes available data blocks.
	         *
	         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	         *
	         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	         *
	         * @return {WordArray} The processed data.
	         *
	         * @example
	         *
	         *     var processedData = bufferedBlockAlgorithm._process();
	         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	         */
	        _process: function (doFlush) {
	            var processedWords;

	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var dataSigBytes = data.sigBytes;
	            var blockSize = this.blockSize;
	            var blockSizeBytes = blockSize * 4;

	            // Count blocks ready
	            var nBlocksReady = dataSigBytes / blockSizeBytes;
	            if (doFlush) {
	                // Round up to include partial blocks
	                nBlocksReady = Math.ceil(nBlocksReady);
	            } else {
	                // Round down to include only full blocks,
	                // less the number of blocks that must remain in the buffer
	                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
	            }

	            // Count words ready
	            var nWordsReady = nBlocksReady * blockSize;

	            // Count bytes ready
	            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

	            // Process blocks
	            if (nWordsReady) {
	                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
	                    // Perform concrete-algorithm logic
	                    this._doProcessBlock(dataWords, offset);
	                }

	                // Remove processed words
	                processedWords = dataWords.splice(0, nWordsReady);
	                data.sigBytes -= nBytesReady;
	            }

	            // Return processed words
	            return new WordArray.init(processedWords, nBytesReady);
	        },

	        /**
	         * Creates a copy of this object.
	         *
	         * @return {Object} The clone.
	         *
	         * @example
	         *
	         *     var clone = bufferedBlockAlgorithm.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone._data = this._data.clone();

	            return clone;
	        },

	        _minBufferSize: 0
	    });

	    /**
	     * Abstract hasher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
	     */
	    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         */
	        cfg: Base.extend(),

	        /**
	         * Initializes a newly created hasher.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
	         *
	         * @example
	         *
	         *     var hasher = CryptoJS.algo.SHA256.create();
	         */
	        init: function (cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this hasher to its initial state.
	         *
	         * @example
	         *
	         *     hasher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-hasher logic
	            this._doReset();
	        },

	        /**
	         * Updates this hasher with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {Hasher} This hasher.
	         *
	         * @example
	         *
	         *     hasher.update('message');
	         *     hasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            // Append
	            this._append(messageUpdate);

	            // Update the hash
	            this._process();

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the hash computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The hash.
	         *
	         * @example
	         *
	         *     var hash = hasher.finalize();
	         *     var hash = hasher.finalize('message');
	         *     var hash = hasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Final message update
	            if (messageUpdate) {
	                this._append(messageUpdate);
	            }

	            // Perform concrete-hasher logic
	            var hash = this._doFinalize();

	            return hash;
	        },

	        blockSize: 512/32,

	        /**
	         * Creates a shortcut function to a hasher's object interface.
	         *
	         * @param {Hasher} hasher The hasher to create a helper for.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	         */
	        _createHelper: function (hasher) {
	            return function (message, cfg) {
	                return new hasher.init(cfg).finalize(message);
	            };
	        },

	        /**
	         * Creates a shortcut function to the HMAC's object interface.
	         *
	         * @param {Hasher} hasher The hasher to use in this HMAC helper.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
	         */
	        _createHmacHelper: function (hasher) {
	            return function (message, key) {
	                return new C_algo.HMAC.init(hasher, key).finalize(message);
	            };
	        }
	    });

	    /**
	     * Algorithm namespace.
	     */
	    var C_algo = C.algo = {};

	    return C;
	}(Math));


	return CryptoJS;

}));

/***/ }),

/***/ "./node_modules/crypto-js/enc-base64.js":
/*!**********************************************!*\
  !*** ./node_modules/crypto-js/enc-base64.js ***!
  \**********************************************/
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * Base64 encoding strategy.
	     */
	    var Base64 = C_enc.Base64 = {
	        /**
	         * Converts a word array to a Base64 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Base64 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;
	            var map = this._map;

	            // Clamp excess bits
	            wordArray.clamp();

	            // Convert
	            var base64Chars = [];
	            for (var i = 0; i < sigBytes; i += 3) {
	                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
	                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
	                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

	                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

	                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
	                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
	                }
	            }

	            // Add padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                while (base64Chars.length % 4) {
	                    base64Chars.push(paddingChar);
	                }
	            }

	            return base64Chars.join('');
	        },

	        /**
	         * Converts a Base64 string to a word array.
	         *
	         * @param {string} base64Str The Base64 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
	         */
	        parse: function (base64Str) {
	            // Shortcuts
	            var base64StrLength = base64Str.length;
	            var map = this._map;
	            var reverseMap = this._reverseMap;

	            if (!reverseMap) {
	                    reverseMap = this._reverseMap = [];
	                    for (var j = 0; j < map.length; j++) {
	                        reverseMap[map.charCodeAt(j)] = j;
	                    }
	            }

	            // Ignore padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                var paddingIndex = base64Str.indexOf(paddingChar);
	                if (paddingIndex !== -1) {
	                    base64StrLength = paddingIndex;
	                }
	            }

	            // Convert
	            return parseLoop(base64Str, base64StrLength, reverseMap);

	        },

	        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
	    };

	    function parseLoop(base64Str, base64StrLength, reverseMap) {
	      var words = [];
	      var nBytes = 0;
	      for (var i = 0; i < base64StrLength; i++) {
	          if (i % 4) {
	              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);
	              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);
	              var bitsCombined = bits1 | bits2;
	              words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);
	              nBytes++;
	          }
	      }
	      return WordArray.create(words, nBytes);
	    }
	}());


	return CryptoJS.enc.Base64;

}));

/***/ }),

/***/ "./node_modules/crypto-js/sha256.js":
/*!******************************************!*\
  !*** ./node_modules/crypto-js/sha256.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"));
	}
	else {}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Initialization and round constants tables
	    var H = [];
	    var K = [];

	    // Compute constants
	    (function () {
	        function isPrime(n) {
	            var sqrtN = Math.sqrt(n);
	            for (var factor = 2; factor <= sqrtN; factor++) {
	                if (!(n % factor)) {
	                    return false;
	                }
	            }

	            return true;
	        }

	        function getFractionalBits(n) {
	            return ((n - (n | 0)) * 0x100000000) | 0;
	        }

	        var n = 2;
	        var nPrime = 0;
	        while (nPrime < 64) {
	            if (isPrime(n)) {
	                if (nPrime < 8) {
	                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
	                }
	                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));

	                nPrime++;
	            }

	            n++;
	        }
	    }());

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-256 hash algorithm.
	     */
	    var SHA256 = C_algo.SHA256 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init(H.slice(0));
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];
	            var f = H[5];
	            var g = H[6];
	            var h = H[7];

	            // Computation
	            for (var i = 0; i < 64; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var gamma0x = W[i - 15];
	                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^
	                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^
	                                   (gamma0x >>> 3);

	                    var gamma1x = W[i - 2];
	                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^
	                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^
	                                   (gamma1x >>> 10);

	                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
	                }

	                var ch  = (e & f) ^ (~e & g);
	                var maj = (a & b) ^ (a & c) ^ (b & c);

	                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
	                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));

	                var t1 = h + sigma1 + ch + K[i] + W[i];
	                var t2 = sigma0 + maj;

	                h = g;
	                g = f;
	                f = e;
	                e = (d + t1) | 0;
	                d = c;
	                c = b;
	                b = a;
	                a = (t1 + t2) | 0;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	            H[5] = (H[5] + f) | 0;
	            H[6] = (H[6] + g) | 0;
	            H[7] = (H[7] + h) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA256('message');
	     *     var hash = CryptoJS.SHA256(wordArray);
	     */
	    C.SHA256 = Hasher._createHelper(SHA256);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA256(message, key);
	     */
	    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
	}(Math));


	return CryptoJS.SHA256;

}));

/***/ }),

/***/ "./node_modules/graph-modal/src/graph-modal.js":
/*!*****************************************************!*\
  !*** ./node_modules/graph-modal/src/graph-modal.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ GraphModal)
/* harmony export */ });
class GraphModal {
  constructor(options) {
    let defaultOptions = {
      isOpen: () => {},
      isClose: () => {},
    }
    this.options = Object.assign(defaultOptions, options);
    this.modal = document.querySelector('.graph-modal');
    this.speed = 300;
    this.animation = 'fade';
    this._reOpen = false;
    this._nextContainer = false;
    this.modalContainer = false;
    this.isOpen = false;
    this.previousActiveElement = false;
    this._focusElements = [
      'a[href]',
      'input',
      'select',
      'textarea',
      'button',
      'iframe',
      '[contenteditable]',
      '[tabindex]:not([tabindex^="-"])'
    ];
    this._fixBlocks = document.querySelectorAll('.fix-block');
    this.events();
  }

  events() {
    if (this.modal) {
      document.addEventListener('click', function (e) {
        const clickedElement = e.target.closest(`[data-graph-path]`);
        if (clickedElement) {
          let target = clickedElement.dataset.graphPath;
          let animation = clickedElement.dataset.graphAnimation;
          let speed = clickedElement.dataset.graphSpeed;
          this.animation = animation ? animation : 'fade';
          this.speed = speed ? parseInt(speed) : 300;
          this._nextContainer = document.querySelector(`[data-graph-target="${target}"]`);
          this.open();
          return;
        }

        if (e.target.closest('.js-modal-close')) {
          this.close();
          return;
        }
      }.bind(this));

      window.addEventListener('keydown', function (e) {
        if (e.keyCode == 27 && this.isOpen) {
          this.close();
        }

        if (e.which == 9 && this.isOpen) {
          this.focusCatch(e);
          return;
        }
      }.bind(this));

      document.addEventListener('click', function (e) {
        if (e.target.classList.contains('graph-modal') && e.target.classList.contains("is-open")) {
          this.close();
        }
      }.bind(this));
    }

  }

  open(selector) {
    this.previousActiveElement = document.activeElement;

    if (this.isOpen) {
      this.reOpen = true;
      this.close();
      return;
    }

    this.modalContainer = this._nextContainer;

    if (selector) {
      this.modalContainer = document.querySelector(`[data-graph-target="${selector}"]`);
    }
    
    this.modalContainer.scrollTo(0, 0)

    this.modal.style.setProperty('--transition-time', `${this.speed / 1000}s`);
    this.modal.classList.add('is-open');

    document.body.style.scrollBehavior = 'auto';
    document.documentElement.style.scrollBehavior = 'auto';

    this.disableScroll();

    this.modalContainer.classList.add('graph-modal-open');
    this.modalContainer.classList.add(this.animation);

    setTimeout(() => {
      this.options.isOpen(this);
      this.modalContainer.classList.add('animate-open');
      this.isOpen = true;
      this.focusTrap();
    }, this.speed);
  }

  close() {
    if (this.modalContainer) {
      this.modalContainer.classList.remove('animate-open');
      this.modalContainer.classList.remove(this.animation);
      this.modal.classList.remove('is-open');
      this.modalContainer.classList.remove('graph-modal-open');

      this.enableScroll();

      document.body.style.scrollBehavior = 'auto';
      document.documentElement.style.scrollBehavior = 'auto';

      this.options.isClose(this);
      this.isOpen = false;
      this.focusTrap();

      if (this.reOpen) {
        this.reOpen = false;
        this.open();
      }
    }
  }

  focusCatch(e) {
    const nodes = this.modalContainer.querySelectorAll(this._focusElements);
    const nodesArray = Array.prototype.slice.call(nodes);
    const focusedItemIndex = nodesArray.indexOf(document.activeElement)
    if (e.shiftKey && focusedItemIndex === 0) {
      nodesArray[nodesArray.length - 1].focus();
      e.preventDefault();
    }
    if (!e.shiftKey && focusedItemIndex === nodesArray.length - 1) {
      nodesArray[0].focus();
      e.preventDefault();
    }
  }

  focusTrap() {
    const nodes = this.modalContainer.querySelectorAll(this._focusElements);
    if (this.isOpen) {
      if (nodes.length) nodes[0].focus();
    } else {
      this.previousActiveElement.focus();
    }
  }

  disableScroll() {
    let pagePosition = window.scrollY;
    this.lockPadding();
    document.body.classList.add('disable-scroll');
    document.body.dataset.position = pagePosition;
    document.body.style.top = -pagePosition + 'px';
  }

  enableScroll() {
    let pagePosition = parseInt(document.body.dataset.position, 10);
    this.unlockPadding();
    document.body.style.top = 'auto';
    document.body.classList.remove('disable-scroll');
    window.scrollTo({
      top: pagePosition,
      left: 0
    });
    document.body.removeAttribute('data-position');
  }

  lockPadding() {
    let paddingOffset = window.innerWidth - document.body.offsetWidth + 'px';
    this._fixBlocks.forEach((el) => {
      el.style.paddingRight = paddingOffset;
    });
    document.body.style.paddingRight = paddingOffset;
  }

  unlockPadding() {
    this._fixBlocks.forEach((el) => {
      el.style.paddingRight = '0px';
    });
    document.body.style.paddingRight = '0px';
  }
}


/***/ }),

/***/ "./node_modules/graph-tabs/src/graph-tabs.js":
/*!***************************************************!*\
  !*** ./node_modules/graph-tabs/src/graph-tabs.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ GraphTabs)
/* harmony export */ });
class GraphTabs {
  constructor(selector, options) {
    let defaultOptions = {
      isChanged: () => {}
    }
    this.options = Object.assign(defaultOptions, options);
    this.selector = selector;
    this.tabs = document.querySelector(`[data-tabs="${selector}"]`);
    if (this.tabs) {
      this.tabList = this.tabs.querySelector('.tabs__nav');
      this.tabsBtns = this.tabList.querySelectorAll('.tabs__nav-btn');
      this.tabsPanels = this.tabs.querySelectorAll('.tabs__panel');
    } else {
      console.error('Селектор data-tabs не существует!');
      return;
    }

    this.check();
    this.init();
    this.events();
  }

  check() {
    if (document.querySelectorAll(`[data-tabs="${this.selector}"]`).length > 1) {
      console.error('Количество элементов с одинаковым data-tabs больше одного!');
      return;
    }

    if (this.tabsBtns.length !== this.tabsPanels.length) {
      console.error('Количество кнопок и элементов табов не совпадает!');
      return;
    }
  }

  init() {
    this.tabList.setAttribute('role', 'tablist');

    this.tabsBtns.forEach((el, i) => {
      el.setAttribute('role', 'tab');
      el.setAttribute('tabindex', '-1');
      el.setAttribute('id', `${this.selector}${i + 1}`);
      el.classList.remove('tabs__nav-btn--active');
    });

    this.tabsPanels.forEach((el, i) => {
      el.setAttribute('role', 'tabpanel');
      el.setAttribute('tabindex', '-1');
      el.setAttribute('aria-labelledby', this.tabsBtns[i].id);
      el.classList.remove('tabs__panel--active');
    });

    this.tabsBtns[0].classList.add('tabs__nav-btn--active');
    this.tabsBtns[0].removeAttribute('tabindex');
    this.tabsBtns[0].setAttribute('aria-selected', 'true');
    this.tabsPanels[0].classList.add('tabs__panel--active');
  }

  events() {
    this.tabsBtns.forEach((el, i) => {
      el.addEventListener('click', (e) => {
        let currentTab = this.tabList.querySelector('[aria-selected]');

        if (e.currentTarget !== currentTab) {
          this.switchTabs(e.currentTarget, currentTab);
        }
      });

      el.addEventListener('keydown', (e) => {
        let index = Array.prototype.indexOf.call(this.tabsBtns, e.currentTarget);

        let dir = null;

        if (e.which === 37) {
          dir = index - 1;
        } else if (e.which === 39) {
          dir = index + 1;
        } else if (e.which === 40) {
          dir = 'down';
        } else {
          dir = null;
        }

        if (dir !== null) {
          if (dir === 'down') {
            this.tabsPanels[i].focus();
          } else if (this.tabsBtns[dir]) {
            this.switchTabs(this.tabsBtns[dir], e.currentTarget);
          }
        }
      });
    });
  }

  switchTabs(newTab, oldTab = this.tabs.querySelector('[aria-selected]')) {
    newTab.focus();
    newTab.removeAttribute('tabindex');
    newTab.setAttribute('aria-selected', 'true');

    oldTab.removeAttribute('aria-selected');
    oldTab.setAttribute('tabindex', '-1');

    let index = Array.prototype.indexOf.call(this.tabsBtns, newTab);
    let oldIndex = Array.prototype.indexOf.call(this.tabsBtns, oldTab);

    this.tabsPanels[oldIndex].classList.remove('tabs__panel--active');
    this.tabsPanels[index].classList.add('tabs__panel--active');

    this.tabsBtns[oldIndex].classList.remove('tabs__nav-btn--active');
    this.tabsBtns[index].classList.add('tabs__nav-btn--active');

    this.options.isChanged(this);
  }
}

/***/ }),

/***/ "./node_modules/smooth-scroll/dist/smooth-scroll.polyfills.min.js":
/*!************************************************************************!*\
  !*** ./node_modules/smooth-scroll/dist/smooth-scroll.polyfills.min.js ***!
  \************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! smooth-scroll v16.1.3 | (c) 2020 Chris Ferdinandi | MIT License | http://github.com/cferdinandi/smooth-scroll */
window.Element&&!Element.prototype.closest&&(Element.prototype.closest=function(e){var t,n=(this.document||this.ownerDocument).querySelectorAll(e),o=this;do{for(t=n.length;0<=--t&&n.item(t)!==o;);}while(t<0&&(o=o.parentElement));return o}),(function(){if("function"==typeof window.CustomEvent)return;function e(e,t){t=t||{bubbles:!1,cancelable:!1,detail:void 0};var n=document.createEvent("CustomEvent");return n.initCustomEvent(e,t.bubbles,t.cancelable,t.detail),n}e.prototype=window.Event.prototype,window.CustomEvent=e})(),(function(){for(var r=0,e=["ms","moz","webkit","o"],t=0;t<e.length&&!window.requestAnimationFrame;++t)window.requestAnimationFrame=window[e[t]+"RequestAnimationFrame"],window.cancelAnimationFrame=window[e[t]+"CancelAnimationFrame"]||window[e[t]+"CancelRequestAnimationFrame"];window.requestAnimationFrame||(window.requestAnimationFrame=function(e,t){var n=(new Date).getTime(),o=Math.max(0,16-(n-r)),a=window.setTimeout((function(){e(n+o)}),o);return r=n+o,a}),window.cancelAnimationFrame||(window.cancelAnimationFrame=function(e){clearTimeout(e)})})(),(function(e,t){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function(){return t(e)}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):0})("undefined"!=typeof __webpack_require__.g?__webpack_require__.g:"undefined"!=typeof window?window:this,(function(M){"use strict";var q={ignore:"[data-scroll-ignore]",header:null,topOnEmptyHash:!0,speed:500,speedAsDuration:!1,durationMax:null,durationMin:null,clip:!0,offset:0,easing:"easeInOutCubic",customEasing:null,updateURL:!0,popstate:!0,emitEvents:!0},I=function(){var n={};return Array.prototype.forEach.call(arguments,(function(e){for(var t in e){if(!e.hasOwnProperty(t))return;n[t]=e[t]}})),n},r=function(e){"#"===e.charAt(0)&&(e=e.substr(1));for(var t,n=String(e),o=n.length,a=-1,r="",i=n.charCodeAt(0);++a<o;){if(0===(t=n.charCodeAt(a)))throw new InvalidCharacterError("Invalid character: the input contains U+0000.");1<=t&&t<=31||127==t||0===a&&48<=t&&t<=57||1===a&&48<=t&&t<=57&&45===i?r+="\\"+t.toString(16)+" ":r+=128<=t||45===t||95===t||48<=t&&t<=57||65<=t&&t<=90||97<=t&&t<=122?n.charAt(a):"\\"+n.charAt(a)}return"#"+r},F=function(){return Math.max(document.body.scrollHeight,document.documentElement.scrollHeight,document.body.offsetHeight,document.documentElement.offsetHeight,document.body.clientHeight,document.documentElement.clientHeight)},L=function(e){return e?(t=e,parseInt(M.getComputedStyle(t).height,10)+e.offsetTop):0;var t},x=function(e,t,n){0===e&&document.body.focus(),n||(e.focus(),document.activeElement!==e&&(e.setAttribute("tabindex","-1"),e.focus(),e.style.outline="none"),M.scrollTo(0,t))},H=function(e,t,n,o){if(t.emitEvents&&"function"==typeof M.CustomEvent){var a=new CustomEvent(e,{bubbles:!0,detail:{anchor:n,toggle:o}});document.dispatchEvent(a)}};return function(o,e){var b,a,A,O,C={};C.cancelScroll=function(e){cancelAnimationFrame(O),O=null,e||H("scrollCancel",b)},C.animateScroll=function(a,r,e){C.cancelScroll();var i=I(b||q,e||{}),c="[object Number]"===Object.prototype.toString.call(a),t=c||!a.tagName?null:a;if(c||t){var s=M.pageYOffset;i.header&&!A&&(A=document.querySelector(i.header));var n,o,u,l,m,d,f,h,p=L(A),g=c?a:(function(e,t,n,o){var a=0;if(e.offsetParent)for(;a+=e.offsetTop,e=e.offsetParent;);return a=Math.max(a-t-n,0),o&&(a=Math.min(a,F()-M.innerHeight)),a})(t,p,parseInt("function"==typeof i.offset?i.offset(a,r):i.offset,10),i.clip),y=g-s,v=F(),w=0,S=(n=y,u=(o=i).speedAsDuration?o.speed:Math.abs(n/1e3*o.speed),o.durationMax&&u>o.durationMax?o.durationMax:o.durationMin&&u<o.durationMin?o.durationMin:parseInt(u,10)),E=function(e){var t,n,o;l||(l=e),w+=e-l,d=s+y*(n=m=1<(m=0===S?0:w/S)?1:m,"easeInQuad"===(t=i).easing&&(o=n*n),"easeOutQuad"===t.easing&&(o=n*(2-n)),"easeInOutQuad"===t.easing&&(o=n<.5?2*n*n:(4-2*n)*n-1),"easeInCubic"===t.easing&&(o=n*n*n),"easeOutCubic"===t.easing&&(o=--n*n*n+1),"easeInOutCubic"===t.easing&&(o=n<.5?4*n*n*n:(n-1)*(2*n-2)*(2*n-2)+1),"easeInQuart"===t.easing&&(o=n*n*n*n),"easeOutQuart"===t.easing&&(o=1- --n*n*n*n),"easeInOutQuart"===t.easing&&(o=n<.5?8*n*n*n*n:1-8*--n*n*n*n),"easeInQuint"===t.easing&&(o=n*n*n*n*n),"easeOutQuint"===t.easing&&(o=1+--n*n*n*n*n),"easeInOutQuint"===t.easing&&(o=n<.5?16*n*n*n*n*n:1+16*--n*n*n*n*n),t.customEasing&&(o=t.customEasing(n)),o||n),M.scrollTo(0,Math.floor(d)),(function(e,t){var n=M.pageYOffset;if(e==t||n==t||(s<t&&M.innerHeight+n)>=v)return C.cancelScroll(!0),x(a,t,c),H("scrollStop",i,a,r),!(O=l=null)})(d,g)||(O=M.requestAnimationFrame(E),l=e)};0===M.pageYOffset&&M.scrollTo(0,0),f=a,h=i,c||history.pushState&&h.updateURL&&history.pushState({smoothScroll:JSON.stringify(h),anchor:f.id},document.title,f===document.documentElement?"#top":"#"+f.id),"matchMedia"in M&&M.matchMedia("(prefers-reduced-motion)").matches?x(a,Math.floor(g),!1):(H("scrollStart",i,a,r),C.cancelScroll(!0),M.requestAnimationFrame(E))}};var t=function(e){if(!e.defaultPrevented&&!(0!==e.button||e.metaKey||e.ctrlKey||e.shiftKey)&&"closest"in e.target&&(a=e.target.closest(o))&&"a"===a.tagName.toLowerCase()&&!e.target.closest(b.ignore)&&a.hostname===M.location.hostname&&a.pathname===M.location.pathname&&/#/.test(a.href)){var t,n;try{t=r(decodeURIComponent(a.hash))}catch(e){t=r(a.hash)}if("#"===t){if(!b.topOnEmptyHash)return;n=document.documentElement}else n=document.querySelector(t);(n=n||"#top"!==t?n:document.documentElement)&&(e.preventDefault(),(function(e){if(history.replaceState&&e.updateURL&&!history.state){var t=M.location.hash;t=t||"",history.replaceState({smoothScroll:JSON.stringify(e),anchor:t||M.pageYOffset},document.title,t||M.location.href)}})(b),C.animateScroll(n,a))}},n=function(e){if(null!==history.state&&history.state.smoothScroll&&history.state.smoothScroll===JSON.stringify(b)){var t=history.state.anchor;"string"==typeof t&&t&&!(t=document.querySelector(r(history.state.anchor)))||C.animateScroll(t,null,{updateURL:!1})}};C.destroy=function(){b&&(document.removeEventListener("click",t,!1),M.removeEventListener("popstate",n,!1),C.cancelScroll(),O=A=a=b=null)};return (function(){if(!("querySelector"in document&&"addEventListener"in M&&"requestAnimationFrame"in M&&"closest"in M.Element.prototype))throw"Smooth Scroll: This browser does not support the required JavaScript methods and browser APIs.";C.destroy(),b=I(q,e||{}),A=b.header?document.querySelector(b.header):null,document.addEventListener("click",t,!1),b.updateURL&&b.popstate&&M.addEventListener("popstate",n,!1)})(),C}}));

/***/ }),

/***/ "ymaps3":
/*!*******************************************************************************************************************!*\
  !*** external ["https://api-maps.yandex.ru/v3/?apikey=5e824dbc-8855-473a-8c31-de0cc93c4481&lang=ru_RU","ymaps3"] ***!
  \*******************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
var __webpack_error__ = new Error();
module.exports = new Promise((resolve, reject) => {
	if(typeof ymaps3 !== "undefined") return resolve();
	__webpack_require__.l("https://api-maps.yandex.ru/v3/?apikey=5e824dbc-8855-473a-8c31-de0cc93c4481&lang=ru_RU", (event) => {
		if(typeof ymaps3 !== "undefined") return resolve();
		var errorType = event && (event.type === 'load' ? 'missing' : event.type);
		var realSrc = event && event.target && event.target.src;
		__webpack_error__.message = 'Loading script failed.\n(' + errorType + ': ' + realSrc + ')';
		__webpack_error__.name = 'ScriptExternalLoadError';
		__webpack_error__.type = errorType;
		__webpack_error__.request = realSrc;
		reject(__webpack_error__);
	}, "ymaps3");
}).then(() => (ymaps3));

/***/ }),

/***/ "?9157":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "./src/js/libs/_choices.js":
/*!*********************************!*\
  !*** ./src/js/libs/_choices.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var choices_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! choices.js */ "./node_modules/choices.js/public/assets/scripts/choices.mjs");

(function () {
  var selects = document.querySelectorAll('[data-choice]');
  if (selects) {
    selects.forEach(function (select) {
      new choices_js__WEBPACK_IMPORTED_MODULE_0__["default"](select, {
        searchEnabled: false,
        searchChoices: false,
        shouldSort: false,
        placeholder: true
        // placeholderValue: 'text'
      });
    });
  }
})();

/***/ }),

/***/ "./src/js/libs/_modals.js":
/*!********************************!*\
  !*** ./src/js/libs/_modals.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var graph_modal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! graph-modal */ "./node_modules/graph-modal/src/graph-modal.js");

new graph_modal__WEBPACK_IMPORTED_MODULE_0__["default"]();
(function () {
  var buttons = document.querySelectorAll('.btn-thanks [data-graph-path]');
  if (buttons) {
    buttons.forEach(function (button) {
      var value = button.getAttribute('data-graph-path');
      button.addEventListener('click', function () {
        new graph_modal__WEBPACK_IMPORTED_MODULE_0__["default"]('modal').open(value);
      });
    });
  }
  var feedbackButton = document.querySelector('[data-graph-path="modal-feedback-success"]');
  var vacancyButton = document.querySelector('[data-graph-path="modal-vacancy-success"]');
  var questionButton = document.querySelector('[data-graph-path="modal-question-success"]');

  // feedbackButton?.click() // Открыть модальное окно "спасибо за отзыв"
  // vacancyButton?.click() // Открыть модальное окно "спасибо за вопрос"
  // questionButton?.click() // Открыть модальное окно "спасибо за резюме"
})();

/***/ }),

/***/ "./src/js/libs/_smooth-scroll.js":
/*!***************************************!*\
  !*** ./src/js/libs/_smooth-scroll.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var smooth_scroll__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! smooth-scroll */ "./node_modules/smooth-scroll/dist/smooth-scroll.polyfills.min.js");

new smooth_scroll__WEBPACK_IMPORTED_MODULE_0__('a[data-scroll]', {
  offset: 16
});

/***/ }),

/***/ "./src/js/libs/_tabs.js":
/*!******************************!*\
  !*** ./src/js/libs/_tabs.js ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var graph_tabs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! graph-tabs */ "./node_modules/graph-tabs/src/graph-tabs.js");

if (document.querySelector('[data-tabs="services-page"]')) {
  new graph_tabs__WEBPACK_IMPORTED_MODULE_0__["default"]('services-page');
}
if (document.querySelector('[data-tabs="all-news"]')) {
  new graph_tabs__WEBPACK_IMPORTED_MODULE_0__["default"]('all-news');
}
if (document.querySelector('[data-tabs="documents-page"]')) {
  new graph_tabs__WEBPACK_IMPORTED_MODULE_0__["default"]('documents-page');
}
if (document.querySelector('[data-tabs="appointments-page"]')) {
  new graph_tabs__WEBPACK_IMPORTED_MODULE_0__["default"]('appointments-page');
}

/***/ }),

/***/ "./src/js/libs/index.js":
/*!******************************!*\
  !*** ./src/js/libs/index.js ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _choices_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_choices.js */ "./src/js/libs/_choices.js");
/* harmony import */ var _tabs_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_tabs.js */ "./src/js/libs/_tabs.js");
/* harmony import */ var _modals_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_modals.js */ "./src/js/libs/_modals.js");
/* harmony import */ var _smooth_scroll_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_smooth-scroll.js */ "./src/js/libs/_smooth-scroll.js");





/***/ }),

/***/ "./src/js/main.js":
/*!************************!*\
  !*** ./src/js/main.js ***!
  \************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _libs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/index.js */ "./src/js/libs/index.js");
/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/index.js */ "./src/js/utils/index.js");
/* harmony import */ var _templates_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./templates/index.js */ "./src/js/templates/index.js");
/* harmony import */ var _project_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./project/index.js */ "./src/js/project/index.js");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_project_index_js__WEBPACK_IMPORTED_MODULE_3__]);
_project_index_js__WEBPACK_IMPORTED_MODULE_3__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];




console.log('gulp');
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "./src/js/project/_breadcrumbs-prev.js":
/*!*********************************************!*\
  !*** ./src/js/project/_breadcrumbs-prev.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
(function () {
  var prevButton = document.querySelector('.breadcrumbs__prev button');
  if (prevButton) {
    prevButton.addEventListener('click', function () {
      window.history.length > 1 ? window.history.back() : indow.location.href = '/';
    });
  }
})();

/***/ }),

/***/ "./src/js/project/_header-search-mobile.js":
/*!*************************************************!*\
  !*** ./src/js/project/_header-search-mobile.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
(function () {
  var blocks = document.querySelectorAll('.select-mobile');
  if (blocks) {
    var documentHandler = function documentHandler(button, list) {
      document.addEventListener('click', function (event) {
        if (!button.contains(event.target) && !list.contains(event.target)) {
          button.setAttribute('aria-expanded', 'false');
          list.classList.remove('select-mobile__list--active');
        }
      });
    };
    var changeHandler = function changeHandler(parent, array) {
      array.forEach(function (item) {
        item.classList.remove('select-mobile__item--active');
      });
      parent.classList.add('select-mobile__item--active');
      //list.classList.remove('select-mobile__list--active')
    };
    blocks.forEach(function (block) {
      var button = block.querySelector('.select-mobile__button');
      var list = block.querySelector('.select-mobile__list');
      var items = block.querySelectorAll('.select-mobile__item');
      items.forEach(function (item, key, array) {
        var input = item.querySelector('.select-mobile__hidden');
        if (input.hasAttribute('checked')) {
          var parent = input.closest('.select-mobile__item');
          parent.classList.add('select-mobile__item--active');
        }
        input.addEventListener('change', function () {
          changeHandler(item, array);
        });
      });
      button.addEventListener('click', function () {
        list.classList.toggle('select-mobile__list--active');
        if (list.classList.contains('select-mobile__list--active')) {
          button.setAttribute('aria-expanded', true);
        } else {
          button.setAttribute('aria-expanded', false);
        }
      });
      documentHandler(button, list);
    });
  }
})();

/***/ }),

/***/ "./src/js/project/_menu-item-highlight.js":
/*!************************************************!*\
  !*** ./src/js/project/_menu-item-highlight.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
(function () {
  var mobileItems = document.querySelectorAll('.header .menu__item--mobile');
  if (mobileItems) {
    var lastItem = mobileItems[mobileItems.length - 1];
    lastItem.classList.add('menu__item--highlight');
  }
})();

/***/ }),

/***/ "./src/js/project/_services-filters.js":
/*!*********************************************!*\
  !*** ./src/js/project/_services-filters.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
(function () {
  var filters = document.querySelectorAll('.services-filters');
  var changeA11yByClass = function changeA11yByClass(wrapper, openButton, closeButton) {
    if (wrapper.classList.contains('services-filters__wrapper--visible')) {
      openButton.setAttribute('aria-expanded', 'true');
      closeButton.setAttribute('aria-expanded', 'true');
      openButton.setAttribute('aria-label', 'Закрыть параметры');
    } else {
      openButton.setAttribute('aria-expanded', 'false');
      closeButton.setAttribute('aria-expanded', 'false');
      openButton.setAttribute('aria-label', 'Открыть параметры');
    }
  };
  if (!filters) {
    return;
  }
  filters.forEach(function (filter) {
    var wrapper = filter.querySelector('.services-filters__wrapper');
    var openButton = filter.querySelector('.services-filters__show');
    var closeButton = filter.querySelector('.services-filters__close');
    if (!wrapper || !openButton || !closeButton) {
      return;
    }
    openButton.addEventListener('click', function () {
      closeButton.classList.toggle('services-filters__close--visible');
      wrapper.classList.toggle('services-filters__wrapper--visible');
      changeA11yByClass(wrapper, openButton, closeButton);
    });
    closeButton.addEventListener('click', function () {
      closeButton.classList.remove('services-filters__close--visible');
      wrapper.classList.remove('services-filters__wrapper--visible');
      changeA11yByClass(wrapper, openButton, closeButton);
    });
  });
})();

/***/ }),

/***/ "./src/js/project/_vk.js":
/*!*******************************!*\
  !*** ./src/js/project/_vk.js ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _vkid_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vkid/sdk */ "./node_modules/@vkid/sdk/dist-sdk/esm/index.js");

_vkid_sdk__WEBPACK_IMPORTED_MODULE_0__.Config.init({
  app: 52881883,
  redirectUrl: 'https://mysite.com',
  state: 'state',
  codeVerifier: 'codeVerifier',
  scope: 'phone email'
});
var authButton = document.createElement('button');
authButton.onclick = function () {
  // После авторизации будет редирект на адрес, указанный в параметре redirectUrl
  _vkid_sdk__WEBPACK_IMPORTED_MODULE_0__.Auth.login()["catch"](console.error);
};
document.getElementById('container').appendChild(authButton);

// VK.Widgets.CommunityMessages("vk_community_messages", 433458018);
// VK.Widgets.CommunityMessages("vk_community_messages", 52881883);

/***/ }),

/***/ "./src/js/project/index.js":
/*!*********************************!*\
  !*** ./src/js/project/index.js ***!
  \*********************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _menu_item_highlight_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_menu-item-highlight.js */ "./src/js/project/_menu-item-highlight.js");
/* harmony import */ var _header_search_mobile_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_header-search-mobile.js */ "./src/js/project/_header-search-mobile.js");
/* harmony import */ var _breadcrumbs_prev_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_breadcrumbs-prev.js */ "./src/js/project/_breadcrumbs-prev.js");
/* harmony import */ var _services_filters_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_services-filters.js */ "./src/js/project/_services-filters.js");
/* harmony import */ var _map_map_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./map/_map.js */ "./src/js/project/map/_map.js");
/* harmony import */ var _vk_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_vk.js */ "./src/js/project/_vk.js");
/* harmony import */ var _sliders_partners_slider_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./sliders/_partners-slider.js */ "./src/js/project/sliders/_partners-slider.js");
/* harmony import */ var _sliders_gallery_slider_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./sliders/_gallery-slider.js */ "./src/js/project/sliders/_gallery-slider.js");
/* harmony import */ var _sliders_office_slider_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./sliders/_office-slider.js */ "./src/js/project/sliders/_office-slider.js");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_map_map_js__WEBPACK_IMPORTED_MODULE_4__]);
_map_map_js__WEBPACK_IMPORTED_MODULE_4__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];









__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "./src/js/project/map/_data.js":
/*!*************************************!*\
  !*** ./src/js/project/map/_data.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   advanceMapSettings: () => (/* binding */ advanceMapSettings),
/* harmony export */   ariaLabelMarkerButton: () => (/* binding */ ariaLabelMarkerButton),
/* harmony export */   baseMapSettings: () => (/* binding */ baseMapSettings),
/* harmony export */   pins: () => (/* binding */ pins)
/* harmony export */ });
// work - Сейчас работает,
// office - Центр оказания услуг,
// road - Выездное обслуживание
var pins = [{
  coordinates: [37.65, 55.75],
  types: ['work', 'office'],
  id: 'element-1',
  htmlContent: {
    title: 'Выездное обслуживание (Анавгай)',
    body: "<p>\u0426\u0435\u043D\u0442\u0440 \u043E\u043A\u0430\u0437\u0430\u043D\u0438\u044F \u0443\u0441\u043B\u0443\u0433 \u0412\u044B\u0435\u0437\u0434\u043D\u043E\u0435 \u043E\u0431\u0441\u043B\u0443\u0436\u0438\u0432\u0430\u043D\u0438\u0435</p><p>2 \u0440\u0430\u0437\u0430 \u0432 \u043C\u0435\u0441\u044F\u0446 (\u043A\u0430\u0436\u0434\u0443\u044E 2-\u044E \u0438 4-\u044E \u0441\u0440\u0435\u0434\u0443 \u043C\u0435\u0441\u044F\u0446\u0430) \u0441 10:00 \u0434\u043E 14:00</p><p>\u0412 \u0437\u0434\u0430\u043D\u0438\u0438 \u0430\u0434\u043C\u0438\u043D\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u0438 \u043F\u043E \u0443\u043B. \u041B\u0435\u043D\u0438\u043D\u0441\u043A\u0430\u044F \u0434. 36, 1-\u0439 \u044D\u0442\u0430\u0436, \u043F\u043E\u043C\u0435\u0449\u0435\u043D\u0438\u0435 \u0431\u0438\u0431\u043B\u0438\u043E\u0442\u0435\u043A\u0438</p><p>\u041F\u0440\u0438\u0451\u043C \u043E\u0441\u0443\u0449\u0435\u0441\u0442\u0432\u043B\u044F\u0435\u0442\u0441\u044F \u043F\u043E\xA0\u0437\u0430\u043F\u0438\u0441\u0438 \u043F\u043E\xA0\u0442\u0435\u043B\u0435\u0444\u043E\u043D\u0443 <a href=\"tel:+74154221031\">8(41542) 21\u20130-31</a> </p>",
    hrefValue: '#'
  }
}, {
  coordinates: [37.66, 55.76],
  types: ['road'],
  id: 'element-2',
  htmlContent: {
    title: 'Выездное обслуживание (Анавгай)',
    body: "<p>\u0426\u0435\u043D\u0442\u0440 \u043E\u043A\u0430\u0437\u0430\u043D\u0438\u044F \u0443\u0441\u043B\u0443\u0433 \u0412\u044B\u0435\u0437\u0434\u043D\u043E\u0435 \u043E\u0431\u0441\u043B\u0443\u0436\u0438\u0432\u0430\u043D\u0438\u0435</p><p>2 \u0440\u0430\u0437\u0430 \u0432 \u043C\u0435\u0441\u044F\u0446 (\u043A\u0430\u0436\u0434\u0443\u044E 2-\u044E \u0438 4-\u044E \u0441\u0440\u0435\u0434\u0443 \u043C\u0435\u0441\u044F\u0446\u0430) \u0441 10:00 \u0434\u043E 14:00</p><p>\u0412 \u0437\u0434\u0430\u043D\u0438\u0438 \u0430\u0434\u043C\u0438\u043D\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u0438 \u043F\u043E \u0443\u043B. \u041B\u0435\u043D\u0438\u043D\u0441\u043A\u0430\u044F \u0434. 36, 1-\u0439 \u044D\u0442\u0430\u0436, \u043F\u043E\u043C\u0435\u0449\u0435\u043D\u0438\u0435 \u0431\u0438\u0431\u043B\u0438\u043E\u0442\u0435\u043A\u0438</p><p>\u041F\u0440\u0438\u0451\u043C \u043E\u0441\u0443\u0449\u0435\u0441\u0442\u0432\u043B\u044F\u0435\u0442\u0441\u044F \u043F\u043E\xA0\u0437\u0430\u043F\u0438\u0441\u0438 \u043F\u043E\xA0\u0442\u0435\u043B\u0435\u0444\u043E\u043D\u0443 <a href=\"tel:+74154221031\">8(41542) 21\u20130-31</a> </p>",
    hrefValue: '#'
  }
}, {
  coordinates: [37.67, 55.77],
  types: ['office'],
  id: 'element-3',
  htmlContent: {
    title: 'Выездное обслуживание (Анавгай)',
    body: "<p>\u0426\u0435\u043D\u0442\u0440 \u043E\u043A\u0430\u0437\u0430\u043D\u0438\u044F \u0443\u0441\u043B\u0443\u0433 \u0412\u044B\u0435\u0437\u0434\u043D\u043E\u0435 \u043E\u0431\u0441\u043B\u0443\u0436\u0438\u0432\u0430\u043D\u0438\u0435</p><p>2 \u0440\u0430\u0437\u0430 \u0432 \u043C\u0435\u0441\u044F\u0446 (\u043A\u0430\u0436\u0434\u0443\u044E 2-\u044E \u0438 4-\u044E \u0441\u0440\u0435\u0434\u0443 \u043C\u0435\u0441\u044F\u0446\u0430) \u0441 10:00 \u0434\u043E 14:00</p><p>\u0412 \u0437\u0434\u0430\u043D\u0438\u0438 \u0430\u0434\u043C\u0438\u043D\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u0438 \u043F\u043E \u0443\u043B. \u041B\u0435\u043D\u0438\u043D\u0441\u043A\u0430\u044F \u0434. 36, 1-\u0439 \u044D\u0442\u0430\u0436, \u043F\u043E\u043C\u0435\u0449\u0435\u043D\u0438\u0435 \u0431\u0438\u0431\u043B\u0438\u043E\u0442\u0435\u043A\u0438</p><p>\u041F\u0440\u0438\u0451\u043C \u043E\u0441\u0443\u0449\u0435\u0441\u0442\u0432\u043B\u044F\u0435\u0442\u0441\u044F \u043F\u043E\xA0\u0437\u0430\u043F\u0438\u0441\u0438 \u043F\u043E\xA0\u0442\u0435\u043B\u0435\u0444\u043E\u043D\u0443 <a href=\"tel:+74154221031\">8(41542) 21\u20130-31</a> </p>",
    hrefValue: '#'
  }
}, {
  coordinates: [37.66, 55.76],
  types: ['work'],
  id: 'element-4',
  htmlContent: {
    title: 'Выездное обслуживание',
    body: "<p>\u0426\u0435\u043D\u0442\u0440 \u043E\u043A\u0430\u0437\u0430\u043D\u0438\u044F \u0443\u0441\u043B\u0443\u0433 \u0412\u044B\u0435\u0437\u0434\u043D\u043E\u0435 \u043E\u0431\u0441\u043B\u0443\u0436\u0438\u0432\u0430\u043D\u0438\u0435</p><p>2 \u0440\u0430\u0437\u0430 \u0432 \u043C\u0435\u0441\u044F\u0446 (\u043A\u0430\u0436\u0434\u0443\u044E 2-\u044E \u0438 4-\u044E \u0441\u0440\u0435\u0434\u0443 \u043C\u0435\u0441\u044F\u0446\u0430) \u0441 10:00 \u0434\u043E 14:00</p><p>\u0412 \u0437\u0434\u0430\u043D\u0438\u0438 \u0430\u0434\u043C\u0438\u043D\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u0438 \u043F\u043E \u0443\u043B. \u041B\u0435\u043D\u0438\u043D\u0441\u043A\u0430\u044F \u0434. 36, 1-\u0439 \u044D\u0442\u0430\u0436, \u043F\u043E\u043C\u0435\u0449\u0435\u043D\u0438\u0435 \u0431\u0438\u0431\u043B\u0438\u043E\u0442\u0435\u043A\u0438</p>",
    hrefValue: '#'
  }
}, {
  coordinates: [37.65, 55.74],
  types: ['work'],
  id: 'element-5',
  htmlContent: {
    title: 'Выездное обслуживание (Анавгай)',
    body: "<p>\u0426\u0435\u043D\u0442\u0440 \u043E\u043A\u0430\u0437\u0430\u043D\u0438\u044F \u0443\u0441\u043B\u0443\u0433 \u0412\u044B\u0435\u0437\u0434\u043D\u043E\u0435 \u043E\u0431\u0441\u043B\u0443\u0436\u0438\u0432\u0430\u043D\u0438\u0435</p><p>2 \u0440\u0430\u0437\u0430 \u0432 \u043C\u0435\u0441\u044F\u0446 (\u043A\u0430\u0436\u0434\u0443\u044E 2-\u044E \u0438 4-\u044E \u0441\u0440\u0435\u0434\u0443 \u043C\u0435\u0441\u044F\u0446\u0430) \u0441 10:00 \u0434\u043E 14:00</p><p>\u0412 \u0437\u0434\u0430\u043D\u0438\u0438 \u0430\u0434\u043C\u0438\u043D\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u0438 \u043F\u043E \u0443\u043B. \u041B\u0435\u043D\u0438\u043D\u0441\u043A\u0430\u044F \u0434. 36, 1-\u0439 \u044D\u0442\u0430\u0436, \u043F\u043E\u043C\u0435\u0449\u0435\u043D\u0438\u0435 \u0431\u0438\u0431\u043B\u0438\u043E\u0442\u0435\u043A\u0438</p><p>\u041F\u0440\u0438\u0451\u043C \u043E\u0441\u0443\u0449\u0435\u0441\u0442\u0432\u043B\u044F\u0435\u0442\u0441\u044F \u043F\u043E\xA0\u0437\u0430\u043F\u0438\u0441\u0438 \u043F\u043E\xA0\u0442\u0435\u043B\u0435\u0444\u043E\u043D\u0443 <a href=\"tel:+74154221031\">8(41542) 21\u20130-31</a> </p>",
    hrefValue: '#'
  }
}, {
  coordinates: [37.63, 55.72],
  types: ['office'],
  id: 'element-7',
  htmlContent: {
    title: 'Выездное обслуживание',
    body: "<p>\u0426\u0435\u043D\u0442\u0440 \u043E\u043A\u0430\u0437\u0430\u043D\u0438\u044F \u0443\u0441\u043B\u0443\u0433 \u0412\u044B\u0435\u0437\u0434\u043D\u043E\u0435 \u043E\u0431\u0441\u043B\u0443\u0436\u0438\u0432\u0430\u043D\u0438\u0435</p><p>2 \u0440\u0430\u0437\u0430 \u0432 \u043C\u0435\u0441\u044F\u0446 (\u043A\u0430\u0436\u0434\u0443\u044E 2-\u044E \u0438 4-\u044E \u0441\u0440\u0435\u0434\u0443 \u043C\u0435\u0441\u044F\u0446\u0430) \u0441 10:00 \u0434\u043E 14:00</p><p>\u0412 \u0437\u0434\u0430\u043D\u0438\u0438 \u0430\u0434\u043C\u0438\u043D\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u0438 \u043F\u043E \u0443\u043B. \u041B\u0435\u043D\u0438\u043D\u0441\u043A\u0430\u044F \u0434. 36, 1-\u0439 \u044D\u0442\u0430\u0436, \u043F\u043E\u043C\u0435\u0449\u0435\u043D\u0438\u0435 \u0431\u0438\u0431\u043B\u0438\u043E\u0442\u0435\u043A\u0438</p>",
    hrefValue: '#'
  }
}, {
  coordinates: [37.64, 55.73],
  types: ['road'],
  id: 'element-6',
  htmlContent: {
    title: 'Выездное обслуживание',
    body: "<p>\u0426\u0435\u043D\u0442\u0440 \u043E\u043A\u0430\u0437\u0430\u043D\u0438\u044F \u0443\u0441\u043B\u0443\u0433 \u0412\u044B\u0435\u0437\u0434\u043D\u043E\u0435 \u043E\u0431\u0441\u043B\u0443\u0436\u0438\u0432\u0430\u043D\u0438\u0435</p><p>2 \u0440\u0430\u0437\u0430 \u0432 \u043C\u0435\u0441\u044F\u0446 (\u043A\u0430\u0436\u0434\u0443\u044E 2-\u044E \u0438 4-\u044E \u0441\u0440\u0435\u0434\u0443 \u043C\u0435\u0441\u044F\u0446\u0430) \u0441 10:00 \u0434\u043E 14:00</p><p>\u0412 \u0437\u0434\u0430\u043D\u0438\u0438 \u0430\u0434\u043C\u0438\u043D\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u0438 \u043F\u043E \u0443\u043B. \u041B\u0435\u043D\u0438\u043D\u0441\u043A\u0430\u044F \u0434. 36, 1-\u0439 \u044D\u0442\u0430\u0436, \u043F\u043E\u043C\u0435\u0449\u0435\u043D\u0438\u0435 \u0431\u0438\u0431\u043B\u0438\u043E\u0442\u0435\u043A\u0438</p>",
    hrefValue: '#'
  }
}];
var ariaLabelMarkerButton = {
  nowOpen: 'Закрыть дополнительную информацию',
  nowClose: 'Открыть дополнительную информацию'
};
var advanceMapSettings = {
  location: {
    center: [37.65080999999997, 55.758412068983525],
    zoom: 12
  }
};
var baseMapSettings = {
  location: {
    center: [37.65080999999997, 55.758412068983525],
    zoom: 12
  }
};

/***/ }),

/***/ "./src/js/project/map/_map.js":
/*!************************************!*\
  !*** ./src/js/project/map/_map.js ***!
  \************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var ymaps3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ymaps3 */ "ymaps3");
/* harmony import */ var _styles_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_styles.json */ "./src/js/project/map/_styles.json");
/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_data.js */ "./src/js/project/map/_data.js");
/* harmony import */ var _utils_geolocation_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/_geolocation.js */ "./src/js/project/map/utils/_geolocation.js");
/* harmony import */ var _utils_handlers_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/_handlers.js */ "./src/js/project/map/utils/_handlers.js");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([ymaps3__WEBPACK_IMPORTED_MODULE_0__]);
ymaps3__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }





function createPin(pin) {
  var wrapper = document.createElement('div');
  wrapper.className = 'marker';
  wrapper.setAttribute('data-custom-marker', 'true');
  var markerButton = document.createElement('button');
  markerButton.className = 'marker__button';
  markerButton.setAttribute('aria-haspopup', 'true');
  (0,_utils_handlers_js__WEBPACK_IMPORTED_MODULE_4__.markerButtonNowCloseA11y)(markerButton);
  markerButton.setAttribute('aria-controls', pin.id);
  var balloonWrapper = document.createElement('div');
  balloonWrapper.innerHTML = "<div class=\"map-balloon map-balloon--hidden\" role=\"tooltip\" id=\"".concat(pin.id, "\">\n    <div class=\"map-balloon__header\">\n        <span class=\"map-balloon__title\">\n            ").concat(pin.htmlContent.title, "\n        </span>\n        <button class=\"map-balloon__close\" type=\"button\" aria-label=\"\u0417\u0430\u043A\u0440\u044B\u0442\u044C\"></button>\n    </div>\n    <div class=\"map-balloon__body\">\n        ").concat(pin.htmlContent.body, "\n    </div>\n    <a class=\"map-balloon__button button button--fill\" href=\"").concat(pin.htmlContent.hrefValue, "\">\n        \u0417\u0430\u043F\u0438\u0441\u0430\u0442\u044C\u0441\u044F\n    </a>\n</div>");
  wrapper.append(markerButton);
  wrapper.append(balloonWrapper);
  pin.types.forEach(function (type) {
    wrapper.setAttribute("data-".concat(type), 'true');
  });
  return wrapper;
}
(function () {
  var mapElement = document.querySelector('[data-map]');
  if (mapElement) {
    var initMap = /*#__PURE__*/function () {
      var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var YMap, YMapDefaultSchemeLayer, YMapDefaultFeaturesLayer, YMapControls, YMapMarker, _yield$ymaps3$import, YMapZoomControl, YMapGeolocationControl, map, controls, filterButtons, nearButton, allCloseButtons, allMarkerButtons;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return ymaps3__WEBPACK_IMPORTED_MODULE_0__.ready;
            case 2:
              _context.next = 4;
              return ymaps3__WEBPACK_IMPORTED_MODULE_0__["import"].registerCdn('https://cdn.jsdelivr.net/npm/{package}', '@yandex/ymaps3-default-ui-theme@0.0.2', '@yandex/ymaps3-controls@0.0.1');
            case 4:
              YMap = ymaps3__WEBPACK_IMPORTED_MODULE_0__.YMap, YMapDefaultSchemeLayer = ymaps3__WEBPACK_IMPORTED_MODULE_0__.YMapDefaultSchemeLayer, YMapDefaultFeaturesLayer = ymaps3__WEBPACK_IMPORTED_MODULE_0__.YMapDefaultFeaturesLayer, YMapControls = ymaps3__WEBPACK_IMPORTED_MODULE_0__.YMapControls, YMapMarker = ymaps3__WEBPACK_IMPORTED_MODULE_0__.YMapMarker;
              _context.next = 7;
              return ymaps3__WEBPACK_IMPORTED_MODULE_0__["import"]('@yandex/ymaps3-default-ui-theme');
            case 7:
              _yield$ymaps3$import = _context.sent;
              YMapZoomControl = _yield$ymaps3$import.YMapZoomControl;
              YMapGeolocationControl = _yield$ymaps3$import.YMapGeolocationControl;
              // создание карты
              map = new YMap(mapElement, isBaseMap ? _data_js__WEBPACK_IMPORTED_MODULE_2__.baseMapSettings : _data_js__WEBPACK_IMPORTED_MODULE_2__.advanceMapSettings);
              map.addChild(new YMapDefaultFeaturesLayer({}));
              if (!isBaseMap) {
                controls = new YMapControls({
                  position: 'right'
                }); //Добавление кнопок + и 
                controls.addChild(new YMapZoomControl({}));
                // Добавление кнопки геолокации
                controls.addChild(new YMapGeolocationControl({}));
                map.addChild(controls);
                _data_js__WEBPACK_IMPORTED_MODULE_2__.pins.forEach(function (pin) {
                  var wrapper = createPin(pin);

                  // Настройка маркера
                  var marker = new YMapMarker({
                    coordinates: pin.coordinates,
                    mapFollowsOnDrag: true
                  }, wrapper);
                  map.addChild(marker);
                });
              }
              filterButtons = document.querySelectorAll('[data-filter-pins]');
              filterButtons && filterButtons.forEach(function (button) {
                button.addEventListener('click', function () {
                  return (0,_utils_handlers_js__WEBPACK_IMPORTED_MODULE_4__.filterButtonClickHandler)(button);
                });
              });
              nearButton = document.querySelector('[data-near]');
              nearButton && nearButton.addEventListener('click', _utils_geolocation_js__WEBPACK_IMPORTED_MODULE_3__.getGeolocation);
              allCloseButtons = document.querySelectorAll('.map-balloon__close'); // обрабатываем клик на крестик в баллуне
              allCloseButtons && allCloseButtons.forEach(function (button) {
                button.addEventListener('click', function () {
                  return (0,_utils_handlers_js__WEBPACK_IMPORTED_MODULE_4__.balloonCloseButtonClickHandler)(button);
                });
              });
              allMarkerButtons = document.querySelectorAll('.marker__button'); // обрабатываем клик на маркер, открываем баллун
              allMarkerButtons && allMarkerButtons.forEach(function (button) {
                button.addEventListener('click', function () {
                  return (0,_utils_handlers_js__WEBPACK_IMPORTED_MODULE_4__.markerButtonClickHandler)(button);
                });
              });

              // подключаем стили
              map.addChild(new YMapDefaultSchemeLayer({
                customization: _styles_json__WEBPACK_IMPORTED_MODULE_1__
              }));
            case 22:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      return function initMap() {
        return _ref.apply(this, arguments);
      };
    }();
    var isBaseMap = mapElement.getAttribute('data-map') === 'base';
    ;
    initMap();
  }
})();
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "./src/js/project/map/utils/_geolocation.js":
/*!**************************************************!*\
  !*** ./src/js/project/map/utils/_geolocation.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getGeolocation: () => (/* binding */ getGeolocation)
/* harmony export */ });
function haversineDistance(coord1, coord2) {
  var R = 6371; // Радиус Земли в километрах
  var dLat = (coord2[1] - coord1[1]) * Math.PI / 180; // Разница в широте
  var dLon = (coord2[0] - coord1[0]) * Math.PI / 180; // Разница в долготе

  var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(coord1[1] * Math.PI / 180) * Math.cos(coord2[1] * Math.PI / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c; // Возвращаем расстояние в километрах
}
function getGeolocation() {
  if ("geolocation" in navigator) {
    navigator.geolocation.getCurrentPosition(function (position) {
      var userCoords = [position.coords.latitude, position.coords.longitude];
      var closestPin = null;
      var closestDistance = Infinity;

      // Ищем ближайший объект
      pins.forEach(function (pin) {
        var distance = haversineDistance(userCoords, pin.coordinates);
        if (distance < closestDistance) {
          closestDistance = distance;
          closestPin = pin;
        }
      });
      var wrappers = document.querySelectorAll('.marker');
      wrappers.forEach(function (wrapper) {
        wrapper.classList.add('marker--hidden');
        checkMarkerA11yByWrapperClass(wrapper);
      });
      var balloon = document.getElementById(closestPin.id);
      var wrapper = balloon.closest('.marker');
      wrapper.classList.remove('marker--hidden');
      checkMarkerA11yByWrapperClass(wrapper);
    }, function (error) {
      console.error("Ошибка получения местоположения: " + error.message);
    });
  } else {
    console.log("Геолокация не поддерживается вашим браузером.");
  }
}

/***/ }),

/***/ "./src/js/project/map/utils/_handlers.js":
/*!***********************************************!*\
  !*** ./src/js/project/map/utils/_handlers.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   balloonCloseButtonClickHandler: () => (/* binding */ balloonCloseButtonClickHandler),
/* harmony export */   filterButtonClickHandler: () => (/* binding */ filterButtonClickHandler),
/* harmony export */   markerButtonClickHandler: () => (/* binding */ markerButtonClickHandler),
/* harmony export */   markerButtonNowCloseA11y: () => (/* binding */ markerButtonNowCloseA11y)
/* harmony export */ });
/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_data.js */ "./src/js/project/map/_data.js");

function markerButtonNowCloseA11y(marker) {
  marker.setAttribute('aria-expanded', 'false');
  marker.setAttribute('aria-label', _data_js__WEBPACK_IMPORTED_MODULE_0__.ariaLabelMarkerButton.nowClose);
}
function markerButtonNowOpenA11y(marker) {
  marker.setAttribute('aria-expanded', 'true');
  marker.setAttribute('aria-label', _data_js__WEBPACK_IMPORTED_MODULE_0__.ariaLabelMarkerButton.nowOpen);
}
function checkMarkerA11yByWrapperClass(wrapper) {
  var marker = wrapper.querySelector('.marker__button');
  wrapper.classList.contains('marker--hidden') ? markerButtonNowCloseA11y(marker) : markerButtonNowOpenA11y(marker);
}
function filterButtonClickHandler(button) {
  var value = button.getAttribute('data-filter-pins');
  var wrappers = document.querySelectorAll('.marker');
  wrappers.forEach(function (wrapper) {
    wrapper.hasAttribute("data-".concat(value)) ? wrapper.classList.remove('marker--hidden') : wrapper.classList.add('marker--hidden');
    checkMarkerA11yByWrapperClass(wrapper);
  });
}
function balloonCloseButtonClickHandler(button) {
  var wrapper = button.closest('.marker');
  var balloon = wrapper.querySelector('.map-balloon');
  var marker = wrapper.querySelector('.marker__button');
  markerButtonNowCloseA11y(marker);
  balloon && balloon.classList.add('map-balloon--hidden');
}
function changeParentZIndex(wrapper) {
  var balloon = wrapper.querySelector('.map-balloon');
  var parent = wrapper.parentNode;
  var parentStyles = parent.getAttribute('style');
  var transformStyle = parentStyles.split(';')[0];
  if (balloon.classList.contains('map-balloon--hidden')) {
    parent.setAttribute('style', "".concat(transformStyle, "; z-index: 0;"));
  } else {
    parent.setAttribute('style', "".concat(transformStyle, "; z-index: 1;"));
  }
}
function markerButtonClickHandler(button) {
  var allBalloons = document.querySelectorAll('.map-balloon');
  allBalloons.forEach(function (balloon) {
    balloon.classList.add('map-balloon--hidden');
    var wrapper = balloon.closest('.marker');
    var marker = wrapper.querySelector('.marker__button');
    changeParentZIndex(wrapper);
    markerButtonNowCloseA11y(marker);
  });
  var parent = button.closest('.marker');
  var balloon = parent.querySelector('.map-balloon');
  markerButtonNowOpenA11y(button);
  balloon && balloon.classList.remove('map-balloon--hidden');
  changeParentZIndex(parent);
}

/***/ }),

/***/ "./src/js/project/sliders/_gallery-slider.js":
/*!***************************************************!*\
  !*** ./src/js/project/sliders/_gallery-slider.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var swiper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! swiper */ "./node_modules/swiper/swiper.mjs");
/* harmony import */ var swiper_modules__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! swiper/modules */ "./node_modules/swiper/modules/index.mjs");


swiper__WEBPACK_IMPORTED_MODULE_0__["default"].use([swiper_modules__WEBPACK_IMPORTED_MODULE_1__.Navigation, swiper_modules__WEBPACK_IMPORTED_MODULE_1__.Thumbs]);
var sliderMain = document.querySelector('.gallery-page .slider-main');
var sliderNav = document.querySelector('.gallery-page .slider-nav');
var wrapperSliderNav = document.querySelector('.gallery-page__thumbs');
if (sliderNav && sliderMain && wrapperSliderNav) {
  var swiperSmall = new swiper__WEBPACK_IMPORTED_MODULE_0__["default"](sliderNav, {
    loopedSlides: 4,
    freeMode: true,
    navigation: {
      nextEl: wrapperSliderNav.querySelector('.swiper-container__button--prev'),
      prevEl: wrapperSliderNav.querySelector('.swiper-container__button--next')
    },
    breakpoints: {
      769: {
        direction: 'vertical',
        slidesPerView: 4,
        spaceBetween: 16,
        slidesPerGroup: 4
      },
      0: {
        direction: 'horizontal',
        slidesPerView: 'auto',
        spaceBetween: 8
      }
    }
  });
  new swiper__WEBPACK_IMPORTED_MODULE_0__["default"](sliderMain, {
    spaceBetween: 10,
    loopedSlides: 4,
    thumbs: {
      swiper: swiperSmall
    },
    navigation: {
      nextEl: sliderMain.querySelector('.swiper-container__button--prev'),
      prevEl: sliderMain.querySelector('.swiper-container__button--next')
    }
  });
}

/***/ }),

/***/ "./src/js/project/sliders/_office-slider.js":
/*!**************************************************!*\
  !*** ./src/js/project/sliders/_office-slider.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var swiper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! swiper */ "./node_modules/swiper/swiper.mjs");
/* harmony import */ var swiper_modules__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! swiper/modules */ "./node_modules/swiper/modules/index.mjs");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }


swiper__WEBPACK_IMPORTED_MODULE_0__["default"].use([swiper_modules__WEBPACK_IMPORTED_MODULE_1__.Navigation]);
if (document.querySelector('.office-department__swiper')) {
  new swiper__WEBPACK_IMPORTED_MODULE_0__["default"]('.office-department__swiper', _defineProperty({
    spaceBetween: 16,
    slidesPerView: 1,
    slidesPerGroup: 1,
    navigation: true
  }, "navigation", {
    nextEl: '.swiper-container__button--next',
    prevEl: '.swiper-container__button--prev'
  }));
}

/***/ }),

/***/ "./src/js/project/sliders/_partners-slider.js":
/*!****************************************************!*\
  !*** ./src/js/project/sliders/_partners-slider.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var swiper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! swiper */ "./node_modules/swiper/swiper.mjs");
/* harmony import */ var swiper_modules__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! swiper/modules */ "./node_modules/swiper/modules/index.mjs");


swiper__WEBPACK_IMPORTED_MODULE_0__["default"].use([swiper_modules__WEBPACK_IMPORTED_MODULE_1__.Navigation, swiper_modules__WEBPACK_IMPORTED_MODULE_1__.Grid]);
if (document.querySelector('.partners__swiper')) {
  new swiper__WEBPACK_IMPORTED_MODULE_0__["default"]('.partners__swiper', {
    breakpoints: {
      992: {
        spaceBetween: 32,
        slidesPerView: 'auto',
        grid: {
          fill: 'row',
          rows: 2
        },
        navigation: {
          nextEl: '.partners__button--next',
          prevEl: '.partners__button--prev'
        }
      },
      0: {
        spaceBetween: 16,
        slidesPerView: 'auto'
      }
    }
  });
}

/***/ }),

/***/ "./src/js/templates/_burger.js":
/*!*************************************!*\
  !*** ./src/js/templates/_burger.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ "./src/js/utils/index.js");

(function () {
  var burgerButton = document.querySelector('[data-burger-button]');
  var menu = document.querySelector('[data-menu]');
  var menuLinks = document.querySelectorAll('[data-menu-link]');
  var checkClass = function checkClass() {
    if (burgerButton.classList.contains('burger-button--active')) {
      document.addEventListener('keydown', keyHandler);
      burgerButton.setAttribute('aria-expanded', 'true');
      burgerButton.setAttribute('aria-label', 'закрыть меню');
      burgerButton.focus();
      (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.disableScroll)();
    } else {
      document.removeEventListener('keydown', keyHandler);
      burgerButton.setAttribute('aria-expanded', 'false');
      burgerButton.setAttribute('aria-label', 'открыть меню');
      (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.enableScroll)();
    }
  };
  var hideBurger = function hideBurger() {
    burgerButton.classList.remove('burger-button--active');
    menu.classList.remove('menu--active');
  };
  burgerButton.addEventListener('click', function () {
    burgerButton.classList.toggle('burger-button--active');
    menu.classList.toggle('menu--active');
    checkClass();
  });
  menuLinks.forEach(function (link) {
    link.addEventListener('click', function () {
      hideBurger();
      (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.enableScroll)();
    });
  });
  var focusCatch = function focusCatch(e) {
    var nodes = menu.querySelectorAll(globalVars.focusEl);
    var nodesArray = Array.prototype.slice.call(nodes);
    var focusedItemIndex = nodesArray.indexOf(document.activeElement);
    if (e.shiftKey && focusedItemIndex === 0) {
      nodesArray[nodesArray.length - 1].focus();
      e.preventDefault();
    }
    if (!e.shiftKey && focusedItemIndex === nodesArray.length - 1) {
      nodesArray[0].focus();
      e.preventDefault();
    }
  };
  var keyHandler = function keyHandler(event) {
    if (menu.classList.contains('menu--active')) {
      if (event.key === 'Escape') {
        hideBurger();
        checkClass();
      }
      if (event.which) {
        focusCatch(event);
      }
    }
  };
})();

/***/ }),

/***/ "./src/js/templates/_stepper.js":
/*!**************************************!*\
  !*** ./src/js/templates/_stepper.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
(function () {
  if (document.querySelector('.stepper')) {
    var stepper = document.querySelector('.stepper');
    var stepperInput = stepper.querySelector('.stepper__input');
    var stepperBtnUp = stepper.querySelector('.stepper__btn--up');
    var stepperBtnDown = stepper.querySelector('.stepper__btn--down');
    var count = stepperInput.value;
    stepperInput.addEventListener('change', function (e) {
      var self = e.currentTarget;
      if (!self.value) {
        self.value = 1;
      }
      count = stepperInput.value;
    });
    stepperBtnUp.addEventListener('click', function (e) {
      e.preventDefault();
      count++;
      stepperInput.value = count;
    });
    stepperBtnDown.addEventListener('click', function (e) {
      e.preventDefault();
      count--;
      stepperInput.value = count;
    });
  }
})();

/***/ }),

/***/ "./src/js/templates/index.js":
/*!***********************************!*\
  !*** ./src/js/templates/index.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _burger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_burger.js */ "./src/js/templates/_burger.js");
/* harmony import */ var _stepper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_stepper.js */ "./src/js/templates/_stepper.js");



/***/ }),

/***/ "./src/js/utils/_disable-scroll.js":
/*!*****************************************!*\
  !*** ./src/js/utils/_disable-scroll.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   disableScroll: () => (/* binding */ disableScroll)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./src/js/utils/index.js");

var disableScroll = function disableScroll() {
  var pagePosition = window.scrollY;
  var paddingOffset = "".concat(window.innerWidth - _index_js__WEBPACK_IMPORTED_MODULE_0__.globalVars.bodyEl.offsetWidth, "px");
  var fixBlocks = document.querySelectorAll('.fix-block');
  if (fixBlocks) {
    fixBlocks.forEach(function (el) {
      var fixBlock = el;
      fixBlock.style.paddingRight = paddingOffset;
    });
  }
  _index_js__WEBPACK_IMPORTED_MODULE_0__.globalVars.htmlEl.style.scrollBehavior = 'none';
  _index_js__WEBPACK_IMPORTED_MODULE_0__.globalVars.bodyEl.style.paddingRight = paddingOffset;
  _index_js__WEBPACK_IMPORTED_MODULE_0__.globalVars.bodyEl.classList.add('disable-scroll');
  _index_js__WEBPACK_IMPORTED_MODULE_0__.globalVars.bodyEl.dataset.position = pagePosition;
  _index_js__WEBPACK_IMPORTED_MODULE_0__.globalVars.bodyEl.style.top = "-".concat(pagePosition, "px");
};

/***/ }),

/***/ "./src/js/utils/_enable-scroll.js":
/*!****************************************!*\
  !*** ./src/js/utils/_enable-scroll.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   enableScroll: () => (/* binding */ enableScroll)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./src/js/utils/index.js");

var enableScroll = function enableScroll() {
  var fixBlocks = document.querySelectorAll('.fix-block');
  if (fixBlocks) {
    fixBlocks.forEach(function (el) {
      var fixBlock = el;
      fixBlock.style.paddingRight = '0';
    });
  }
  var pagePosition = parseInt(_index_js__WEBPACK_IMPORTED_MODULE_0__.globalVars.bodyEl.dataset.position, 10);
  _index_js__WEBPACK_IMPORTED_MODULE_0__.globalVars.bodyEl.style.paddingRight = '0';
  _index_js__WEBPACK_IMPORTED_MODULE_0__.globalVars.bodyEl.style.top = 'auto';
  _index_js__WEBPACK_IMPORTED_MODULE_0__.globalVars.bodyEl.classList.remove('disable-scroll');
  window.scroll({
    top: pagePosition,
    left: 0
  });
  _index_js__WEBPACK_IMPORTED_MODULE_0__.globalVars.bodyEl.removeAttribute('data-position');
};

/***/ }),

/***/ "./src/js/utils/_throttle.js":
/*!***********************************!*\
  !*** ./src/js/utils/_throttle.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   throttle: () => (/* binding */ throttle)
/* harmony export */ });
var throttle = function throttle(func) {
  var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 250;
  var isThrottled = false;
  var savedArgs = null;
  var savedThis = null;
  return function wrap() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (isThrottled) {
      savedArgs = args;
      savedThis = this;
      return;
    }
    func.apply(this, args);
    isThrottled = true;
    setTimeout(function () {
      isThrottled = false;
      if (savedThis) {
        wrap.apply(savedThis, savedArgs);
        savedThis = null;
        savedArgs = null;
      }
    }, delay);
  };
};

/***/ }),

/***/ "./src/js/utils/_vars.js":
/*!*******************************!*\
  !*** ./src/js/utils/_vars.js ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   globalVars: () => (/* binding */ globalVars)
/* harmony export */ });
var globalVars = {
  windowEl: window,
  documentEl: document,
  htmlEl: document.documentElement,
  bodyEl: document.body,
  focusEl: ['a[href]', 'input', 'select', 'textarea', 'button', 'iframe', '[contenteditable]', '[tabindex]:not([tabindex^="-"])']
};

/***/ }),

/***/ "./src/js/utils/index.js":
/*!*******************************!*\
  !*** ./src/js/utils/index.js ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   disableScroll: () => (/* reexport safe */ _disable_scroll_js__WEBPACK_IMPORTED_MODULE_0__.disableScroll),
/* harmony export */   enableScroll: () => (/* reexport safe */ _enable_scroll_js__WEBPACK_IMPORTED_MODULE_1__.enableScroll),
/* harmony export */   globalVars: () => (/* reexport safe */ _vars_js__WEBPACK_IMPORTED_MODULE_3__.globalVars),
/* harmony export */   throttle: () => (/* reexport safe */ _throttle_js__WEBPACK_IMPORTED_MODULE_2__.throttle)
/* harmony export */ });
/* harmony import */ var _disable_scroll_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_disable-scroll.js */ "./src/js/utils/_disable-scroll.js");
/* harmony import */ var _enable_scroll_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_enable-scroll.js */ "./src/js/utils/_enable-scroll.js");
/* harmony import */ var _throttle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_throttle.js */ "./src/js/utils/_throttle.js");
/* harmony import */ var _vars_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_vars.js */ "./src/js/utils/_vars.js");




// import { fixFullheight } from './_fix-fullheight.js';
// import { getHeaderHeight } from './_get-header-height.js';
// import { mobileCheck } from './_mobile-check.js';

// fixFullheight();
// getHeaderHeight();
// mobileCheck();

/***/ }),

/***/ "./node_modules/choices.js/public/assets/scripts/choices.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/choices.js/public/assets/scripts/choices.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Choices)
/* harmony export */ });
/*! choices.js v11.0.2 | © 2024 Josh Johnson | https://github.com/jshjohnson/Choices#readme */

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */

var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

var ActionType = {
    ADD_CHOICE: 'ADD_CHOICE',
    REMOVE_CHOICE: 'REMOVE_CHOICE',
    FILTER_CHOICES: 'FILTER_CHOICES',
    ACTIVATE_CHOICES: 'ACTIVATE_CHOICES',
    CLEAR_CHOICES: 'CLEAR_CHOICES',
    ADD_GROUP: 'ADD_GROUP',
    ADD_ITEM: 'ADD_ITEM',
    REMOVE_ITEM: 'REMOVE_ITEM',
    HIGHLIGHT_ITEM: 'HIGHLIGHT_ITEM',
};

var EventType = {
    showDropdown: 'showDropdown',
    hideDropdown: 'hideDropdown',
    change: 'change',
    choice: 'choice',
    search: 'search',
    addItem: 'addItem',
    removeItem: 'removeItem',
    highlightItem: 'highlightItem',
    highlightChoice: 'highlightChoice',
    unhighlightItem: 'unhighlightItem',
};

var ObjectsInConfig = ['fuseOptions', 'classNames'];

var PassedElementTypes = {
    Text: 'text',
    SelectOne: 'select-one',
    SelectMultiple: 'select-multiple',
};

var addChoice = function (choice) { return ({
    type: ActionType.ADD_CHOICE,
    choice: choice,
}); };
var removeChoice = function (choice) { return ({
    type: ActionType.REMOVE_CHOICE,
    choice: choice,
}); };
var filterChoices = function (results) { return ({
    type: ActionType.FILTER_CHOICES,
    results: results,
}); };
var activateChoices = function (active) {
    return ({
        type: ActionType.ACTIVATE_CHOICES,
        active: active,
    });
};

var addGroup = function (group) { return ({
    type: ActionType.ADD_GROUP,
    group: group,
}); };

var addItem = function (item) { return ({
    type: ActionType.ADD_ITEM,
    item: item,
}); };
var removeItem$1 = function (item) { return ({
    type: ActionType.REMOVE_ITEM,
    item: item,
}); };
var highlightItem = function (item, highlighted) { return ({
    type: ActionType.HIGHLIGHT_ITEM,
    item: item,
    highlighted: highlighted,
}); };

var getRandomNumber = function (min, max) { return Math.floor(Math.random() * (max - min) + min); };
var generateChars = function (length) {
    return Array.from({ length: length }, function () { return getRandomNumber(0, 36).toString(36); }).join('');
};
var generateId = function (element, prefix) {
    var id = element.id || (element.name && "".concat(element.name, "-").concat(generateChars(2))) || generateChars(4);
    id = id.replace(/(:|\.|\[|\]|,)/g, '');
    id = "".concat(prefix, "-").concat(id);
    return id;
};
var getAdjacentEl = function (startEl, selector, direction) {
    if (direction === void 0) { direction = 1; }
    var prop = "".concat(direction > 0 ? 'next' : 'previous', "ElementSibling");
    var sibling = startEl[prop];
    while (sibling) {
        if (sibling.matches(selector)) {
            return sibling;
        }
        sibling = sibling[prop];
    }
    return null;
};
var isScrolledIntoView = function (element, parent, direction) {
    if (direction === void 0) { direction = 1; }
    var isVisible;
    if (direction > 0) {
        // In view from bottom
        isVisible = parent.scrollTop + parent.offsetHeight >= element.offsetTop + element.offsetHeight;
    }
    else {
        // In view from top
        isVisible = element.offsetTop >= parent.scrollTop;
    }
    return isVisible;
};
var sanitise = function (value) {
    if (typeof value !== 'string') {
        if (value === null || value === undefined) {
            return '';
        }
        if (typeof value === 'object') {
            if ('raw' in value) {
                return sanitise(value.raw);
            }
            if ('trusted' in value) {
                return value.trusted;
            }
        }
        return value;
    }
    return value
        .replace(/&/g, '&amp;')
        .replace(/>/g, '&gt;')
        .replace(/</g, '&lt;')
        .replace(/'/g, '&#039;')
        .replace(/"/g, '&quot;');
};
var strToEl = (function () {
    var tmpEl = document.createElement('div');
    return function (str) {
        tmpEl.innerHTML = str.trim();
        var firstChild = tmpEl.children[0];
        while (tmpEl.firstChild) {
            tmpEl.removeChild(tmpEl.firstChild);
        }
        return firstChild;
    };
})();
var resolveNoticeFunction = function (fn, value) {
    return typeof fn === 'function' ? fn(sanitise(value), value) : fn;
};
var resolveStringFunction = function (fn) {
    return typeof fn === 'function' ? fn() : fn;
};
var unwrapStringForRaw = function (s) {
    if (typeof s === 'string') {
        return s;
    }
    if (typeof s === 'object') {
        if ('trusted' in s) {
            return s.trusted;
        }
        if ('raw' in s) {
            return s.raw;
        }
    }
    return '';
};
var unwrapStringForEscaped = function (s) {
    if (typeof s === 'string') {
        return s;
    }
    if (typeof s === 'object') {
        if ('escaped' in s) {
            return s.escaped;
        }
        if ('trusted' in s) {
            return s.trusted;
        }
    }
    return '';
};
var escapeForTemplate = function (allowHTML, s) {
    return allowHTML ? unwrapStringForEscaped(s) : sanitise(s);
};
var setElementHtml = function (el, allowHtml, html) {
    el.innerHTML = escapeForTemplate(allowHtml, html);
};
var sortByAlpha = function (_a, _b) {
    var value = _a.value, _c = _a.label, label = _c === void 0 ? value : _c;
    var value2 = _b.value, _d = _b.label, label2 = _d === void 0 ? value2 : _d;
    return unwrapStringForRaw(label).localeCompare(unwrapStringForRaw(label2), [], {
        sensitivity: 'base',
        ignorePunctuation: true,
        numeric: true,
    });
};
var sortByRank = function (a, b) {
    return a.rank - b.rank;
};
var dispatchEvent = function (element, type, customArgs) {
    if (customArgs === void 0) { customArgs = null; }
    var event = new CustomEvent(type, {
        detail: customArgs,
        bubbles: true,
        cancelable: true,
    });
    return element.dispatchEvent(event);
};
/**
 * Returns an array of keys present on the first but missing on the second object
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
var diff = function (a, b) {
    var aKeys = Object.keys(a).sort();
    var bKeys = Object.keys(b).sort();
    return aKeys.filter(function (i) { return bKeys.indexOf(i) < 0; });
};
var getClassNames = function (ClassNames) {
    return Array.isArray(ClassNames) ? ClassNames : [ClassNames];
};
var getClassNamesSelector = function (option) {
    if (option && Array.isArray(option)) {
        return option
            .map(function (item) {
            return ".".concat(item);
        })
            .join('');
    }
    return ".".concat(option);
};
var addClassesToElement = function (element, className) {
    var _a;
    (_a = element.classList).add.apply(_a, getClassNames(className));
};
var removeClassesFromElement = function (element, className) {
    var _a;
    (_a = element.classList).remove.apply(_a, getClassNames(className));
};
var parseCustomProperties = function (customProperties) {
    if (typeof customProperties !== 'undefined') {
        try {
            return JSON.parse(customProperties);
        }
        catch (e) {
            return customProperties;
        }
    }
    return {};
};
var updateClassList = function (item, add, remove) {
    var itemEl = item.itemEl;
    if (itemEl) {
        removeClassesFromElement(itemEl, remove);
        addClassesToElement(itemEl, add);
    }
};

var Dropdown = /** @class */ (function () {
    function Dropdown(_a) {
        var element = _a.element, type = _a.type, classNames = _a.classNames;
        this.element = element;
        this.classNames = classNames;
        this.type = type;
        this.isActive = false;
    }
    /**
     * Show dropdown to user by adding active state class
     */
    Dropdown.prototype.show = function () {
        addClassesToElement(this.element, this.classNames.activeState);
        this.element.setAttribute('aria-expanded', 'true');
        this.isActive = true;
        return this;
    };
    /**
     * Hide dropdown from user
     */
    Dropdown.prototype.hide = function () {
        removeClassesFromElement(this.element, this.classNames.activeState);
        this.element.setAttribute('aria-expanded', 'false');
        this.isActive = false;
        return this;
    };
    return Dropdown;
}());

var Container = /** @class */ (function () {
    function Container(_a) {
        var element = _a.element, type = _a.type, classNames = _a.classNames, position = _a.position;
        this.element = element;
        this.classNames = classNames;
        this.type = type;
        this.position = position;
        this.isOpen = false;
        this.isFlipped = false;
        this.isDisabled = false;
        this.isLoading = false;
    }
    /**
     * Determine whether container should be flipped based on passed
     * dropdown position
     */
    Container.prototype.shouldFlip = function (dropdownPos, dropdownHeight) {
        // If flip is enabled and the dropdown bottom position is
        // greater than the window height flip the dropdown.
        var shouldFlip = false;
        if (this.position === 'auto') {
            shouldFlip =
                this.element.getBoundingClientRect().top - dropdownHeight >= 0 &&
                    !window.matchMedia("(min-height: ".concat(dropdownPos + 1, "px)")).matches;
        }
        else if (this.position === 'top') {
            shouldFlip = true;
        }
        return shouldFlip;
    };
    Container.prototype.setActiveDescendant = function (activeDescendantID) {
        this.element.setAttribute('aria-activedescendant', activeDescendantID);
    };
    Container.prototype.removeActiveDescendant = function () {
        this.element.removeAttribute('aria-activedescendant');
    };
    Container.prototype.open = function (dropdownPos, dropdownHeight) {
        addClassesToElement(this.element, this.classNames.openState);
        this.element.setAttribute('aria-expanded', 'true');
        this.isOpen = true;
        if (this.shouldFlip(dropdownPos, dropdownHeight)) {
            addClassesToElement(this.element, this.classNames.flippedState);
            this.isFlipped = true;
        }
    };
    Container.prototype.close = function () {
        removeClassesFromElement(this.element, this.classNames.openState);
        this.element.setAttribute('aria-expanded', 'false');
        this.removeActiveDescendant();
        this.isOpen = false;
        // A dropdown flips if it does not have space within the page
        if (this.isFlipped) {
            removeClassesFromElement(this.element, this.classNames.flippedState);
            this.isFlipped = false;
        }
    };
    Container.prototype.addFocusState = function () {
        addClassesToElement(this.element, this.classNames.focusState);
    };
    Container.prototype.removeFocusState = function () {
        removeClassesFromElement(this.element, this.classNames.focusState);
    };
    Container.prototype.enable = function () {
        removeClassesFromElement(this.element, this.classNames.disabledState);
        this.element.removeAttribute('aria-disabled');
        if (this.type === PassedElementTypes.SelectOne) {
            this.element.setAttribute('tabindex', '0');
        }
        this.isDisabled = false;
    };
    Container.prototype.disable = function () {
        addClassesToElement(this.element, this.classNames.disabledState);
        this.element.setAttribute('aria-disabled', 'true');
        if (this.type === PassedElementTypes.SelectOne) {
            this.element.setAttribute('tabindex', '-1');
        }
        this.isDisabled = true;
    };
    Container.prototype.wrap = function (element) {
        var el = this.element;
        var parentNode = element.parentNode;
        if (parentNode) {
            if (element.nextSibling) {
                parentNode.insertBefore(el, element.nextSibling);
            }
            else {
                parentNode.appendChild(el);
            }
        }
        el.appendChild(element);
    };
    Container.prototype.unwrap = function (element) {
        var el = this.element;
        var parentNode = el.parentNode;
        if (parentNode) {
            // Move passed element outside this element
            parentNode.insertBefore(element, el);
            // Remove this element
            parentNode.removeChild(el);
        }
    };
    Container.prototype.addLoadingState = function () {
        addClassesToElement(this.element, this.classNames.loadingState);
        this.element.setAttribute('aria-busy', 'true');
        this.isLoading = true;
    };
    Container.prototype.removeLoadingState = function () {
        removeClassesFromElement(this.element, this.classNames.loadingState);
        this.element.removeAttribute('aria-busy');
        this.isLoading = false;
    };
    return Container;
}());

var Input = /** @class */ (function () {
    function Input(_a) {
        var element = _a.element, type = _a.type, classNames = _a.classNames, preventPaste = _a.preventPaste;
        this.element = element;
        this.type = type;
        this.classNames = classNames;
        this.preventPaste = preventPaste;
        this.isFocussed = this.element.isEqualNode(document.activeElement);
        this.isDisabled = element.disabled;
        this._onPaste = this._onPaste.bind(this);
        this._onInput = this._onInput.bind(this);
        this._onFocus = this._onFocus.bind(this);
        this._onBlur = this._onBlur.bind(this);
    }
    Object.defineProperty(Input.prototype, "placeholder", {
        set: function (placeholder) {
            this.element.placeholder = placeholder;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Input.prototype, "value", {
        get: function () {
            return this.element.value;
        },
        set: function (value) {
            this.element.value = value;
        },
        enumerable: false,
        configurable: true
    });
    Input.prototype.addEventListeners = function () {
        var el = this.element;
        el.addEventListener('paste', this._onPaste);
        el.addEventListener('input', this._onInput, {
            passive: true,
        });
        el.addEventListener('focus', this._onFocus, {
            passive: true,
        });
        el.addEventListener('blur', this._onBlur, {
            passive: true,
        });
    };
    Input.prototype.removeEventListeners = function () {
        var el = this.element;
        el.removeEventListener('input', this._onInput);
        el.removeEventListener('paste', this._onPaste);
        el.removeEventListener('focus', this._onFocus);
        el.removeEventListener('blur', this._onBlur);
    };
    Input.prototype.enable = function () {
        var el = this.element;
        el.removeAttribute('disabled');
        this.isDisabled = false;
    };
    Input.prototype.disable = function () {
        var el = this.element;
        el.setAttribute('disabled', '');
        this.isDisabled = true;
    };
    Input.prototype.focus = function () {
        if (!this.isFocussed) {
            this.element.focus();
        }
    };
    Input.prototype.blur = function () {
        if (this.isFocussed) {
            this.element.blur();
        }
    };
    Input.prototype.clear = function (setWidth) {
        if (setWidth === void 0) { setWidth = true; }
        this.element.value = '';
        if (setWidth) {
            this.setWidth();
        }
        return this;
    };
    /**
     * Set the correct input width based on placeholder
     * value or input value
     */
    Input.prototype.setWidth = function () {
        // Resize input to contents or placeholder
        var element = this.element;
        element.style.minWidth = "".concat(element.placeholder.length + 1, "ch");
        element.style.width = "".concat(element.value.length + 1, "ch");
    };
    Input.prototype.setActiveDescendant = function (activeDescendantID) {
        this.element.setAttribute('aria-activedescendant', activeDescendantID);
    };
    Input.prototype.removeActiveDescendant = function () {
        this.element.removeAttribute('aria-activedescendant');
    };
    Input.prototype._onInput = function () {
        if (this.type !== PassedElementTypes.SelectOne) {
            this.setWidth();
        }
    };
    Input.prototype._onPaste = function (event) {
        if (this.preventPaste) {
            event.preventDefault();
        }
    };
    Input.prototype._onFocus = function () {
        this.isFocussed = true;
    };
    Input.prototype._onBlur = function () {
        this.isFocussed = false;
    };
    return Input;
}());

var SCROLLING_SPEED = 4;

var List = /** @class */ (function () {
    function List(_a) {
        var element = _a.element;
        this.element = element;
        this.scrollPos = this.element.scrollTop;
        this.height = this.element.offsetHeight;
    }
    List.prototype.prepend = function (node) {
        var child = this.element.firstElementChild;
        if (child) {
            this.element.insertBefore(node, child);
        }
        else {
            this.element.append(node);
        }
    };
    List.prototype.scrollToTop = function () {
        this.element.scrollTop = 0;
    };
    List.prototype.scrollToChildElement = function (element, direction) {
        var _this = this;
        if (!element) {
            return;
        }
        var listHeight = this.element.offsetHeight;
        // Scroll position of dropdown
        var listScrollPosition = this.element.scrollTop + listHeight;
        var elementHeight = element.offsetHeight;
        // Distance from bottom of element to top of parent
        var elementPos = element.offsetTop + elementHeight;
        // Difference between the element and scroll position
        var destination = direction > 0 ? this.element.scrollTop + elementPos - listScrollPosition : element.offsetTop;
        requestAnimationFrame(function () {
            _this._animateScroll(destination, direction);
        });
    };
    List.prototype._scrollDown = function (scrollPos, strength, destination) {
        var easing = (destination - scrollPos) / strength;
        var distance = easing > 1 ? easing : 1;
        this.element.scrollTop = scrollPos + distance;
    };
    List.prototype._scrollUp = function (scrollPos, strength, destination) {
        var easing = (scrollPos - destination) / strength;
        var distance = easing > 1 ? easing : 1;
        this.element.scrollTop = scrollPos - distance;
    };
    List.prototype._animateScroll = function (destination, direction) {
        var _this = this;
        var strength = SCROLLING_SPEED;
        var choiceListScrollTop = this.element.scrollTop;
        var continueAnimation = false;
        if (direction > 0) {
            this._scrollDown(choiceListScrollTop, strength, destination);
            if (choiceListScrollTop < destination) {
                continueAnimation = true;
            }
        }
        else {
            this._scrollUp(choiceListScrollTop, strength, destination);
            if (choiceListScrollTop > destination) {
                continueAnimation = true;
            }
        }
        if (continueAnimation) {
            requestAnimationFrame(function () {
                _this._animateScroll(destination, direction);
            });
        }
    };
    return List;
}());

var WrappedElement = /** @class */ (function () {
    function WrappedElement(_a) {
        var element = _a.element, classNames = _a.classNames;
        this.element = element;
        this.classNames = classNames;
        this.isDisabled = false;
    }
    Object.defineProperty(WrappedElement.prototype, "isActive", {
        get: function () {
            return this.element.dataset.choice === 'active';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WrappedElement.prototype, "dir", {
        get: function () {
            return this.element.dir;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WrappedElement.prototype, "value", {
        get: function () {
            return this.element.value;
        },
        set: function (value) {
            this.element.setAttribute('value', value);
            this.element.value = value;
        },
        enumerable: false,
        configurable: true
    });
    WrappedElement.prototype.conceal = function () {
        var el = this.element;
        // Hide passed input
        addClassesToElement(el, this.classNames.input);
        el.hidden = true;
        // Remove element from tab index
        el.tabIndex = -1;
        // Backup original styles if any
        var origStyle = el.getAttribute('style');
        if (origStyle) {
            el.setAttribute('data-choice-orig-style', origStyle);
        }
        el.setAttribute('data-choice', 'active');
    };
    WrappedElement.prototype.reveal = function () {
        var el = this.element;
        // Reinstate passed element
        removeClassesFromElement(el, this.classNames.input);
        el.hidden = false;
        el.removeAttribute('tabindex');
        // Recover original styles if any
        var origStyle = el.getAttribute('data-choice-orig-style');
        if (origStyle) {
            el.removeAttribute('data-choice-orig-style');
            el.setAttribute('style', origStyle);
        }
        else {
            el.removeAttribute('style');
        }
        el.removeAttribute('data-choice');
    };
    WrappedElement.prototype.enable = function () {
        this.element.removeAttribute('disabled');
        this.element.disabled = false;
        this.isDisabled = false;
    };
    WrappedElement.prototype.disable = function () {
        this.element.setAttribute('disabled', '');
        this.element.disabled = true;
        this.isDisabled = true;
    };
    WrappedElement.prototype.triggerEvent = function (eventType, data) {
        dispatchEvent(this.element, eventType, data || {});
    };
    return WrappedElement;
}());

var WrappedInput = /** @class */ (function (_super) {
    __extends(WrappedInput, _super);
    function WrappedInput() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return WrappedInput;
}(WrappedElement));

var coerceBool = function (arg, defaultValue) {
    if (defaultValue === void 0) { defaultValue = true; }
    return typeof arg === 'undefined' ? defaultValue : !!arg;
};
var stringToHtmlClass = function (input) {
    if (typeof input === 'string') {
        // eslint-disable-next-line no-param-reassign
        input = input.split(' ').filter(function (s) { return s.length; });
    }
    if (Array.isArray(input) && input.length) {
        return input;
    }
    return undefined;
};
var mapInputToChoice = function (value, allowGroup) {
    if (typeof value === 'string') {
        var result_1 = mapInputToChoice({
            value: value,
            label: value,
        }, false);
        return result_1;
    }
    var groupOrChoice = value;
    if ('choices' in groupOrChoice) {
        if (!allowGroup) {
            // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/optgroup
            throw new TypeError("optGroup is not allowed");
        }
        var group = groupOrChoice;
        var choices = group.choices.map(function (e) { return mapInputToChoice(e, false); });
        var result_2 = {
            id: 0, // actual ID will be assigned during _addGroup
            label: unwrapStringForRaw(group.label) || group.value,
            active: !!choices.length,
            disabled: !!group.disabled,
            choices: choices,
        };
        return result_2;
    }
    var choice = groupOrChoice;
    var result = {
        id: 0, // actual ID will be assigned during _addChoice
        group: null, // actual group will be assigned during _addGroup but before _addChoice
        score: 0, // used in search
        rank: 0, // used in search, stable sort order
        value: choice.value,
        label: choice.label || choice.value,
        active: coerceBool(choice.active),
        selected: coerceBool(choice.selected, false),
        disabled: coerceBool(choice.disabled, false),
        placeholder: coerceBool(choice.placeholder, false),
        highlighted: false,
        labelClass: stringToHtmlClass(choice.labelClass),
        labelDescription: choice.labelDescription,
        customProperties: choice.customProperties,
    };
    return result;
};

var isHtmlInputElement = function (e) { return e.tagName === 'INPUT'; };
var isHtmlSelectElement = function (e) { return e.tagName === 'SELECT'; };
var isHtmlOption = function (e) { return e.tagName === 'OPTION'; };
var isHtmlOptgroup = function (e) { return e.tagName === 'OPTGROUP'; };

var WrappedSelect = /** @class */ (function (_super) {
    __extends(WrappedSelect, _super);
    function WrappedSelect(_a) {
        var element = _a.element, classNames = _a.classNames, template = _a.template, extractPlaceholder = _a.extractPlaceholder;
        var _this = _super.call(this, { element: element, classNames: classNames }) || this;
        _this.template = template;
        _this.extractPlaceholder = extractPlaceholder;
        return _this;
    }
    Object.defineProperty(WrappedSelect.prototype, "placeholderOption", {
        get: function () {
            return (this.element.querySelector('option[value=""]') ||
                // Backward compatibility layer for the non-standard placeholder attribute supported in older versions.
                this.element.querySelector('option[placeholder]'));
        },
        enumerable: false,
        configurable: true
    });
    WrappedSelect.prototype.addOptions = function (choices) {
        var _this = this;
        var fragment = document.createDocumentFragment();
        choices.forEach(function (obj) {
            var choice = obj;
            if (choice.element) {
                return;
            }
            var option = _this.template(choice);
            fragment.appendChild(option);
            choice.element = option;
        });
        this.element.appendChild(fragment);
    };
    WrappedSelect.prototype.optionsAsChoices = function () {
        var _this = this;
        var choices = [];
        this.element.querySelectorAll(':scope > option, :scope > optgroup').forEach(function (e) {
            if (isHtmlOption(e)) {
                choices.push(_this._optionToChoice(e));
            }
            else if (isHtmlOptgroup(e)) {
                choices.push(_this._optgroupToChoice(e));
            }
            // todo: hr as empty optgroup, requires displaying empty opt-groups to be useful
        });
        return choices;
    };
    // eslint-disable-next-line class-methods-use-this
    WrappedSelect.prototype._optionToChoice = function (option) {
        // option.value returns the label if there is no value attribute, which can break legacy placeholder attribute support
        if (!option.hasAttribute('value') && option.hasAttribute('placeholder')) {
            option.setAttribute('value', '');
            option.value = '';
        }
        return {
            id: 0,
            group: null,
            score: 0,
            rank: 0,
            value: option.value,
            label: option.innerHTML,
            element: option,
            active: true,
            // this returns true if nothing is selected on initial load, which will break placeholder support
            selected: this.extractPlaceholder ? option.selected : option.hasAttribute('selected'),
            disabled: option.disabled,
            highlighted: false,
            placeholder: this.extractPlaceholder && (!option.value || option.hasAttribute('placeholder')),
            labelClass: typeof option.dataset.labelClass !== 'undefined' ? stringToHtmlClass(option.dataset.labelClass) : undefined,
            labelDescription: typeof option.dataset.labelDescription !== 'undefined' ? option.dataset.labelDescription : undefined,
            customProperties: parseCustomProperties(option.dataset.customProperties),
        };
    };
    WrappedSelect.prototype._optgroupToChoice = function (optgroup) {
        var _this = this;
        var options = optgroup.querySelectorAll('option');
        var choices = Array.from(options).map(function (option) { return _this._optionToChoice(option); });
        return {
            id: 0,
            label: optgroup.label || '',
            element: optgroup,
            active: !!choices.length,
            disabled: optgroup.disabled,
            choices: choices,
        };
    };
    return WrappedSelect;
}(WrappedElement));

var DEFAULT_CLASSNAMES = {
    containerOuter: ['choices'],
    containerInner: ['choices__inner'],
    input: ['choices__input'],
    inputCloned: ['choices__input--cloned'],
    list: ['choices__list'],
    listItems: ['choices__list--multiple'],
    listSingle: ['choices__list--single'],
    listDropdown: ['choices__list--dropdown'],
    item: ['choices__item'],
    itemSelectable: ['choices__item--selectable'],
    itemDisabled: ['choices__item--disabled'],
    itemChoice: ['choices__item--choice'],
    description: ['choices__description'],
    placeholder: ['choices__placeholder'],
    group: ['choices__group'],
    groupHeading: ['choices__heading'],
    button: ['choices__button'],
    activeState: ['is-active'],
    focusState: ['is-focused'],
    openState: ['is-open'],
    disabledState: ['is-disabled'],
    highlightedState: ['is-highlighted'],
    selectedState: ['is-selected'],
    flippedState: ['is-flipped'],
    loadingState: ['is-loading'],
    notice: ['choices__notice'],
    addChoice: ['choices__item--selectable', 'add-choice'],
    noResults: ['has-no-results'],
    noChoices: ['has-no-choices'],
};
var DEFAULT_CONFIG = {
    items: [],
    choices: [],
    silent: false,
    renderChoiceLimit: -1,
    maxItemCount: -1,
    closeDropdownOnSelect: 'auto',
    singleModeForMultiSelect: false,
    addChoices: false,
    addItems: true,
    addItemFilter: function (value) { return !!value && value !== ''; },
    removeItems: true,
    removeItemButton: false,
    removeItemButtonAlignLeft: false,
    editItems: false,
    allowHTML: false,
    allowHtmlUserInput: false,
    duplicateItemsAllowed: true,
    delimiter: ',',
    paste: true,
    searchEnabled: true,
    searchChoices: true,
    searchFloor: 1,
    searchResultLimit: 4,
    searchFields: ['label', 'value'],
    position: 'auto',
    resetScrollPosition: true,
    shouldSort: true,
    shouldSortItems: false,
    sorter: sortByAlpha,
    shadowRoot: null,
    placeholder: true,
    placeholderValue: null,
    searchPlaceholderValue: null,
    prependValue: null,
    appendValue: null,
    renderSelectedChoices: 'auto',
    loadingText: 'Loading...',
    noResultsText: 'No results found',
    noChoicesText: 'No choices to choose from',
    itemSelectText: 'Press to select',
    uniqueItemText: 'Only unique values can be added',
    customAddItemText: 'Only values matching specific conditions can be added',
    addItemText: function (value) { return "Press Enter to add <b>\"".concat(value, "\"</b>"); },
    removeItemIconText: function () { return "Remove item"; },
    removeItemLabelText: function (value) { return "Remove item: ".concat(value); },
    maxItemText: function (maxItemCount) { return "Only ".concat(maxItemCount, " values can be added"); },
    valueComparer: function (value1, value2) { return value1 === value2; },
    fuseOptions: {
        includeScore: true,
    },
    labelId: '',
    callbackOnInit: null,
    callbackOnCreateTemplates: null,
    classNames: DEFAULT_CLASSNAMES,
    appendGroupInSearch: false,
};

var removeItem = function (item) {
    var itemEl = item.itemEl;
    if (itemEl) {
        itemEl.remove();
        item.itemEl = undefined;
    }
};
function items(s, action, context) {
    var state = s;
    var update = true;
    switch (action.type) {
        case ActionType.ADD_ITEM: {
            action.item.selected = true;
            var el = action.item.element;
            if (el) {
                el.selected = true;
                el.setAttribute('selected', '');
            }
            state.push(action.item);
            break;
        }
        case ActionType.REMOVE_ITEM: {
            action.item.selected = false;
            var el = action.item.element;
            if (el) {
                el.selected = false;
                el.removeAttribute('selected');
                // For a select-one, if all options are deselected, the first item is selected. To set a black value, select.value needs to be set
                var select = el.parentElement;
                if (select && isHtmlSelectElement(select) && select.type === PassedElementTypes.SelectOne) {
                    select.value = '';
                }
            }
            // this is mixing concerns, but this is *so much faster*
            removeItem(action.item);
            state = state.filter(function (choice) { return choice.id !== action.item.id; });
            break;
        }
        case ActionType.REMOVE_CHOICE: {
            removeItem(action.choice);
            state = state.filter(function (item) { return item.id !== action.choice.id; });
            break;
        }
        case ActionType.HIGHLIGHT_ITEM: {
            var highlighted = action.highlighted;
            var item = state.find(function (obj) { return obj.id === action.item.id; });
            if (item && item.highlighted !== highlighted) {
                item.highlighted = highlighted;
                if (context) {
                    updateClassList(item, highlighted ? context.classNames.highlightedState : context.classNames.selectedState, highlighted ? context.classNames.selectedState : context.classNames.highlightedState);
                }
            }
            break;
        }
        default: {
            update = false;
            break;
        }
    }
    return { state: state, update: update };
}

function groups(s, action) {
    var state = s;
    var update = true;
    switch (action.type) {
        case ActionType.ADD_GROUP: {
            state.push(action.group);
            break;
        }
        case ActionType.CLEAR_CHOICES: {
            state = [];
            break;
        }
        default: {
            update = false;
            break;
        }
    }
    return { state: state, update: update };
}

/* eslint-disable */
function choices(s, action, context) {
    var state = s;
    var update = true;
    switch (action.type) {
        case ActionType.ADD_CHOICE: {
            state.push(action.choice);
            break;
        }
        case ActionType.REMOVE_CHOICE: {
            action.choice.choiceEl = undefined;
            if (action.choice.group) {
                action.choice.group.choices = action.choice.group.choices.filter(function (obj) { return obj.id !== action.choice.id; });
            }
            state = state.filter(function (obj) { return obj.id !== action.choice.id; });
            break;
        }
        case ActionType.ADD_ITEM:
        case ActionType.REMOVE_ITEM: {
            action.item.choiceEl = undefined;
            break;
        }
        case ActionType.FILTER_CHOICES: {
            // avoid O(n^2) algorithm complexity when searching/filtering choices
            var scoreLookup_1 = [];
            action.results.forEach(function (result) {
                scoreLookup_1[result.item.id] = result;
            });
            state.forEach(function (choice) {
                var result = scoreLookup_1[choice.id];
                if (result !== undefined) {
                    choice.score = result.score;
                    choice.rank = result.rank;
                    choice.active = true;
                }
                else {
                    choice.score = 0;
                    choice.rank = 0;
                    choice.active = false;
                }
                if (context && context.appendGroupInSearch) {
                    choice.choiceEl = undefined;
                }
            });
            break;
        }
        case ActionType.ACTIVATE_CHOICES: {
            state.forEach(function (choice) {
                choice.active = action.active;
                if (context && context.appendGroupInSearch) {
                    choice.choiceEl = undefined;
                }
            });
            break;
        }
        case ActionType.CLEAR_CHOICES: {
            state = [];
            break;
        }
        default: {
            update = false;
            break;
        }
    }
    return { state: state, update: update };
}

var reducers = {
    groups: groups,
    items: items,
    choices: choices,
};
var Store = /** @class */ (function () {
    function Store(context) {
        this._state = this.defaultState;
        this._listeners = [];
        this._txn = 0;
        this._context = context;
    }
    Object.defineProperty(Store.prototype, "defaultState", {
        // eslint-disable-next-line class-methods-use-this
        get: function () {
            return {
                groups: [],
                items: [],
                choices: [],
            };
        },
        enumerable: false,
        configurable: true
    });
    // eslint-disable-next-line class-methods-use-this
    Store.prototype.changeSet = function (init) {
        return {
            groups: init,
            items: init,
            choices: init,
        };
    };
    Store.prototype.reset = function () {
        this._state = this.defaultState;
        var changes = this.changeSet(true);
        if (this._txn) {
            this._changeSet = changes;
        }
        else {
            this._listeners.forEach(function (l) { return l(changes); });
        }
    };
    Store.prototype.subscribe = function (onChange) {
        this._listeners.push(onChange);
        return this;
    };
    Store.prototype.dispatch = function (action) {
        var _this = this;
        var state = this._state;
        var hasChanges = false;
        var changes = this._changeSet || this.changeSet(false);
        Object.keys(reducers).forEach(function (key) {
            var stateUpdate = reducers[key](state[key], action, _this._context);
            if (stateUpdate.update) {
                hasChanges = true;
                changes[key] = true;
                state[key] = stateUpdate.state;
            }
        });
        if (hasChanges) {
            if (this._txn) {
                this._changeSet = changes;
            }
            else {
                this._listeners.forEach(function (l) { return l(changes); });
            }
        }
    };
    Store.prototype.withTxn = function (func) {
        this._txn++;
        try {
            func();
        }
        finally {
            this._txn = Math.max(0, this._txn - 1);
            if (!this._txn) {
                var changeSet_1 = this._changeSet;
                if (changeSet_1) {
                    this._changeSet = undefined;
                    this._listeners.forEach(function (l) { return l(changeSet_1); });
                }
            }
        }
    };
    Object.defineProperty(Store.prototype, "state", {
        /**
         * Get store object
         */
        get: function () {
            return this._state;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Store.prototype, "items", {
        /**
         * Get items from store
         */
        get: function () {
            return this.state.items;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Store.prototype, "highlightedActiveItems", {
        /**
         * Get highlighted items from store
         */
        get: function () {
            return this.items.filter(function (item) { return !item.disabled && item.active && item.highlighted; });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Store.prototype, "choices", {
        /**
         * Get choices from store
         */
        get: function () {
            return this.state.choices;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Store.prototype, "activeChoices", {
        /**
         * Get active choices from store
         */
        get: function () {
            return this.choices.filter(function (choice) { return choice.active; });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Store.prototype, "searchableChoices", {
        /**
         * Get choices that can be searched (excluding placeholders)
         */
        get: function () {
            return this.choices.filter(function (choice) { return !choice.disabled && !choice.placeholder; });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Store.prototype, "groups", {
        /**
         * Get groups from store
         */
        get: function () {
            return this.state.groups;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Store.prototype, "activeGroups", {
        /**
         * Get active groups from store
         */
        get: function () {
            var _this = this;
            return this.state.groups.filter(function (group) {
                var isActive = group.active && !group.disabled;
                var hasActiveOptions = _this.state.choices.some(function (choice) { return choice.active && !choice.disabled; });
                return isActive && hasActiveOptions;
            }, []);
        },
        enumerable: false,
        configurable: true
    });
    Store.prototype.inTxn = function () {
        return this._txn > 0;
    };
    /**
     * Get single choice by it's ID
     */
    Store.prototype.getChoiceById = function (id) {
        return this.activeChoices.find(function (choice) { return choice.id === id; });
    };
    /**
     * Get group by group id
     */
    Store.prototype.getGroupById = function (id) {
        return this.groups.find(function (group) { return group.id === id; });
    };
    return Store;
}());

var NoticeTypes = {
    noChoices: 'no-choices',
    noResults: 'no-results',
    addChoice: 'add-choice',
    generic: '',
};

function _defineProperty(e, r, t) {
  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[r] = t, e;
}
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      _defineProperty(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : i + "";
}

/**
 * Fuse.js v7.0.0 - Lightweight fuzzy-search (http://fusejs.io)
 *
 * Copyright (c) 2023 Kiro Risk (http://kiro.me)
 * All Rights Reserved. Apache Software License 2.0
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */

function isArray(value) {
  return !Array.isArray ? getTag(value) === '[object Array]' : Array.isArray(value);
}

// Adapted from: https://github.com/lodash/lodash/blob/master/.internal/baseToString.js
const INFINITY = 1 / 0;
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  let result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}
function toString(value) {
  return value == null ? '' : baseToString(value);
}
function isString(value) {
  return typeof value === 'string';
}
function isNumber(value) {
  return typeof value === 'number';
}

// Adapted from: https://github.com/lodash/lodash/blob/master/isBoolean.js
function isBoolean(value) {
  return value === true || value === false || isObjectLike(value) && getTag(value) == '[object Boolean]';
}
function isObject(value) {
  return typeof value === 'object';
}

// Checks if `value` is object-like.
function isObjectLike(value) {
  return isObject(value) && value !== null;
}
function isDefined(value) {
  return value !== undefined && value !== null;
}
function isBlank(value) {
  return !value.trim().length;
}

// Gets the `toStringTag` of `value`.
// Adapted from: https://github.com/lodash/lodash/blob/master/.internal/getTag.js
function getTag(value) {
  return value == null ? value === undefined ? '[object Undefined]' : '[object Null]' : Object.prototype.toString.call(value);
}
const EXTENDED_SEARCH_UNAVAILABLE = 'Extended search is not available';
const INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
const LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = key => `Invalid value for key ${key}`;
const PATTERN_LENGTH_TOO_LARGE = max => `Pattern length exceeds max of ${max}.`;
const MISSING_KEY_PROPERTY = name => `Missing ${name} property in key`;
const INVALID_KEY_WEIGHT_VALUE = key => `Property 'weight' in key '${key}' must be a positive integer`;
const hasOwn = Object.prototype.hasOwnProperty;
class KeyStore {
  constructor(keys) {
    this._keys = [];
    this._keyMap = {};
    let totalWeight = 0;
    keys.forEach(key => {
      let obj = createKey(key);
      this._keys.push(obj);
      this._keyMap[obj.id] = obj;
      totalWeight += obj.weight;
    });

    // Normalize weights so that their sum is equal to 1
    this._keys.forEach(key => {
      key.weight /= totalWeight;
    });
  }
  get(keyId) {
    return this._keyMap[keyId];
  }
  keys() {
    return this._keys;
  }
  toJSON() {
    return JSON.stringify(this._keys);
  }
}
function createKey(key) {
  let path = null;
  let id = null;
  let src = null;
  let weight = 1;
  let getFn = null;
  if (isString(key) || isArray(key)) {
    src = key;
    path = createKeyPath(key);
    id = createKeyId(key);
  } else {
    if (!hasOwn.call(key, 'name')) {
      throw new Error(MISSING_KEY_PROPERTY('name'));
    }
    const name = key.name;
    src = name;
    if (hasOwn.call(key, 'weight')) {
      weight = key.weight;
      if (weight <= 0) {
        throw new Error(INVALID_KEY_WEIGHT_VALUE(name));
      }
    }
    path = createKeyPath(name);
    id = createKeyId(name);
    getFn = key.getFn;
  }
  return {
    path,
    id,
    weight,
    src,
    getFn
  };
}
function createKeyPath(key) {
  return isArray(key) ? key : key.split('.');
}
function createKeyId(key) {
  return isArray(key) ? key.join('.') : key;
}
function get(obj, path) {
  let list = [];
  let arr = false;
  const deepGet = (obj, path, index) => {
    if (!isDefined(obj)) {
      return;
    }
    if (!path[index]) {
      // If there's no path left, we've arrived at the object we care about.
      list.push(obj);
    } else {
      let key = path[index];
      const value = obj[key];
      if (!isDefined(value)) {
        return;
      }

      // If we're at the last value in the path, and if it's a string/number/bool,
      // add it to the list
      if (index === path.length - 1 && (isString(value) || isNumber(value) || isBoolean(value))) {
        list.push(toString(value));
      } else if (isArray(value)) {
        arr = true;
        // Search each item in the array.
        for (let i = 0, len = value.length; i < len; i += 1) {
          deepGet(value[i], path, index + 1);
        }
      } else if (path.length) {
        // An object. Recurse further.
        deepGet(value, path, index + 1);
      }
    }
  };

  // Backwards compatibility (since path used to be a string)
  deepGet(obj, isString(path) ? path.split('.') : path, 0);
  return arr ? list : list[0];
}
const MatchOptions = {
  // Whether the matches should be included in the result set. When `true`, each record in the result
  // set will include the indices of the matched characters.
  // These can consequently be used for highlighting purposes.
  includeMatches: false,
  // When `true`, the matching function will continue to the end of a search pattern even if
  // a perfect match has already been located in the string.
  findAllMatches: false,
  // Minimum number of characters that must be matched before a result is considered a match
  minMatchCharLength: 1
};
const BasicOptions = {
  // When `true`, the algorithm continues searching to the end of the input even if a perfect
  // match is found before the end of the same input.
  isCaseSensitive: false,
  // When true, the matching function will continue to the end of a search pattern even if
  includeScore: false,
  // List of properties that will be searched. This also supports nested properties.
  keys: [],
  // Whether to sort the result list, by score
  shouldSort: true,
  // Default sort function: sort by ascending score, ascending index
  sortFn: (a, b) => a.score === b.score ? a.idx < b.idx ? -1 : 1 : a.score < b.score ? -1 : 1
};
const FuzzyOptions = {
  // Approximately where in the text is the pattern expected to be found?
  location: 0,
  // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
  // (of both letters and location), a threshold of '1.0' would match anything.
  threshold: 0.6,
  // Determines how close the match must be to the fuzzy location (specified above).
  // An exact letter match which is 'distance' characters away from the fuzzy location
  // would score as a complete mismatch. A distance of '0' requires the match be at
  // the exact location specified, a threshold of '1000' would require a perfect match
  // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
  distance: 100
};
const AdvancedOptions = {
  // When `true`, it enables the use of unix-like search commands
  useExtendedSearch: false,
  // The get function to use when fetching an object's properties.
  // The default will search nested paths *ie foo.bar.baz*
  getFn: get,
  // When `true`, search will ignore `location` and `distance`, so it won't matter
  // where in the string the pattern appears.
  // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score
  ignoreLocation: false,
  // When `true`, the calculation for the relevance score (used for sorting) will
  // ignore the field-length norm.
  // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm
  ignoreFieldNorm: false,
  // The weight to determine how much field length norm effects scoring.
  fieldNormWeight: 1
};
var Config = _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, BasicOptions), MatchOptions), FuzzyOptions), AdvancedOptions);
const SPACE = /[^ ]+/g;

// Field-length norm: the shorter the field, the higher the weight.
// Set to 3 decimals to reduce index size.
function norm(weight = 1, mantissa = 3) {
  const cache = new Map();
  const m = Math.pow(10, mantissa);
  return {
    get(value) {
      const numTokens = value.match(SPACE).length;
      if (cache.has(numTokens)) {
        return cache.get(numTokens);
      }

      // Default function is 1/sqrt(x), weight makes that variable
      const norm = 1 / Math.pow(numTokens, 0.5 * weight);

      // In place of `toFixed(mantissa)`, for faster computation
      const n = parseFloat(Math.round(norm * m) / m);
      cache.set(numTokens, n);
      return n;
    },
    clear() {
      cache.clear();
    }
  };
}
class FuseIndex {
  constructor({
    getFn = Config.getFn,
    fieldNormWeight = Config.fieldNormWeight
  } = {}) {
    this.norm = norm(fieldNormWeight, 3);
    this.getFn = getFn;
    this.isCreated = false;
    this.setIndexRecords();
  }
  setSources(docs = []) {
    this.docs = docs;
  }
  setIndexRecords(records = []) {
    this.records = records;
  }
  setKeys(keys = []) {
    this.keys = keys;
    this._keysMap = {};
    keys.forEach((key, idx) => {
      this._keysMap[key.id] = idx;
    });
  }
  create() {
    if (this.isCreated || !this.docs.length) {
      return;
    }
    this.isCreated = true;

    // List is Array<String>
    if (isString(this.docs[0])) {
      this.docs.forEach((doc, docIndex) => {
        this._addString(doc, docIndex);
      });
    } else {
      // List is Array<Object>
      this.docs.forEach((doc, docIndex) => {
        this._addObject(doc, docIndex);
      });
    }
    this.norm.clear();
  }
  // Adds a doc to the end of the index
  add(doc) {
    const idx = this.size();
    if (isString(doc)) {
      this._addString(doc, idx);
    } else {
      this._addObject(doc, idx);
    }
  }
  // Removes the doc at the specified index of the index
  removeAt(idx) {
    this.records.splice(idx, 1);

    // Change ref index of every subsquent doc
    for (let i = idx, len = this.size(); i < len; i += 1) {
      this.records[i].i -= 1;
    }
  }
  getValueForItemAtKeyId(item, keyId) {
    return item[this._keysMap[keyId]];
  }
  size() {
    return this.records.length;
  }
  _addString(doc, docIndex) {
    if (!isDefined(doc) || isBlank(doc)) {
      return;
    }
    let record = {
      v: doc,
      i: docIndex,
      n: this.norm.get(doc)
    };
    this.records.push(record);
  }
  _addObject(doc, docIndex) {
    let record = {
      i: docIndex,
      $: {}
    };

    // Iterate over every key (i.e, path), and fetch the value at that key
    this.keys.forEach((key, keyIndex) => {
      let value = key.getFn ? key.getFn(doc) : this.getFn(doc, key.path);
      if (!isDefined(value)) {
        return;
      }
      if (isArray(value)) {
        let subRecords = [];
        const stack = [{
          nestedArrIndex: -1,
          value
        }];
        while (stack.length) {
          const {
            nestedArrIndex,
            value
          } = stack.pop();
          if (!isDefined(value)) {
            continue;
          }
          if (isString(value) && !isBlank(value)) {
            let subRecord = {
              v: value,
              i: nestedArrIndex,
              n: this.norm.get(value)
            };
            subRecords.push(subRecord);
          } else if (isArray(value)) {
            value.forEach((item, k) => {
              stack.push({
                nestedArrIndex: k,
                value: item
              });
            });
          } else ;
        }
        record.$[keyIndex] = subRecords;
      } else if (isString(value) && !isBlank(value)) {
        let subRecord = {
          v: value,
          n: this.norm.get(value)
        };
        record.$[keyIndex] = subRecord;
      }
    });
    this.records.push(record);
  }
  toJSON() {
    return {
      keys: this.keys,
      records: this.records
    };
  }
}
function createIndex(keys, docs, {
  getFn = Config.getFn,
  fieldNormWeight = Config.fieldNormWeight
} = {}) {
  const myIndex = new FuseIndex({
    getFn,
    fieldNormWeight
  });
  myIndex.setKeys(keys.map(createKey));
  myIndex.setSources(docs);
  myIndex.create();
  return myIndex;
}
function parseIndex(data, {
  getFn = Config.getFn,
  fieldNormWeight = Config.fieldNormWeight
} = {}) {
  const {
    keys,
    records
  } = data;
  const myIndex = new FuseIndex({
    getFn,
    fieldNormWeight
  });
  myIndex.setKeys(keys);
  myIndex.setIndexRecords(records);
  return myIndex;
}
function computeScore$1(pattern, {
  errors = 0,
  currentLocation = 0,
  expectedLocation = 0,
  distance = Config.distance,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  const accuracy = errors / pattern.length;
  if (ignoreLocation) {
    return accuracy;
  }
  const proximity = Math.abs(expectedLocation - currentLocation);
  if (!distance) {
    // Dodge divide by zero error.
    return proximity ? 1.0 : accuracy;
  }
  return accuracy + proximity / distance;
}
function convertMaskToIndices(matchmask = [], minMatchCharLength = Config.minMatchCharLength) {
  let indices = [];
  let start = -1;
  let end = -1;
  let i = 0;
  for (let len = matchmask.length; i < len; i += 1) {
    let match = matchmask[i];
    if (match && start === -1) {
      start = i;
    } else if (!match && start !== -1) {
      end = i - 1;
      if (end - start + 1 >= minMatchCharLength) {
        indices.push([start, end]);
      }
      start = -1;
    }
  }

  // (i-1 - start) + 1 => i - start
  if (matchmask[i - 1] && i - start >= minMatchCharLength) {
    indices.push([start, i - 1]);
  }
  return indices;
}

// Machine word size
const MAX_BITS = 32;
function search(text, pattern, patternAlphabet, {
  location = Config.location,
  distance = Config.distance,
  threshold = Config.threshold,
  findAllMatches = Config.findAllMatches,
  minMatchCharLength = Config.minMatchCharLength,
  includeMatches = Config.includeMatches,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  if (pattern.length > MAX_BITS) {
    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
  }
  const patternLen = pattern.length;
  // Set starting location at beginning text and initialize the alphabet.
  const textLen = text.length;
  // Handle the case when location > text.length
  const expectedLocation = Math.max(0, Math.min(location, textLen));
  // Highest score beyond which we give up.
  let currentThreshold = threshold;
  // Is there a nearby exact match? (speedup)
  let bestLocation = expectedLocation;

  // Performance: only computer matches when the minMatchCharLength > 1
  // OR if `includeMatches` is true.
  const computeMatches = minMatchCharLength > 1 || includeMatches;
  // A mask of the matches, used for building the indices
  const matchMask = computeMatches ? Array(textLen) : [];
  let index;

  // Get all exact matches, here for speed up
  while ((index = text.indexOf(pattern, bestLocation)) > -1) {
    let score = computeScore$1(pattern, {
      currentLocation: index,
      expectedLocation,
      distance,
      ignoreLocation
    });
    currentThreshold = Math.min(score, currentThreshold);
    bestLocation = index + patternLen;
    if (computeMatches) {
      let i = 0;
      while (i < patternLen) {
        matchMask[index + i] = 1;
        i += 1;
      }
    }
  }

  // Reset the best location
  bestLocation = -1;
  let lastBitArr = [];
  let finalScore = 1;
  let binMax = patternLen + textLen;
  const mask = 1 << patternLen - 1;
  for (let i = 0; i < patternLen; i += 1) {
    // Scan for the best match; each iteration allows for one more error.
    // Run a binary search to determine how far from the match location we can stray
    // at this error level.
    let binMin = 0;
    let binMid = binMax;
    while (binMin < binMid) {
      const score = computeScore$1(pattern, {
        errors: i,
        currentLocation: expectedLocation + binMid,
        expectedLocation,
        distance,
        ignoreLocation
      });
      if (score <= currentThreshold) {
        binMin = binMid;
      } else {
        binMax = binMid;
      }
      binMid = Math.floor((binMax - binMin) / 2 + binMin);
    }

    // Use the result from this iteration as the maximum for the next.
    binMax = binMid;
    let start = Math.max(1, expectedLocation - binMid + 1);
    let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;

    // Initialize the bit array
    let bitArr = Array(finish + 2);
    bitArr[finish + 1] = (1 << i) - 1;
    for (let j = finish; j >= start; j -= 1) {
      let currentLocation = j - 1;
      let charMatch = patternAlphabet[text.charAt(currentLocation)];
      if (computeMatches) {
        // Speed up: quick bool to int conversion (i.e, `charMatch ? 1 : 0`)
        matchMask[currentLocation] = +!!charMatch;
      }

      // First pass: exact match
      bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;

      // Subsequent passes: fuzzy match
      if (i) {
        bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];
      }
      if (bitArr[j] & mask) {
        finalScore = computeScore$1(pattern, {
          errors: i,
          currentLocation,
          expectedLocation,
          distance,
          ignoreLocation
        });

        // This match will almost certainly be better than any existing match.
        // But check anyway.
        if (finalScore <= currentThreshold) {
          // Indeed it is
          currentThreshold = finalScore;
          bestLocation = currentLocation;

          // Already passed `loc`, downhill from here on in.
          if (bestLocation <= expectedLocation) {
            break;
          }

          // When passing `bestLocation`, don't exceed our current distance from `expectedLocation`.
          start = Math.max(1, 2 * expectedLocation - bestLocation);
        }
      }
    }

    // No hope for a (better) match at greater error levels.
    const score = computeScore$1(pattern, {
      errors: i + 1,
      currentLocation: expectedLocation,
      expectedLocation,
      distance,
      ignoreLocation
    });
    if (score > currentThreshold) {
      break;
    }
    lastBitArr = bitArr;
  }
  const result = {
    isMatch: bestLocation >= 0,
    // Count exact matches (those with a score of 0) to be "almost" exact
    score: Math.max(0.001, finalScore)
  };
  if (computeMatches) {
    const indices = convertMaskToIndices(matchMask, minMatchCharLength);
    if (!indices.length) {
      result.isMatch = false;
    } else if (includeMatches) {
      result.indices = indices;
    }
  }
  return result;
}
function createPatternAlphabet(pattern) {
  let mask = {};
  for (let i = 0, len = pattern.length; i < len; i += 1) {
    const char = pattern.charAt(i);
    mask[char] = (mask[char] || 0) | 1 << len - i - 1;
  }
  return mask;
}
class BitapSearch {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    this.options = {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.chunks = [];
    if (!this.pattern.length) {
      return;
    }
    const addChunk = (pattern, startIndex) => {
      this.chunks.push({
        pattern,
        alphabet: createPatternAlphabet(pattern),
        startIndex
      });
    };
    const len = this.pattern.length;
    if (len > MAX_BITS) {
      let i = 0;
      const remainder = len % MAX_BITS;
      const end = len - remainder;
      while (i < end) {
        addChunk(this.pattern.substr(i, MAX_BITS), i);
        i += MAX_BITS;
      }
      if (remainder) {
        const startIndex = len - MAX_BITS;
        addChunk(this.pattern.substr(startIndex), startIndex);
      }
    } else {
      addChunk(this.pattern, 0);
    }
  }
  searchIn(text) {
    const {
      isCaseSensitive,
      includeMatches
    } = this.options;
    if (!isCaseSensitive) {
      text = text.toLowerCase();
    }

    // Exact match
    if (this.pattern === text) {
      let result = {
        isMatch: true,
        score: 0
      };
      if (includeMatches) {
        result.indices = [[0, text.length - 1]];
      }
      return result;
    }

    // Otherwise, use Bitap algorithm
    const {
      location,
      distance,
      threshold,
      findAllMatches,
      minMatchCharLength,
      ignoreLocation
    } = this.options;
    let allIndices = [];
    let totalScore = 0;
    let hasMatches = false;
    this.chunks.forEach(({
      pattern,
      alphabet,
      startIndex
    }) => {
      const {
        isMatch,
        score,
        indices
      } = search(text, pattern, alphabet, {
        location: location + startIndex,
        distance,
        threshold,
        findAllMatches,
        minMatchCharLength,
        includeMatches,
        ignoreLocation
      });
      if (isMatch) {
        hasMatches = true;
      }
      totalScore += score;
      if (isMatch && indices) {
        allIndices = [...allIndices, ...indices];
      }
    });
    let result = {
      isMatch: hasMatches,
      score: hasMatches ? totalScore / this.chunks.length : 1
    };
    if (hasMatches && includeMatches) {
      result.indices = allIndices;
    }
    return result;
  }
}
class BaseMatch {
  constructor(pattern) {
    this.pattern = pattern;
  }
  static isMultiMatch(pattern) {
    return getMatch(pattern, this.multiRegex);
  }
  static isSingleMatch(pattern) {
    return getMatch(pattern, this.singleRegex);
  }
  search( /*text*/) {}
}
function getMatch(pattern, exp) {
  const matches = pattern.match(exp);
  return matches ? matches[1] : null;
}

// Token: 'file

class ExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return 'exact';
  }
  static get multiRegex() {
    return /^="(.*)"$/;
  }
  static get singleRegex() {
    return /^=(.*)$/;
  }
  search(text) {
    const isMatch = text === this.pattern;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
}

// Token: !fire

class InverseExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return 'inverse-exact';
  }
  static get multiRegex() {
    return /^!"(.*)"$/;
  }
  static get singleRegex() {
    return /^!(.*)$/;
  }
  search(text) {
    const index = text.indexOf(this.pattern);
    const isMatch = index === -1;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
}

// Token: ^file

class PrefixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return 'prefix-exact';
  }
  static get multiRegex() {
    return /^\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^\^(.*)$/;
  }
  search(text) {
    const isMatch = text.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
}

// Token: !^fire

class InversePrefixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return 'inverse-prefix-exact';
  }
  static get multiRegex() {
    return /^!\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^!\^(.*)$/;
  }
  search(text) {
    const isMatch = !text.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
}

// Token: .file$

class SuffixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return 'suffix-exact';
  }
  static get multiRegex() {
    return /^"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^(.*)\$$/;
  }
  search(text) {
    const isMatch = text.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [text.length - this.pattern.length, text.length - 1]
    };
  }
}

// Token: !.file$

class InverseSuffixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return 'inverse-suffix-exact';
  }
  static get multiRegex() {
    return /^!"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^!(.*)\$$/;
  }
  search(text) {
    const isMatch = !text.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
}
class FuzzyMatch extends BaseMatch {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    super(pattern);
    this._bitapSearch = new BitapSearch(pattern, {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    });
  }
  static get type() {
    return 'fuzzy';
  }
  static get multiRegex() {
    return /^"(.*)"$/;
  }
  static get singleRegex() {
    return /^(.*)$/;
  }
  search(text) {
    return this._bitapSearch.searchIn(text);
  }
}

// Token: 'file

class IncludeMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return 'include';
  }
  static get multiRegex() {
    return /^'"(.*)"$/;
  }
  static get singleRegex() {
    return /^'(.*)$/;
  }
  search(text) {
    let location = 0;
    let index;
    const indices = [];
    const patternLen = this.pattern.length;

    // Get all exact matches
    while ((index = text.indexOf(this.pattern, location)) > -1) {
      location = index + patternLen;
      indices.push([index, location - 1]);
    }
    const isMatch = !!indices.length;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices
    };
  }
}

// ❗Order is important. DO NOT CHANGE.
const searchers = [ExactMatch, IncludeMatch, PrefixExactMatch, InversePrefixExactMatch, InverseSuffixExactMatch, SuffixExactMatch, InverseExactMatch, FuzzyMatch];
const searchersLen = searchers.length;

// Regex to split by spaces, but keep anything in quotes together
const SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
const OR_TOKEN = '|';

// Return a 2D array representation of the query, for simpler parsing.
// Example:
// "^core go$ | rb$ | py$ xy$" => [["^core", "go$"], ["rb$"], ["py$", "xy$"]]
function parseQuery(pattern, options = {}) {
  return pattern.split(OR_TOKEN).map(item => {
    let query = item.trim().split(SPACE_RE).filter(item => item && !!item.trim());
    let results = [];
    for (let i = 0, len = query.length; i < len; i += 1) {
      const queryItem = query[i];

      // 1. Handle multiple query match (i.e, once that are quoted, like `"hello world"`)
      let found = false;
      let idx = -1;
      while (!found && ++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isMultiMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          found = true;
        }
      }
      if (found) {
        continue;
      }

      // 2. Handle single query matches (i.e, once that are *not* quoted)
      idx = -1;
      while (++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isSingleMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          break;
        }
      }
    }
    return results;
  });
}

// These extended matchers can return an array of matches, as opposed
// to a singl match
const MultiMatchSet = new Set([FuzzyMatch.type, IncludeMatch.type]);

/**
 * Command-like searching
 * ======================
 *
 * Given multiple search terms delimited by spaces.e.g. `^jscript .python$ ruby !java`,
 * search in a given text.
 *
 * Search syntax:
 *
 * | Token       | Match type                 | Description                            |
 * | ----------- | -------------------------- | -------------------------------------- |
 * | `jscript`   | fuzzy-match                | Items that fuzzy match `jscript`       |
 * | `=scheme`   | exact-match                | Items that are `scheme`                |
 * | `'python`   | include-match              | Items that include `python`            |
 * | `!ruby`     | inverse-exact-match        | Items that do not include `ruby`       |
 * | `^java`     | prefix-exact-match         | Items that start with `java`           |
 * | `!^earlang` | inverse-prefix-exact-match | Items that do not start with `earlang` |
 * | `.js$`      | suffix-exact-match         | Items that end with `.js`              |
 * | `!.go$`     | inverse-suffix-exact-match | Items that do not end with `.go`       |
 *
 * A single pipe character acts as an OR operator. For example, the following
 * query matches entries that start with `core` and end with either`go`, `rb`,
 * or`py`.
 *
 * ```
 * ^core go$ | rb$ | py$
 * ```
 */
class ExtendedSearch {
  constructor(pattern, {
    isCaseSensitive = Config.isCaseSensitive,
    includeMatches = Config.includeMatches,
    minMatchCharLength = Config.minMatchCharLength,
    ignoreLocation = Config.ignoreLocation,
    findAllMatches = Config.findAllMatches,
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance
  } = {}) {
    this.query = null;
    this.options = {
      isCaseSensitive,
      includeMatches,
      minMatchCharLength,
      findAllMatches,
      ignoreLocation,
      location,
      threshold,
      distance
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.query = parseQuery(this.pattern, this.options);
  }
  static condition(_, options) {
    return options.useExtendedSearch;
  }
  searchIn(text) {
    const query = this.query;
    if (!query) {
      return {
        isMatch: false,
        score: 1
      };
    }
    const {
      includeMatches,
      isCaseSensitive
    } = this.options;
    text = isCaseSensitive ? text : text.toLowerCase();
    let numMatches = 0;
    let allIndices = [];
    let totalScore = 0;

    // ORs
    for (let i = 0, qLen = query.length; i < qLen; i += 1) {
      const searchers = query[i];

      // Reset indices
      allIndices.length = 0;
      numMatches = 0;

      // ANDs
      for (let j = 0, pLen = searchers.length; j < pLen; j += 1) {
        const searcher = searchers[j];
        const {
          isMatch,
          indices,
          score
        } = searcher.search(text);
        if (isMatch) {
          numMatches += 1;
          totalScore += score;
          if (includeMatches) {
            const type = searcher.constructor.type;
            if (MultiMatchSet.has(type)) {
              allIndices = [...allIndices, ...indices];
            } else {
              allIndices.push(indices);
            }
          }
        } else {
          totalScore = 0;
          numMatches = 0;
          allIndices.length = 0;
          break;
        }
      }

      // OR condition, so if TRUE, return
      if (numMatches) {
        let result = {
          isMatch: true,
          score: totalScore / numMatches
        };
        if (includeMatches) {
          result.indices = allIndices;
        }
        return result;
      }
    }

    // Nothing was matched
    return {
      isMatch: false,
      score: 1
    };
  }
}
const registeredSearchers = [];
function register(...args) {
  registeredSearchers.push(...args);
}
function createSearcher(pattern, options) {
  for (let i = 0, len = registeredSearchers.length; i < len; i += 1) {
    let searcherClass = registeredSearchers[i];
    if (searcherClass.condition(pattern, options)) {
      return new searcherClass(pattern, options);
    }
  }
  return new BitapSearch(pattern, options);
}
const LogicalOperator = {
  AND: '$and',
  OR: '$or'
};
const KeyType = {
  PATH: '$path',
  PATTERN: '$val'
};
const isExpression = query => !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);
const isPath = query => !!query[KeyType.PATH];
const isLeaf = query => !isArray(query) && isObject(query) && !isExpression(query);
const convertToExplicit = query => ({
  [LogicalOperator.AND]: Object.keys(query).map(key => ({
    [key]: query[key]
  }))
});

// When `auto` is `true`, the parse function will infer and initialize and add
// the appropriate `Searcher` instance
function parse(query, options, {
  auto = true
} = {}) {
  const next = query => {
    let keys = Object.keys(query);
    const isQueryPath = isPath(query);
    if (!isQueryPath && keys.length > 1 && !isExpression(query)) {
      return next(convertToExplicit(query));
    }
    if (isLeaf(query)) {
      const key = isQueryPath ? query[KeyType.PATH] : keys[0];
      const pattern = isQueryPath ? query[KeyType.PATTERN] : query[key];
      if (!isString(pattern)) {
        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));
      }
      const obj = {
        keyId: createKeyId(key),
        pattern
      };
      if (auto) {
        obj.searcher = createSearcher(pattern, options);
      }
      return obj;
    }
    let node = {
      children: [],
      operator: keys[0]
    };
    keys.forEach(key => {
      const value = query[key];
      if (isArray(value)) {
        value.forEach(item => {
          node.children.push(next(item));
        });
      }
    });
    return node;
  };
  if (!isExpression(query)) {
    query = convertToExplicit(query);
  }
  return next(query);
}

// Practical scoring function
function computeScore(results, {
  ignoreFieldNorm = Config.ignoreFieldNorm
}) {
  results.forEach(result => {
    let totalScore = 1;
    result.matches.forEach(({
      key,
      norm,
      score
    }) => {
      const weight = key ? key.weight : null;
      totalScore *= Math.pow(score === 0 && weight ? Number.EPSILON : score, (weight || 1) * (ignoreFieldNorm ? 1 : norm));
    });
    result.score = totalScore;
  });
}
function transformMatches(result, data) {
  const matches = result.matches;
  data.matches = [];
  if (!isDefined(matches)) {
    return;
  }
  matches.forEach(match => {
    if (!isDefined(match.indices) || !match.indices.length) {
      return;
    }
    const {
      indices,
      value
    } = match;
    let obj = {
      indices,
      value
    };
    if (match.key) {
      obj.key = match.key.src;
    }
    if (match.idx > -1) {
      obj.refIndex = match.idx;
    }
    data.matches.push(obj);
  });
}
function transformScore(result, data) {
  data.score = result.score;
}
function format(results, docs, {
  includeMatches = Config.includeMatches,
  includeScore = Config.includeScore
} = {}) {
  const transformers = [];
  if (includeMatches) transformers.push(transformMatches);
  if (includeScore) transformers.push(transformScore);
  return results.map(result => {
    const {
      idx
    } = result;
    const data = {
      item: docs[idx],
      refIndex: idx
    };
    if (transformers.length) {
      transformers.forEach(transformer => {
        transformer(result, data);
      });
    }
    return data;
  });
}
class Fuse {
  constructor(docs, options = {}, index) {
    this.options = _objectSpread2(_objectSpread2({}, Config), options);
    if (this.options.useExtendedSearch && !true) {}
    this._keyStore = new KeyStore(this.options.keys);
    this.setCollection(docs, index);
  }
  setCollection(docs, index) {
    this._docs = docs;
    if (index && !(index instanceof FuseIndex)) {
      throw new Error(INCORRECT_INDEX_TYPE);
    }
    this._myIndex = index || createIndex(this.options.keys, this._docs, {
      getFn: this.options.getFn,
      fieldNormWeight: this.options.fieldNormWeight
    });
  }
  add(doc) {
    if (!isDefined(doc)) {
      return;
    }
    this._docs.push(doc);
    this._myIndex.add(doc);
  }
  remove(predicate = ( /* doc, idx */) => false) {
    const results = [];
    for (let i = 0, len = this._docs.length; i < len; i += 1) {
      const doc = this._docs[i];
      if (predicate(doc, i)) {
        this.removeAt(i);
        i -= 1;
        len -= 1;
        results.push(doc);
      }
    }
    return results;
  }
  removeAt(idx) {
    this._docs.splice(idx, 1);
    this._myIndex.removeAt(idx);
  }
  getIndex() {
    return this._myIndex;
  }
  search(query, {
    limit = -1
  } = {}) {
    const {
      includeMatches,
      includeScore,
      shouldSort,
      sortFn,
      ignoreFieldNorm
    } = this.options;
    let results = isString(query) ? isString(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);
    computeScore(results, {
      ignoreFieldNorm
    });
    if (shouldSort) {
      results.sort(sortFn);
    }
    if (isNumber(limit) && limit > -1) {
      results = results.slice(0, limit);
    }
    return format(results, this._docs, {
      includeMatches,
      includeScore
    });
  }
  _searchStringList(query) {
    const searcher = createSearcher(query, this.options);
    const {
      records
    } = this._myIndex;
    const results = [];

    // Iterate over every string in the index
    records.forEach(({
      v: text,
      i: idx,
      n: norm
    }) => {
      if (!isDefined(text)) {
        return;
      }
      const {
        isMatch,
        score,
        indices
      } = searcher.searchIn(text);
      if (isMatch) {
        results.push({
          item: text,
          idx,
          matches: [{
            score,
            value: text,
            norm,
            indices
          }]
        });
      }
    });
    return results;
  }
  _searchLogical(query) {
    const expression = parse(query, this.options);
    const evaluate = (node, item, idx) => {
      if (!node.children) {
        const {
          keyId,
          searcher
        } = node;
        const matches = this._findMatches({
          key: this._keyStore.get(keyId),
          value: this._myIndex.getValueForItemAtKeyId(item, keyId),
          searcher
        });
        if (matches && matches.length) {
          return [{
            idx,
            item,
            matches
          }];
        }
        return [];
      }
      const res = [];
      for (let i = 0, len = node.children.length; i < len; i += 1) {
        const child = node.children[i];
        const result = evaluate(child, item, idx);
        if (result.length) {
          res.push(...result);
        } else if (node.operator === LogicalOperator.AND) {
          return [];
        }
      }
      return res;
    };
    const records = this._myIndex.records;
    const resultMap = {};
    const results = [];
    records.forEach(({
      $: item,
      i: idx
    }) => {
      if (isDefined(item)) {
        let expResults = evaluate(expression, item, idx);
        if (expResults.length) {
          // Dedupe when adding
          if (!resultMap[idx]) {
            resultMap[idx] = {
              idx,
              item,
              matches: []
            };
            results.push(resultMap[idx]);
          }
          expResults.forEach(({
            matches
          }) => {
            resultMap[idx].matches.push(...matches);
          });
        }
      }
    });
    return results;
  }
  _searchObjectList(query) {
    const searcher = createSearcher(query, this.options);
    const {
      keys,
      records
    } = this._myIndex;
    const results = [];

    // List is Array<Object>
    records.forEach(({
      $: item,
      i: idx
    }) => {
      if (!isDefined(item)) {
        return;
      }
      let matches = [];

      // Iterate over every key (i.e, path), and fetch the value at that key
      keys.forEach((key, keyIndex) => {
        matches.push(...this._findMatches({
          key,
          value: item[keyIndex],
          searcher
        }));
      });
      if (matches.length) {
        results.push({
          idx,
          item,
          matches
        });
      }
    });
    return results;
  }
  _findMatches({
    key,
    value,
    searcher
  }) {
    if (!isDefined(value)) {
      return [];
    }
    let matches = [];
    if (isArray(value)) {
      value.forEach(({
        v: text,
        i: idx,
        n: norm
      }) => {
        if (!isDefined(text)) {
          return;
        }
        const {
          isMatch,
          score,
          indices
        } = searcher.searchIn(text);
        if (isMatch) {
          matches.push({
            score,
            key,
            value: text,
            idx,
            norm,
            indices
          });
        }
      });
    } else {
      const {
        v: text,
        n: norm
      } = value;
      const {
        isMatch,
        score,
        indices
      } = searcher.searchIn(text);
      if (isMatch) {
        matches.push({
          score,
          key,
          value: text,
          norm,
          indices
        });
      }
    }
    return matches;
  }
}
Fuse.version = '7.0.0';
Fuse.createIndex = createIndex;
Fuse.parseIndex = parseIndex;
Fuse.config = Config;
{
  Fuse.parseQuery = parse;
}
{
  register(ExtendedSearch);
}

var SearchByFuse = /** @class */ (function () {
    function SearchByFuse(config) {
        this._haystack = [];
        this._fuseOptions = __assign(__assign({}, config.fuseOptions), { keys: __spreadArray([], config.searchFields, true), includeMatches: true });
    }
    SearchByFuse.prototype.index = function (data) {
        this._haystack = data;
        if (this._fuse) {
            this._fuse.setCollection(data);
        }
    };
    SearchByFuse.prototype.reset = function () {
        this._haystack = [];
        this._fuse = undefined;
    };
    SearchByFuse.prototype.isEmptyIndex = function () {
        return !this._haystack.length;
    };
    SearchByFuse.prototype.search = function (needle) {
        if (!this._fuse) {
            {
                this._fuse = new Fuse(this._haystack, this._fuseOptions);
            }
        }
        var results = this._fuse.search(needle);
        return results.map(function (value, i) {
            return {
                item: value.item,
                score: value.score || 0,
                rank: i + 1, // If value.score is used for sorting, this can create non-stable sorts!
            };
        });
    };
    return SearchByFuse;
}());

function getSearcher(config) {
    {
        return new SearchByFuse(config);
    }
}

/**
 * Helpers to create HTML elements used by Choices
 * Can be overridden by providing `callbackOnCreateTemplates` option.
 * `Choices.defaults.templates` allows access to the default template methods from `callbackOnCreateTemplates`
 */
var isEmptyObject = function (obj) {
    // eslint-disable-next-line no-restricted-syntax
    for (var prop in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, prop)) {
            return false;
        }
    }
    return true;
};
var assignCustomProperties = function (el, choice, withCustomProperties) {
    var dataset = el.dataset;
    var customProperties = choice.customProperties, labelClass = choice.labelClass, labelDescription = choice.labelDescription;
    if (labelClass) {
        dataset.labelClass = getClassNames(labelClass).join(' ');
    }
    if (labelDescription) {
        dataset.labelDescription = labelDescription;
    }
    if (withCustomProperties && customProperties) {
        if (typeof customProperties === 'string') {
            dataset.customProperties = customProperties;
        }
        else if (typeof customProperties === 'object' && !isEmptyObject(customProperties)) {
            dataset.customProperties = JSON.stringify(customProperties);
        }
    }
};
var addAriaLabel = function (docRoot, id, element) {
    var label = id && docRoot.querySelector("label[for='".concat(id, "']"));
    var text = label && label.innerText;
    if (text) {
        element.setAttribute('aria-label', text);
    }
};
var templates = {
    containerOuter: function (_a, dir, isSelectElement, isSelectOneElement, searchEnabled, passedElementType, labelId) {
        var containerOuter = _a.classNames.containerOuter;
        var div = document.createElement('div');
        addClassesToElement(div, containerOuter);
        div.dataset.type = passedElementType;
        if (dir) {
            div.dir = dir;
        }
        if (isSelectOneElement) {
            div.tabIndex = 0;
        }
        if (isSelectElement) {
            div.setAttribute('role', searchEnabled ? 'combobox' : 'listbox');
            if (searchEnabled) {
                div.setAttribute('aria-autocomplete', 'list');
            }
            else if (!labelId) {
                addAriaLabel(this._docRoot, this.passedElement.element.id, div);
            }
            div.setAttribute('aria-haspopup', 'true');
            div.setAttribute('aria-expanded', 'false');
        }
        if (labelId) {
            div.setAttribute('aria-labelledby', labelId);
        }
        return div;
    },
    containerInner: function (_a) {
        var containerInner = _a.classNames.containerInner;
        var div = document.createElement('div');
        addClassesToElement(div, containerInner);
        return div;
    },
    itemList: function (_a, isSelectOneElement) {
        var searchEnabled = _a.searchEnabled, _b = _a.classNames, list = _b.list, listSingle = _b.listSingle, listItems = _b.listItems;
        var div = document.createElement('div');
        addClassesToElement(div, list);
        addClassesToElement(div, isSelectOneElement ? listSingle : listItems);
        if (this._isSelectElement && searchEnabled) {
            div.setAttribute('role', 'listbox');
        }
        return div;
    },
    placeholder: function (_a, value) {
        var allowHTML = _a.allowHTML, placeholder = _a.classNames.placeholder;
        var div = document.createElement('div');
        addClassesToElement(div, placeholder);
        setElementHtml(div, allowHTML, value);
        return div;
    },
    item: function (_a, choice, removeItemButton) {
        var allowHTML = _a.allowHTML, removeItemButtonAlignLeft = _a.removeItemButtonAlignLeft, removeItemIconText = _a.removeItemIconText, removeItemLabelText = _a.removeItemLabelText, _b = _a.classNames, item = _b.item, button = _b.button, highlightedState = _b.highlightedState, itemSelectable = _b.itemSelectable, placeholder = _b.placeholder;
        var rawValue = unwrapStringForRaw(choice.value);
        var div = document.createElement('div');
        addClassesToElement(div, item);
        if (choice.labelClass) {
            var spanLabel = document.createElement('span');
            setElementHtml(spanLabel, allowHTML, choice.label);
            addClassesToElement(spanLabel, choice.labelClass);
            div.appendChild(spanLabel);
        }
        else {
            setElementHtml(div, allowHTML, choice.label);
        }
        div.dataset.item = '';
        div.dataset.id = choice.id;
        div.dataset.value = rawValue;
        assignCustomProperties(div, choice, true);
        if (choice.disabled || this.containerOuter.isDisabled) {
            div.setAttribute('aria-disabled', 'true');
        }
        if (this._isSelectElement) {
            div.setAttribute('aria-selected', 'true');
            div.setAttribute('role', 'option');
        }
        if (choice.placeholder) {
            addClassesToElement(div, placeholder);
            div.dataset.placeholder = '';
        }
        addClassesToElement(div, choice.highlighted ? highlightedState : itemSelectable);
        if (removeItemButton) {
            if (choice.disabled) {
                removeClassesFromElement(div, itemSelectable);
            }
            div.dataset.deletable = '';
            var removeButton = document.createElement('button');
            removeButton.type = 'button';
            addClassesToElement(removeButton, button);
            setElementHtml(removeButton, true, resolveNoticeFunction(removeItemIconText, choice.value));
            var REMOVE_ITEM_LABEL = resolveNoticeFunction(removeItemLabelText, choice.value);
            if (REMOVE_ITEM_LABEL) {
                removeButton.setAttribute('aria-label', REMOVE_ITEM_LABEL);
            }
            removeButton.dataset.button = '';
            if (removeItemButtonAlignLeft) {
                div.insertAdjacentElement('afterbegin', removeButton);
            }
            else {
                div.appendChild(removeButton);
            }
        }
        return div;
    },
    choiceList: function (_a, isSelectOneElement) {
        var list = _a.classNames.list;
        var div = document.createElement('div');
        addClassesToElement(div, list);
        if (!isSelectOneElement) {
            div.setAttribute('aria-multiselectable', 'true');
        }
        div.setAttribute('role', 'listbox');
        return div;
    },
    choiceGroup: function (_a, _b) {
        var allowHTML = _a.allowHTML, _c = _a.classNames, group = _c.group, groupHeading = _c.groupHeading, itemDisabled = _c.itemDisabled;
        var id = _b.id, label = _b.label, disabled = _b.disabled;
        var rawLabel = unwrapStringForRaw(label);
        var div = document.createElement('div');
        addClassesToElement(div, group);
        if (disabled) {
            addClassesToElement(div, itemDisabled);
        }
        div.setAttribute('role', 'group');
        div.dataset.group = '';
        div.dataset.id = id;
        div.dataset.value = rawLabel;
        if (disabled) {
            div.setAttribute('aria-disabled', 'true');
        }
        var heading = document.createElement('div');
        addClassesToElement(heading, groupHeading);
        setElementHtml(heading, allowHTML, label || '');
        div.appendChild(heading);
        return div;
    },
    choice: function (_a, choice, selectText, groupName) {
        var allowHTML = _a.allowHTML, _b = _a.classNames, item = _b.item, itemChoice = _b.itemChoice, itemSelectable = _b.itemSelectable, selectedState = _b.selectedState, itemDisabled = _b.itemDisabled, description = _b.description, placeholder = _b.placeholder;
        // eslint-disable-next-line prefer-destructuring
        var label = choice.label;
        var rawValue = unwrapStringForRaw(choice.value);
        var div = document.createElement('div');
        div.id = choice.elementId;
        addClassesToElement(div, item);
        addClassesToElement(div, itemChoice);
        if (groupName && typeof label === 'string') {
            label = escapeForTemplate(allowHTML, label);
            label += " (".concat(groupName, ")");
            label = { trusted: label };
        }
        var describedBy = div;
        if (choice.labelClass) {
            var spanLabel = document.createElement('span');
            setElementHtml(spanLabel, allowHTML, label);
            addClassesToElement(spanLabel, choice.labelClass);
            describedBy = spanLabel;
            div.appendChild(spanLabel);
        }
        else {
            setElementHtml(div, allowHTML, label);
        }
        if (choice.labelDescription) {
            var descId = "".concat(choice.elementId, "-description");
            describedBy.setAttribute('aria-describedby', descId);
            var spanDesc = document.createElement('span');
            setElementHtml(spanDesc, allowHTML, choice.labelDescription);
            spanDesc.id = descId;
            addClassesToElement(spanDesc, description);
            div.appendChild(spanDesc);
        }
        if (choice.selected) {
            addClassesToElement(div, selectedState);
        }
        if (choice.placeholder) {
            addClassesToElement(div, placeholder);
        }
        div.setAttribute('role', choice.group ? 'treeitem' : 'option');
        div.dataset.choice = '';
        div.dataset.id = choice.id;
        div.dataset.value = rawValue;
        if (selectText) {
            div.dataset.selectText = selectText;
        }
        if (choice.group) {
            div.dataset.groupId = "".concat(choice.group.id);
        }
        assignCustomProperties(div, choice, false);
        if (choice.disabled) {
            addClassesToElement(div, itemDisabled);
            div.dataset.choiceDisabled = '';
            div.setAttribute('aria-disabled', 'true');
        }
        else {
            addClassesToElement(div, itemSelectable);
            div.dataset.choiceSelectable = '';
        }
        return div;
    },
    input: function (_a, placeholderValue) {
        var _b = _a.classNames, input = _b.input, inputCloned = _b.inputCloned, labelId = _a.labelId;
        var inp = document.createElement('input');
        inp.type = 'search';
        addClassesToElement(inp, input);
        addClassesToElement(inp, inputCloned);
        inp.autocomplete = 'off';
        inp.autocapitalize = 'off';
        inp.spellcheck = false;
        inp.setAttribute('role', 'textbox');
        inp.setAttribute('aria-autocomplete', 'list');
        if (placeholderValue) {
            inp.setAttribute('aria-label', placeholderValue);
        }
        else if (!labelId) {
            addAriaLabel(this._docRoot, this.passedElement.element.id, inp);
        }
        return inp;
    },
    dropdown: function (_a) {
        var _b = _a.classNames, list = _b.list, listDropdown = _b.listDropdown;
        var div = document.createElement('div');
        addClassesToElement(div, list);
        addClassesToElement(div, listDropdown);
        div.setAttribute('aria-expanded', 'false');
        return div;
    },
    notice: function (_a, innerHTML, type) {
        var _b = _a.classNames, item = _b.item, itemChoice = _b.itemChoice, addChoice = _b.addChoice, noResults = _b.noResults, noChoices = _b.noChoices, noticeItem = _b.notice;
        if (type === void 0) { type = NoticeTypes.generic; }
        var notice = document.createElement('div');
        setElementHtml(notice, true, innerHTML);
        addClassesToElement(notice, item);
        addClassesToElement(notice, itemChoice);
        addClassesToElement(notice, noticeItem);
        // eslint-disable-next-line default-case
        switch (type) {
            case NoticeTypes.addChoice:
                addClassesToElement(notice, addChoice);
                break;
            case NoticeTypes.noResults:
                addClassesToElement(notice, noResults);
                break;
            case NoticeTypes.noChoices:
                addClassesToElement(notice, noChoices);
                break;
        }
        if (type === NoticeTypes.addChoice) {
            notice.dataset.choiceSelectable = '';
            notice.dataset.choice = '';
        }
        return notice;
    },
    option: function (choice) {
        // HtmlOptionElement's label value does not support HTML, so the avoid double escaping unwrap the untrusted string.
        var labelValue = unwrapStringForRaw(choice.label);
        var opt = new Option(labelValue, choice.value, false, choice.selected);
        assignCustomProperties(opt, choice, true);
        opt.disabled = choice.disabled;
        if (choice.selected) {
            opt.setAttribute('selected', '');
        }
        return opt;
    },
};

/** @see {@link http://browserhacks.com/#hack-acea075d0ac6954f275a70023906050c} */
var IS_IE11 = '-ms-scroll-limit' in document.documentElement.style &&
    '-ms-ime-align' in document.documentElement.style;
var USER_DEFAULTS = {};
var parseDataSetId = function (element) {
    if (!element) {
        return undefined;
    }
    return element.dataset.id ? parseInt(element.dataset.id, 10) : undefined;
};
var selectableChoiceIdentifier = '[data-choice-selectable]';
/**
 * Choices
 * @author Josh Johnson<josh@joshuajohnson.co.uk>
 */
var Choices = /** @class */ (function () {
    function Choices(element, userConfig) {
        if (element === void 0) { element = '[data-choice]'; }
        if (userConfig === void 0) { userConfig = {}; }
        var _this = this;
        this.initialisedOK = undefined;
        this._hasNonChoicePlaceholder = false;
        this._lastAddedChoiceId = 0;
        this._lastAddedGroupId = 0;
        var defaults = Choices.defaults;
        this.config = __assign(__assign(__assign({}, defaults.allOptions), defaults.options), userConfig);
        ObjectsInConfig.forEach(function (key) {
            _this.config[key] = __assign(__assign(__assign({}, defaults.allOptions[key]), defaults.options[key]), userConfig[key]);
        });
        var config = this.config;
        if (!config.silent) {
            this._validateConfig();
        }
        var docRoot = config.shadowRoot || document.documentElement;
        this._docRoot = docRoot;
        var passedElement = typeof element === 'string' ? docRoot.querySelector(element) : element;
        if (!passedElement ||
            typeof passedElement !== 'object' ||
            !(isHtmlInputElement(passedElement) || isHtmlSelectElement(passedElement))) {
            if (!passedElement && typeof element === 'string') {
                throw TypeError("Selector ".concat(element, " failed to find an element"));
            }
            throw TypeError("Expected one of the following types text|select-one|select-multiple");
        }
        var elementType = passedElement.type;
        var isText = elementType === PassedElementTypes.Text;
        if (isText || config.maxItemCount !== 1) {
            config.singleModeForMultiSelect = false;
        }
        if (config.singleModeForMultiSelect) {
            elementType = PassedElementTypes.SelectMultiple;
        }
        var isSelectOne = elementType === PassedElementTypes.SelectOne;
        var isSelectMultiple = elementType === PassedElementTypes.SelectMultiple;
        var isSelect = isSelectOne || isSelectMultiple;
        this._elementType = elementType;
        this._isTextElement = isText;
        this._isSelectOneElement = isSelectOne;
        this._isSelectMultipleElement = isSelectMultiple;
        this._isSelectElement = isSelectOne || isSelectMultiple;
        this._canAddUserChoices = (isText && config.addItems) || (isSelect && config.addChoices);
        if (typeof config.renderSelectedChoices !== 'boolean') {
            config.renderSelectedChoices = config.renderSelectedChoices === 'always' || isSelectOne;
        }
        if (config.closeDropdownOnSelect === 'auto') {
            config.closeDropdownOnSelect = isText || isSelectOne || config.singleModeForMultiSelect;
        }
        else {
            config.closeDropdownOnSelect = coerceBool(config.closeDropdownOnSelect);
        }
        if (config.placeholder) {
            if (config.placeholderValue) {
                this._hasNonChoicePlaceholder = true;
            }
            else if (passedElement.dataset.placeholder) {
                this._hasNonChoicePlaceholder = true;
                config.placeholderValue = passedElement.dataset.placeholder;
            }
        }
        if (userConfig.addItemFilter && typeof userConfig.addItemFilter !== 'function') {
            var re = userConfig.addItemFilter instanceof RegExp ? userConfig.addItemFilter : new RegExp(userConfig.addItemFilter);
            config.addItemFilter = re.test.bind(re);
        }
        if (this._isTextElement) {
            this.passedElement = new WrappedInput({
                element: passedElement,
                classNames: config.classNames,
            });
        }
        else {
            var selectEl = passedElement;
            this.passedElement = new WrappedSelect({
                element: selectEl,
                classNames: config.classNames,
                template: function (data) { return _this._templates.option(data); },
                extractPlaceholder: config.placeholder && !this._hasNonChoicePlaceholder,
            });
        }
        this.initialised = false;
        this._store = new Store(config);
        this._currentValue = '';
        config.searchEnabled = (!isText && config.searchEnabled) || isSelectMultiple;
        this._canSearch = config.searchEnabled;
        this._isScrollingOnIe = false;
        this._highlightPosition = 0;
        this._wasTap = true;
        this._placeholderValue = this._generatePlaceholderValue();
        this._baseId = generateId(passedElement, 'choices-');
        /**
         * setting direction in cases where it's explicitly set on passedElement
         * or when calculated direction is different from the document
         */
        this._direction = passedElement.dir;
        if (!this._direction) {
            var elementDirection = window.getComputedStyle(passedElement).direction;
            var documentDirection = window.getComputedStyle(document.documentElement).direction;
            if (elementDirection !== documentDirection) {
                this._direction = elementDirection;
            }
        }
        this._idNames = {
            itemChoice: 'item-choice',
        };
        this._templates = defaults.templates;
        this._render = this._render.bind(this);
        this._onFocus = this._onFocus.bind(this);
        this._onBlur = this._onBlur.bind(this);
        this._onKeyUp = this._onKeyUp.bind(this);
        this._onKeyDown = this._onKeyDown.bind(this);
        this._onInput = this._onInput.bind(this);
        this._onClick = this._onClick.bind(this);
        this._onTouchMove = this._onTouchMove.bind(this);
        this._onTouchEnd = this._onTouchEnd.bind(this);
        this._onMouseDown = this._onMouseDown.bind(this);
        this._onMouseOver = this._onMouseOver.bind(this);
        this._onFormReset = this._onFormReset.bind(this);
        this._onSelectKey = this._onSelectKey.bind(this);
        this._onEnterKey = this._onEnterKey.bind(this);
        this._onEscapeKey = this._onEscapeKey.bind(this);
        this._onDirectionKey = this._onDirectionKey.bind(this);
        this._onDeleteKey = this._onDeleteKey.bind(this);
        // If element has already been initialised with Choices, fail silently
        if (this.passedElement.isActive) {
            if (!config.silent) {
                console.warn('Trying to initialise Choices on element already initialised', { element: element });
            }
            this.initialised = true;
            this.initialisedOK = false;
            return;
        }
        // Let's go
        this.init();
        // preserve the selected item list after setup for form reset
        this._initialItems = this._store.items.map(function (choice) { return choice.value; });
    }
    Object.defineProperty(Choices, "defaults", {
        get: function () {
            return Object.preventExtensions({
                get options() {
                    return USER_DEFAULTS;
                },
                get allOptions() {
                    return DEFAULT_CONFIG;
                },
                get templates() {
                    return templates;
                },
            });
        },
        enumerable: false,
        configurable: true
    });
    Choices.prototype.init = function () {
        if (this.initialised || this.initialisedOK !== undefined) {
            return;
        }
        this._searcher = getSearcher(this.config);
        this._loadChoices();
        this._createTemplates();
        this._createElements();
        this._createStructure();
        if ((this._isTextElement && !this.config.addItems) ||
            this.passedElement.element.hasAttribute('disabled') ||
            !!this.passedElement.element.closest('fieldset:disabled')) {
            this.disable();
        }
        else {
            this.enable();
            this._addEventListeners();
        }
        // should be triggered **after** disabled state to avoid additional re-draws
        this._initStore();
        this.initialised = true;
        this.initialisedOK = true;
        var callbackOnInit = this.config.callbackOnInit;
        // Run callback if it is a function
        if (typeof callbackOnInit === 'function') {
            callbackOnInit.call(this);
        }
    };
    Choices.prototype.destroy = function () {
        if (!this.initialised) {
            return;
        }
        this._removeEventListeners();
        this.passedElement.reveal();
        this.containerOuter.unwrap(this.passedElement.element);
        this._store._listeners = []; // prevents select/input value being wiped
        this.clearStore(false);
        this._stopSearch();
        this._templates = Choices.defaults.templates;
        this.initialised = false;
        this.initialisedOK = undefined;
    };
    Choices.prototype.enable = function () {
        if (this.passedElement.isDisabled) {
            this.passedElement.enable();
        }
        if (this.containerOuter.isDisabled) {
            this._addEventListeners();
            this.input.enable();
            this.containerOuter.enable();
        }
        return this;
    };
    Choices.prototype.disable = function () {
        if (!this.passedElement.isDisabled) {
            this.passedElement.disable();
        }
        if (!this.containerOuter.isDisabled) {
            this._removeEventListeners();
            this.input.disable();
            this.containerOuter.disable();
        }
        return this;
    };
    Choices.prototype.highlightItem = function (item, runEvent) {
        if (runEvent === void 0) { runEvent = true; }
        if (!item || !item.id) {
            return this;
        }
        var choice = this._store.items.find(function (c) { return c.id === item.id; });
        if (!choice || choice.highlighted) {
            return this;
        }
        this._store.dispatch(highlightItem(choice, true));
        if (runEvent) {
            this.passedElement.triggerEvent(EventType.highlightItem, this._getChoiceForOutput(choice));
        }
        return this;
    };
    Choices.prototype.unhighlightItem = function (item, runEvent) {
        if (runEvent === void 0) { runEvent = true; }
        if (!item || !item.id) {
            return this;
        }
        var choice = this._store.items.find(function (c) { return c.id === item.id; });
        if (!choice || !choice.highlighted) {
            return this;
        }
        this._store.dispatch(highlightItem(choice, false));
        if (runEvent) {
            this.passedElement.triggerEvent(EventType.unhighlightItem, this._getChoiceForOutput(choice));
        }
        return this;
    };
    Choices.prototype.highlightAll = function () {
        var _this = this;
        this._store.withTxn(function () {
            _this._store.items.forEach(function (item) {
                if (!item.highlighted) {
                    _this._store.dispatch(highlightItem(item, true));
                    _this.passedElement.triggerEvent(EventType.highlightItem, _this._getChoiceForOutput(item));
                }
            });
        });
        return this;
    };
    Choices.prototype.unhighlightAll = function () {
        var _this = this;
        this._store.withTxn(function () {
            _this._store.items.forEach(function (item) {
                if (item.highlighted) {
                    _this._store.dispatch(highlightItem(item, false));
                    _this.passedElement.triggerEvent(EventType.highlightItem, _this._getChoiceForOutput(item));
                }
            });
        });
        return this;
    };
    Choices.prototype.removeActiveItemsByValue = function (value) {
        var _this = this;
        this._store.withTxn(function () {
            _this._store.items.filter(function (item) { return item.value === value; }).forEach(function (item) { return _this._removeItem(item); });
        });
        return this;
    };
    Choices.prototype.removeActiveItems = function (excludedId) {
        var _this = this;
        this._store.withTxn(function () {
            _this._store.items.filter(function (_a) {
                var id = _a.id;
                return id !== excludedId;
            }).forEach(function (item) { return _this._removeItem(item); });
        });
        return this;
    };
    Choices.prototype.removeHighlightedItems = function (runEvent) {
        var _this = this;
        if (runEvent === void 0) { runEvent = false; }
        this._store.withTxn(function () {
            _this._store.highlightedActiveItems.forEach(function (item) {
                _this._removeItem(item);
                // If this action was performed by the user
                // trigger the event
                if (runEvent) {
                    _this._triggerChange(item.value);
                }
            });
        });
        return this;
    };
    Choices.prototype.showDropdown = function (preventInputFocus) {
        var _this = this;
        if (this.dropdown.isActive) {
            return this;
        }
        requestAnimationFrame(function () {
            _this.dropdown.show();
            var rect = _this.dropdown.element.getBoundingClientRect();
            _this.containerOuter.open(rect.bottom, rect.height);
            if (!preventInputFocus && _this._canSearch) {
                _this.input.focus();
            }
            _this.passedElement.triggerEvent(EventType.showDropdown);
        });
        return this;
    };
    Choices.prototype.hideDropdown = function (preventInputBlur) {
        var _this = this;
        if (!this.dropdown.isActive) {
            return this;
        }
        requestAnimationFrame(function () {
            _this.dropdown.hide();
            _this.containerOuter.close();
            if (!preventInputBlur && _this._canSearch) {
                _this.input.removeActiveDescendant();
                _this.input.blur();
            }
            _this.passedElement.triggerEvent(EventType.hideDropdown);
        });
        return this;
    };
    Choices.prototype.getValue = function (valueOnly) {
        var _this = this;
        var values = this._store.items.map(function (item) {
            return (valueOnly ? item.value : _this._getChoiceForOutput(item));
        });
        return this._isSelectOneElement || this.config.singleModeForMultiSelect ? values[0] : values;
    };
    Choices.prototype.setValue = function (items) {
        var _this = this;
        if (!this.initialisedOK) {
            this._warnChoicesInitFailed('setValue');
            return this;
        }
        this._store.withTxn(function () {
            items.forEach(function (value) {
                if (value) {
                    _this._addChoice(mapInputToChoice(value, false));
                }
            });
        });
        // @todo integrate with Store
        this._searcher.reset();
        return this;
    };
    Choices.prototype.setChoiceByValue = function (value) {
        var _this = this;
        if (!this.initialisedOK) {
            this._warnChoicesInitFailed('setChoiceByValue');
            return this;
        }
        if (this._isTextElement) {
            return this;
        }
        this._store.withTxn(function () {
            // If only one value has been passed, convert to array
            var choiceValue = Array.isArray(value) ? value : [value];
            // Loop through each value and
            choiceValue.forEach(function (val) { return _this._findAndSelectChoiceByValue(val); });
            _this.unhighlightAll();
        });
        // @todo integrate with Store
        this._searcher.reset();
        return this;
    };
    /**
     * Set choices of select input via an array of objects (or function that returns array of object or promise of it),
     * a value field name and a label field name.
     * This behaves the same as passing items via the choices option but can be called after initialising Choices.
     * This can also be used to add groups of choices (see example 2); Optionally pass a true `replaceChoices` value to remove any existing choices.
     * Optionally pass a `customProperties` object to add additional data to your choices (useful when searching/filtering etc).
     *
     * **Input types affected:** select-one, select-multiple
     *
     * @example
     * ```js
     * const example = new Choices(element);
     *
     * example.setChoices([
     *   {value: 'One', label: 'Label One', disabled: true},
     *   {value: 'Two', label: 'Label Two', selected: true},
     *   {value: 'Three', label: 'Label Three'},
     * ], 'value', 'label', false);
     * ```
     *
     * @example
     * ```js
     * const example = new Choices(element);
     *
     * example.setChoices(async () => {
     *   try {
     *      const items = await fetch('/items');
     *      return items.json()
     *   } catch(err) {
     *      console.error(err)
     *   }
     * });
     * ```
     *
     * @example
     * ```js
     * const example = new Choices(element);
     *
     * example.setChoices([{
     *   label: 'Group one',
     *   id: 1,
     *   disabled: false,
     *   choices: [
     *     {value: 'Child One', label: 'Child One', selected: true},
     *     {value: 'Child Two', label: 'Child Two',  disabled: true},
     *     {value: 'Child Three', label: 'Child Three'},
     *   ]
     * },
     * {
     *   label: 'Group two',
     *   id: 2,
     *   disabled: false,
     *   choices: [
     *     {value: 'Child Four', label: 'Child Four', disabled: true},
     *     {value: 'Child Five', label: 'Child Five'},
     *     {value: 'Child Six', label: 'Child Six', customProperties: {
     *       description: 'Custom description about child six',
     *       random: 'Another random custom property'
     *     }},
     *   ]
     * }], 'value', 'label', false);
     * ```
     */
    Choices.prototype.setChoices = function (choicesArrayOrFetcher, value, label, replaceChoices, clearSearchFlag) {
        var _this = this;
        if (choicesArrayOrFetcher === void 0) { choicesArrayOrFetcher = []; }
        if (value === void 0) { value = 'value'; }
        if (label === void 0) { label = 'label'; }
        if (replaceChoices === void 0) { replaceChoices = false; }
        if (clearSearchFlag === void 0) { clearSearchFlag = true; }
        if (!this.initialisedOK) {
            this._warnChoicesInitFailed('setChoices');
            return this;
        }
        if (!this._isSelectElement) {
            throw new TypeError("setChoices can't be used with INPUT based Choices");
        }
        if (typeof value !== 'string' || !value) {
            throw new TypeError("value parameter must be a name of 'value' field in passed objects");
        }
        // Clear choices if needed
        if (replaceChoices) {
            this.clearChoices();
        }
        if (typeof choicesArrayOrFetcher === 'function') {
            // it's a choices fetcher function
            var fetcher_1 = choicesArrayOrFetcher(this);
            if (typeof Promise === 'function' && fetcher_1 instanceof Promise) {
                // that's a promise
                // eslint-disable-next-line no-promise-executor-return
                return new Promise(function (resolve) { return requestAnimationFrame(resolve); })
                    .then(function () { return _this._handleLoadingState(true); })
                    .then(function () { return fetcher_1; })
                    .then(function (data) { return _this.setChoices(data, value, label, replaceChoices); })
                    .catch(function (err) {
                    if (!_this.config.silent) {
                        console.error(err);
                    }
                })
                    .then(function () { return _this._handleLoadingState(false); })
                    .then(function () { return _this; });
            }
            // function returned something else than promise, let's check if it's an array of choices
            if (!Array.isArray(fetcher_1)) {
                throw new TypeError(".setChoices first argument function must return either array of choices or Promise, got: ".concat(typeof fetcher_1));
            }
            // recursion with results, it's sync and choices were cleared already
            return this.setChoices(fetcher_1, value, label, false);
        }
        if (!Array.isArray(choicesArrayOrFetcher)) {
            throw new TypeError(".setChoices must be called either with array of choices with a function resulting into Promise of array of choices");
        }
        this.containerOuter.removeLoadingState();
        this._store.withTxn(function () {
            if (clearSearchFlag) {
                _this._isSearching = false;
            }
            var isDefaultValue = value === 'value';
            var isDefaultLabel = label === 'label';
            choicesArrayOrFetcher.forEach(function (groupOrChoice) {
                if ('choices' in groupOrChoice) {
                    var group = groupOrChoice;
                    if (!isDefaultLabel) {
                        group = __assign(__assign({}, group), { label: group[label] });
                    }
                    _this._addGroup(mapInputToChoice(group, true));
                }
                else {
                    var choice = groupOrChoice;
                    if (!isDefaultLabel || !isDefaultValue) {
                        choice = __assign(__assign({}, choice), { value: choice[value], label: choice[label] });
                    }
                    _this._addChoice(mapInputToChoice(choice, false));
                }
            });
            _this.unhighlightAll();
        });
        // @todo integrate with Store
        this._searcher.reset();
        return this;
    };
    Choices.prototype.refresh = function (withEvents, selectFirstOption, deselectAll) {
        var _this = this;
        if (withEvents === void 0) { withEvents = false; }
        if (selectFirstOption === void 0) { selectFirstOption = false; }
        if (deselectAll === void 0) { deselectAll = false; }
        if (!this._isSelectElement) {
            if (!this.config.silent) {
                console.warn('refresh method can only be used on choices backed by a <select> element');
            }
            return this;
        }
        this._store.withTxn(function () {
            var choicesFromOptions = _this.passedElement.optionsAsChoices();
            // Build the list of items which require preserving
            var existingItems = {};
            if (!deselectAll) {
                _this._store.items.forEach(function (choice) {
                    if (choice.id && choice.active && choice.selected && !choice.disabled) {
                        existingItems[choice.value] = true;
                    }
                });
            }
            _this.clearStore(false);
            var updateChoice = function (choice) {
                if (deselectAll) {
                    _this._store.dispatch(removeItem$1(choice));
                }
                else if (existingItems[choice.value]) {
                    choice.selected = true;
                }
            };
            choicesFromOptions.forEach(function (groupOrChoice) {
                if ('choices' in groupOrChoice) {
                    groupOrChoice.choices.forEach(updateChoice);
                    return;
                }
                updateChoice(groupOrChoice);
            });
            /* @todo only generate add events for the added options instead of all
            if (withEvents) {
              items.forEach((choice) => {
                if (existingItems[choice.value]) {
                  this.passedElement.triggerEvent(
                    EventType.removeItem,
                    this._getChoiceForEvent(choice),
                  );
                }
              });
            }
            */
            // load new choices & items
            _this._addPredefinedChoices(choicesFromOptions, selectFirstOption, withEvents);
            // re-do search if required
            if (_this._isSearching) {
                _this._searchChoices(_this.input.value);
            }
        });
        return this;
    };
    Choices.prototype.removeChoice = function (value) {
        var choice = this._store.choices.find(function (c) { return c.value === value; });
        if (!choice) {
            return this;
        }
        this._clearNotice();
        this._store.dispatch(removeChoice(choice));
        // @todo integrate with Store
        this._searcher.reset();
        if (choice.selected) {
            this.passedElement.triggerEvent(EventType.removeItem, this._getChoiceForOutput(choice));
        }
        return this;
    };
    Choices.prototype.clearChoices = function () {
        var _this = this;
        this._store.withTxn(function () {
            _this._store.choices.forEach(function (choice) {
                if (!choice.selected) {
                    _this._store.dispatch(removeChoice(choice));
                }
            });
        });
        // @todo integrate with Store
        this._searcher.reset();
        return this;
    };
    Choices.prototype.clearStore = function (clearOptions) {
        if (clearOptions === void 0) { clearOptions = true; }
        this._stopSearch();
        if (clearOptions) {
            this.passedElement.element.replaceChildren('');
        }
        this.itemList.element.replaceChildren('');
        this.choiceList.element.replaceChildren('');
        this._store.reset();
        this._lastAddedChoiceId = 0;
        this._lastAddedGroupId = 0;
        // @todo integrate with Store
        this._searcher.reset();
        return this;
    };
    Choices.prototype.clearInput = function () {
        var shouldSetInputWidth = !this._isSelectOneElement;
        this.input.clear(shouldSetInputWidth);
        this._stopSearch();
        return this;
    };
    Choices.prototype._validateConfig = function () {
        var config = this.config;
        var invalidConfigOptions = diff(config, DEFAULT_CONFIG);
        if (invalidConfigOptions.length) {
            console.warn('Unknown config option(s) passed', invalidConfigOptions.join(', '));
        }
        if (config.allowHTML && config.allowHtmlUserInput) {
            if (config.addItems) {
                console.warn('Warning: allowHTML/allowHtmlUserInput/addItems all being true is strongly not recommended and may lead to XSS attacks');
            }
            if (config.addChoices) {
                console.warn('Warning: allowHTML/allowHtmlUserInput/addChoices all being true is strongly not recommended and may lead to XSS attacks');
            }
        }
    };
    Choices.prototype._render = function (changes) {
        if (changes === void 0) { changes = { choices: true, groups: true, items: true }; }
        if (this._store.inTxn()) {
            return;
        }
        if (this._isSelectElement) {
            if (changes.choices || changes.groups) {
                this._renderChoices();
            }
        }
        if (changes.items) {
            this._renderItems();
        }
    };
    Choices.prototype._renderChoices = function () {
        var _this = this;
        if (!this._canAddItems()) {
            return; // block rendering choices if the input limit is reached.
        }
        var _a = this, config = _a.config, isSearching = _a._isSearching;
        var _b = this._store, activeGroups = _b.activeGroups, activeChoices = _b.activeChoices;
        var renderLimit = 0;
        if (isSearching && config.searchResultLimit > 0) {
            renderLimit = config.searchResultLimit;
        }
        else if (config.renderChoiceLimit > 0) {
            renderLimit = config.renderChoiceLimit;
        }
        if (this._isSelectElement) {
            var backingOptions = activeChoices.filter(function (choice) { return !choice.element; });
            if (backingOptions.length) {
                this.passedElement.addOptions(backingOptions);
            }
        }
        var fragment = document.createDocumentFragment();
        var renderableChoices = function (choices) {
            return choices.filter(function (choice) {
                return !choice.placeholder && (isSearching ? !!choice.rank : config.renderSelectedChoices || !choice.selected);
            });
        };
        var selectableChoices = false;
        var renderChoices = function (choices, withinGroup, groupLabel) {
            if (isSearching) {
                // sortByRank is used to ensure stable sorting, as scores are non-unique
                // this additionally ensures fuseOptions.sortFn is not ignored
                choices.sort(sortByRank);
            }
            else if (config.shouldSort) {
                choices.sort(config.sorter);
            }
            var choiceLimit = choices.length;
            choiceLimit = !withinGroup && renderLimit && choiceLimit > renderLimit ? renderLimit : choiceLimit;
            choiceLimit--;
            choices.every(function (choice, index) {
                // choiceEl being empty signals the contents has probably significantly changed
                var dropdownItem = choice.choiceEl || _this._templates.choice(config, choice, config.itemSelectText, groupLabel);
                choice.choiceEl = dropdownItem;
                fragment.appendChild(dropdownItem);
                if (!choice.disabled && (isSearching || !choice.selected)) {
                    selectableChoices = true;
                }
                return index < choiceLimit;
            });
        };
        if (activeChoices.length) {
            if (config.resetScrollPosition) {
                requestAnimationFrame(function () { return _this.choiceList.scrollToTop(); });
            }
            if (!this._hasNonChoicePlaceholder && !isSearching && this._isSelectOneElement) {
                // If we have a placeholder choice along with groups
                renderChoices(activeChoices.filter(function (choice) { return choice.placeholder && !choice.group; }), false, undefined);
            }
            // If we have grouped options
            if (activeGroups.length && !isSearching) {
                if (config.shouldSort) {
                    activeGroups.sort(config.sorter);
                }
                // render Choices without group first, regardless of sort, otherwise they won't be distinguishable
                // from the last group
                renderChoices(activeChoices.filter(function (choice) { return !choice.placeholder && !choice.group; }), false, undefined);
                activeGroups.forEach(function (group) {
                    var groupChoices = renderableChoices(group.choices);
                    if (groupChoices.length) {
                        if (group.label) {
                            var dropdownGroup = group.groupEl || _this._templates.choiceGroup(_this.config, group);
                            group.groupEl = dropdownGroup;
                            dropdownGroup.remove();
                            fragment.appendChild(dropdownGroup);
                        }
                        renderChoices(groupChoices, true, config.appendGroupInSearch && isSearching ? group.label : undefined);
                    }
                });
            }
            else {
                renderChoices(renderableChoices(activeChoices), false, undefined);
            }
        }
        if (!selectableChoices) {
            if (!this._notice) {
                this._notice = {
                    text: resolveStringFunction(isSearching ? config.noResultsText : config.noChoicesText),
                    type: isSearching ? NoticeTypes.noResults : NoticeTypes.noChoices,
                };
            }
            fragment.replaceChildren('');
        }
        this._renderNotice(fragment);
        this.choiceList.element.replaceChildren(fragment);
        if (selectableChoices) {
            this._highlightChoice();
        }
    };
    Choices.prototype._renderItems = function () {
        var _this = this;
        var items = this._store.items || [];
        var itemList = this.itemList.element;
        var config = this.config;
        var fragment = document.createDocumentFragment();
        var itemFromList = function (item) {
            return itemList.querySelector("[data-item][data-id=\"".concat(item.id, "\"]"));
        };
        var addItemToFragment = function (item) {
            var el = item.itemEl;
            if (el && el.parentElement) {
                return;
            }
            el = itemFromList(item) || _this._templates.item(config, item, config.removeItemButton);
            item.itemEl = el;
            fragment.appendChild(el);
        };
        // new items
        items.forEach(addItemToFragment);
        var addItems = !!fragment.childNodes.length;
        if (this._isSelectOneElement && this._hasNonChoicePlaceholder) {
            var existingItems = itemList.children.length;
            if (addItems || existingItems > 1) {
                var placeholder = itemList.querySelector(getClassNamesSelector(config.classNames.placeholder));
                if (placeholder) {
                    placeholder.remove();
                }
            }
            else if (!existingItems) {
                addItems = true;
                addItemToFragment(mapInputToChoice({
                    selected: true,
                    value: '',
                    label: config.placeholderValue || '',
                    placeholder: true,
                }, false));
            }
        }
        if (addItems) {
            itemList.append(fragment);
            if (config.shouldSortItems && !this._isSelectOneElement) {
                items.sort(config.sorter);
                // push sorting into the DOM
                items.forEach(function (item) {
                    var el = itemFromList(item);
                    if (el) {
                        el.remove();
                        fragment.append(el);
                    }
                });
                itemList.append(fragment);
            }
        }
        if (this._isTextElement) {
            // Update the value of the hidden input
            this.passedElement.value = items.map(function (_a) {
                var value = _a.value;
                return value;
            }).join(config.delimiter);
        }
    };
    Choices.prototype._displayNotice = function (text, type, openDropdown) {
        if (openDropdown === void 0) { openDropdown = true; }
        var oldNotice = this._notice;
        if (oldNotice &&
            ((oldNotice.type === type && oldNotice.text === text) ||
                (oldNotice.type === NoticeTypes.addChoice &&
                    (type === NoticeTypes.noResults || type === NoticeTypes.noChoices)))) {
            if (openDropdown) {
                this.showDropdown(true);
            }
            return;
        }
        this._clearNotice();
        this._notice = text
            ? {
                text: text,
                type: type,
            }
            : undefined;
        this._renderNotice();
        if (openDropdown && text) {
            this.showDropdown(true);
        }
    };
    Choices.prototype._clearNotice = function () {
        if (!this._notice) {
            return;
        }
        var noticeElement = this.choiceList.element.querySelector(getClassNamesSelector(this.config.classNames.notice));
        if (noticeElement) {
            noticeElement.remove();
        }
        this._notice = undefined;
    };
    Choices.prototype._renderNotice = function (fragment) {
        var noticeConf = this._notice;
        if (noticeConf) {
            var notice = this._templates.notice(this.config, noticeConf.text, noticeConf.type);
            if (fragment) {
                fragment.append(notice);
            }
            else {
                this.choiceList.prepend(notice);
            }
        }
    };
    // eslint-disable-next-line class-methods-use-this
    Choices.prototype._getChoiceForOutput = function (choice, keyCode) {
        return {
            id: choice.id,
            highlighted: choice.highlighted,
            labelClass: choice.labelClass,
            labelDescription: choice.labelDescription,
            customProperties: choice.customProperties,
            disabled: choice.disabled,
            active: choice.active,
            label: choice.label,
            placeholder: choice.placeholder,
            value: choice.value,
            groupValue: choice.group ? choice.group.label : undefined,
            element: choice.element,
            keyCode: keyCode,
        };
    };
    Choices.prototype._triggerChange = function (value) {
        if (value === undefined || value === null) {
            return;
        }
        this.passedElement.triggerEvent(EventType.change, {
            value: value,
        });
    };
    Choices.prototype._handleButtonAction = function (element) {
        var _this = this;
        var items = this._store.items;
        if (!items.length || !this.config.removeItems || !this.config.removeItemButton) {
            return;
        }
        var id = element && parseDataSetId(element.parentElement);
        var itemToRemove = id && items.find(function (item) { return item.id === id; });
        if (!itemToRemove) {
            return;
        }
        this._store.withTxn(function () {
            // Remove item associated with button
            _this._removeItem(itemToRemove);
            _this._triggerChange(itemToRemove.value);
            if (_this._isSelectOneElement && !_this._hasNonChoicePlaceholder) {
                var placeholderChoice = _this._store.choices
                    .reverse()
                    .find(function (choice) { return !choice.disabled && choice.placeholder; });
                if (placeholderChoice) {
                    _this._addItem(placeholderChoice);
                    _this.unhighlightAll();
                    if (placeholderChoice.value) {
                        _this._triggerChange(placeholderChoice.value);
                    }
                }
            }
        });
    };
    Choices.prototype._handleItemAction = function (element, hasShiftKey) {
        var _this = this;
        if (hasShiftKey === void 0) { hasShiftKey = false; }
        var items = this._store.items;
        if (!items.length || !this.config.removeItems || this._isSelectOneElement) {
            return;
        }
        var id = parseDataSetId(element);
        if (!id) {
            return;
        }
        // We only want to select one item with a click
        // so we deselect any items that aren't the target
        // unless shift is being pressed
        items.forEach(function (item) {
            if (item.id === id && !item.highlighted) {
                _this.highlightItem(item);
            }
            else if (!hasShiftKey && item.highlighted) {
                _this.unhighlightItem(item);
            }
        });
        // Focus input as without focus, a user cannot do anything with a
        // highlighted item
        this.input.focus();
    };
    Choices.prototype._handleChoiceAction = function (element) {
        var _this = this;
        // If we are clicking on an option
        var id = parseDataSetId(element);
        var choice = id && this._store.getChoiceById(id);
        if (!choice || choice.disabled) {
            return false;
        }
        var hasActiveDropdown = this.dropdown.isActive;
        if (!choice.selected) {
            if (!this._canAddItems()) {
                return true; // causes _onEnterKey to early out
            }
            this._store.withTxn(function () {
                _this._addItem(choice, true, true);
                _this.clearInput();
                _this.unhighlightAll();
            });
            this._triggerChange(choice.value);
        }
        // We want to close the dropdown if we are dealing with a single select box
        if (hasActiveDropdown && this.config.closeDropdownOnSelect) {
            this.hideDropdown(true);
            this.containerOuter.element.focus();
        }
        return true;
    };
    Choices.prototype._handleBackspace = function (items) {
        var config = this.config;
        if (!config.removeItems || !items.length) {
            return;
        }
        var lastItem = items[items.length - 1];
        var hasHighlightedItems = items.some(function (item) { return item.highlighted; });
        // If editing the last item is allowed and there are not other selected items,
        // we can edit the item value. Otherwise if we can remove items, remove all selected items
        if (config.editItems && !hasHighlightedItems && lastItem) {
            this.input.value = lastItem.value;
            this.input.setWidth();
            this._removeItem(lastItem);
            this._triggerChange(lastItem.value);
        }
        else {
            if (!hasHighlightedItems) {
                // Highlight last item if none already highlighted
                this.highlightItem(lastItem, false);
            }
            this.removeHighlightedItems(true);
        }
    };
    Choices.prototype._loadChoices = function () {
        var _a;
        var config = this.config;
        if (this._isTextElement) {
            // Assign preset items from passed object first
            this._presetChoices = config.items.map(function (e) { return mapInputToChoice(e, false); });
            // Add any values passed from attribute
            if (this.passedElement.value) {
                var elementItems = this.passedElement.value
                    .split(config.delimiter)
                    .map(function (e) { return mapInputToChoice(e, false); });
                this._presetChoices = this._presetChoices.concat(elementItems);
            }
            this._presetChoices.forEach(function (choice) {
                choice.selected = true;
            });
        }
        else if (this._isSelectElement) {
            // Assign preset choices from passed object
            this._presetChoices = config.choices.map(function (e) { return mapInputToChoice(e, true); });
            // Create array of choices from option elements
            var choicesFromOptions = this.passedElement.optionsAsChoices();
            if (choicesFromOptions) {
                (_a = this._presetChoices).push.apply(_a, choicesFromOptions);
            }
        }
    };
    Choices.prototype._handleLoadingState = function (setLoading) {
        if (setLoading === void 0) { setLoading = true; }
        var el = this.itemList.element;
        if (setLoading) {
            this.disable();
            this.containerOuter.addLoadingState();
            if (this._isSelectOneElement) {
                el.replaceChildren(this._templates.placeholder(this.config, this.config.loadingText));
            }
            else {
                this.input.placeholder = this.config.loadingText;
            }
        }
        else {
            this.enable();
            this.containerOuter.removeLoadingState();
            if (this._isSelectOneElement) {
                el.replaceChildren('');
                this._render();
            }
            else {
                this.input.placeholder = this._placeholderValue || '';
            }
        }
    };
    Choices.prototype._handleSearch = function (value) {
        if (!this.input.isFocussed) {
            return;
        }
        // Check that we have a value to search and the input was an alphanumeric character
        if (value !== null && typeof value !== 'undefined' && value.length >= this.config.searchFloor) {
            var resultCount = this.config.searchChoices ? this._searchChoices(value) : 0;
            if (resultCount !== null) {
                // Trigger search event
                this.passedElement.triggerEvent(EventType.search, {
                    value: value,
                    resultCount: resultCount,
                });
            }
        }
        else if (this._store.choices.some(function (option) { return !option.active; })) {
            this._stopSearch();
        }
    };
    Choices.prototype._canAddItems = function () {
        var config = this.config;
        var maxItemCount = config.maxItemCount, maxItemText = config.maxItemText;
        if (!config.singleModeForMultiSelect && maxItemCount > 0 && maxItemCount <= this._store.items.length) {
            this.choiceList.element.replaceChildren('');
            this._displayNotice(typeof maxItemText === 'function' ? maxItemText(maxItemCount) : maxItemText, NoticeTypes.addChoice);
            return false;
        }
        return true;
    };
    Choices.prototype._canCreateItem = function (value) {
        var config = this.config;
        var canAddItem = true;
        var notice = '';
        if (canAddItem && typeof config.addItemFilter === 'function' && !config.addItemFilter(value)) {
            canAddItem = false;
            notice = resolveNoticeFunction(config.customAddItemText, value);
        }
        if (canAddItem) {
            var foundChoice = this._store.choices.find(function (choice) { return config.valueComparer(choice.value, value); });
            if (this._isSelectElement) {
                // for exact matches, do not prompt to add it as a custom choice
                if (foundChoice) {
                    this._displayNotice('', NoticeTypes.addChoice);
                    return false;
                }
            }
            else if (this._isTextElement && !config.duplicateItemsAllowed) {
                if (foundChoice) {
                    canAddItem = false;
                    notice = resolveNoticeFunction(config.uniqueItemText, value);
                }
            }
        }
        if (canAddItem) {
            notice = resolveNoticeFunction(config.addItemText, value);
        }
        if (notice) {
            this._displayNotice(notice, NoticeTypes.addChoice);
        }
        return canAddItem;
    };
    Choices.prototype._searchChoices = function (value) {
        var newValue = value.trim().replace(/\s{2,}/, ' ');
        // signal input didn't change search
        if (!newValue.length || newValue === this._currentValue) {
            return null;
        }
        var searcher = this._searcher;
        if (searcher.isEmptyIndex()) {
            searcher.index(this._store.searchableChoices);
        }
        // If new value matches the desired length and is not the same as the current value with a space
        var results = searcher.search(newValue);
        this._currentValue = newValue;
        this._highlightPosition = 0;
        this._isSearching = true;
        var notice = this._notice;
        var noticeType = notice && notice.type;
        if (noticeType !== NoticeTypes.addChoice) {
            if (!results.length) {
                this._displayNotice(resolveStringFunction(this.config.noResultsText), NoticeTypes.noResults);
            }
            else {
                this._clearNotice();
            }
        }
        this._store.dispatch(filterChoices(results));
        return results.length;
    };
    Choices.prototype._stopSearch = function () {
        if (this._isSearching) {
            this._currentValue = '';
            this._isSearching = false;
            this._clearNotice();
            this._store.dispatch(activateChoices(true));
            this.passedElement.triggerEvent(EventType.search, {
                value: '',
                resultCount: 0,
            });
        }
    };
    Choices.prototype._addEventListeners = function () {
        var documentElement = this._docRoot;
        var outerElement = this.containerOuter.element;
        var inputElement = this.input.element;
        // capture events - can cancel event processing or propagation
        documentElement.addEventListener('touchend', this._onTouchEnd, true);
        outerElement.addEventListener('keydown', this._onKeyDown, true);
        outerElement.addEventListener('mousedown', this._onMouseDown, true);
        // passive events - doesn't call `preventDefault` or `stopPropagation`
        documentElement.addEventListener('click', this._onClick, { passive: true });
        documentElement.addEventListener('touchmove', this._onTouchMove, {
            passive: true,
        });
        this.dropdown.element.addEventListener('mouseover', this._onMouseOver, {
            passive: true,
        });
        if (this._isSelectOneElement) {
            outerElement.addEventListener('focus', this._onFocus, {
                passive: true,
            });
            outerElement.addEventListener('blur', this._onBlur, {
                passive: true,
            });
        }
        inputElement.addEventListener('keyup', this._onKeyUp, {
            passive: true,
        });
        inputElement.addEventListener('input', this._onInput, {
            passive: true,
        });
        inputElement.addEventListener('focus', this._onFocus, {
            passive: true,
        });
        inputElement.addEventListener('blur', this._onBlur, {
            passive: true,
        });
        if (inputElement.form) {
            inputElement.form.addEventListener('reset', this._onFormReset, {
                passive: true,
            });
        }
        this.input.addEventListeners();
    };
    Choices.prototype._removeEventListeners = function () {
        var documentElement = this._docRoot;
        var outerElement = this.containerOuter.element;
        var inputElement = this.input.element;
        documentElement.removeEventListener('touchend', this._onTouchEnd, true);
        outerElement.removeEventListener('keydown', this._onKeyDown, true);
        outerElement.removeEventListener('mousedown', this._onMouseDown, true);
        documentElement.removeEventListener('click', this._onClick);
        documentElement.removeEventListener('touchmove', this._onTouchMove);
        this.dropdown.element.removeEventListener('mouseover', this._onMouseOver);
        if (this._isSelectOneElement) {
            outerElement.removeEventListener('focus', this._onFocus);
            outerElement.removeEventListener('blur', this._onBlur);
        }
        inputElement.removeEventListener('keyup', this._onKeyUp);
        inputElement.removeEventListener('input', this._onInput);
        inputElement.removeEventListener('focus', this._onFocus);
        inputElement.removeEventListener('blur', this._onBlur);
        if (inputElement.form) {
            inputElement.form.removeEventListener('reset', this._onFormReset);
        }
        this.input.removeEventListeners();
    };
    Choices.prototype._onKeyDown = function (event) {
        var keyCode = event.keyCode;
        var hasActiveDropdown = this.dropdown.isActive;
        /*
        See:
        https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key
        https://developer.mozilla.org/en-US/docs/Web/API/UI_Events/Keyboard_event_key_values
        https://en.wikipedia.org/wiki/UTF-16#Code_points_from_U+010000_to_U+10FFFF - UTF-16 surrogate pairs
        https://stackoverflow.com/a/70866532 - "Unidentified" for mobile
        http://www.unicode.org/versions/Unicode5.2.0/ch16.pdf#G19635 - U+FFFF is reserved (Section 16.7)
    
        Logic: when a key event is sent, `event.key` represents its printable value _or_ one
        of a large list of special values indicating meta keys/functionality. In addition,
        key events for compose functionality contain a value of `Dead` when mid-composition.
    
        I can't quite verify it, but non-English IMEs may also be able to generate key codes
        for code points in the surrogate-pair range, which could potentially be seen as having
        key.length > 1. Since `Fn` is one of the special keys, we can't distinguish by that
        alone.
    
        Here, key.length === 1 means we know for sure the input was printable and not a special
        `key` value. When the length is greater than 1, it could be either a printable surrogate
        pair or a special `key` value. We can tell the difference by checking if the _character
        code_ value (not code point!) is in the "surrogate pair" range or not.
    
        We don't use .codePointAt because an invalid code point would return 65535, which wouldn't
        pass the >= 0x10000 check we would otherwise use.
    
        > ...The Unicode Standard sets aside 66 noncharacter code points. The last two code points
        > of each plane are noncharacters: U+FFFE and U+FFFF on the BMP...
        */
        var wasPrintableChar = event.key.length === 1 ||
            (event.key.length === 2 && event.key.charCodeAt(0) >= 0xd800) ||
            event.key === 'Unidentified';
        if (!this._isTextElement && !hasActiveDropdown) {
            this.showDropdown();
            if (!this.input.isFocussed && wasPrintableChar) {
                /*
                  We update the input value with the pressed key as
                  the input was not focussed at the time of key press
                  therefore does not have the value of the key.
                */
                this.input.value += event.key;
                // browsers interpret a space as pagedown
                if (event.key === ' ') {
                    event.preventDefault();
                }
            }
        }
        switch (keyCode) {
            case 65 /* KeyCodeMap.A_KEY */:
                return this._onSelectKey(event, this.itemList.element.hasChildNodes());
            case 13 /* KeyCodeMap.ENTER_KEY */:
                return this._onEnterKey(event, hasActiveDropdown);
            case 27 /* KeyCodeMap.ESC_KEY */:
                return this._onEscapeKey(event, hasActiveDropdown);
            case 38 /* KeyCodeMap.UP_KEY */:
            case 33 /* KeyCodeMap.PAGE_UP_KEY */:
            case 40 /* KeyCodeMap.DOWN_KEY */:
            case 34 /* KeyCodeMap.PAGE_DOWN_KEY */:
                return this._onDirectionKey(event, hasActiveDropdown);
            case 8 /* KeyCodeMap.DELETE_KEY */:
            case 46 /* KeyCodeMap.BACK_KEY */:
                return this._onDeleteKey(event, this._store.items, this.input.isFocussed);
        }
    };
    Choices.prototype._onKeyUp = function ( /* event: KeyboardEvent */) {
        this._canSearch = this.config.searchEnabled;
    };
    Choices.prototype._onInput = function ( /* event: InputEvent */) {
        var value = this.input.value;
        if (!value) {
            if (this._isTextElement) {
                this.hideDropdown(true);
            }
            else {
                this._stopSearch();
            }
            return;
        }
        if (!this._canAddItems()) {
            return;
        }
        if (this._canSearch) {
            // do the search even if the entered text can not be added
            this._handleSearch(value);
        }
        if (!this._canAddUserChoices) {
            return;
        }
        // determine if a notice needs to be displayed for why a search result can't be added
        this._canCreateItem(value);
        if (this._isSelectElement) {
            this._highlightPosition = 0; // reset to select the notice and/or exact match
            this._highlightChoice();
        }
    };
    Choices.prototype._onSelectKey = function (event, hasItems) {
        // If CTRL + A or CMD + A have been pressed and there are items to select
        if ((event.ctrlKey || event.metaKey) && hasItems) {
            this._canSearch = false;
            var shouldHightlightAll = this.config.removeItems && !this.input.value && this.input.element === document.activeElement;
            if (shouldHightlightAll) {
                this.highlightAll();
            }
        }
    };
    Choices.prototype._onEnterKey = function (event, hasActiveDropdown) {
        var _this = this;
        var value = this.input.value;
        var target = event.target;
        event.preventDefault();
        if (target && target.hasAttribute('data-button')) {
            this._handleButtonAction(target);
            return;
        }
        if (!hasActiveDropdown) {
            if (this._isSelectElement || this._notice) {
                this.showDropdown();
            }
            return;
        }
        var highlightedChoice = this.dropdown.element.querySelector(getClassNamesSelector(this.config.classNames.highlightedState));
        if (highlightedChoice && this._handleChoiceAction(highlightedChoice)) {
            return;
        }
        if (!target || !value) {
            this.hideDropdown(true);
            return;
        }
        if (!this._canAddItems()) {
            return;
        }
        var addedItem = false;
        this._store.withTxn(function () {
            addedItem = _this._findAndSelectChoiceByValue(value, true);
            if (!addedItem) {
                if (!_this._canAddUserChoices) {
                    return;
                }
                if (!_this._canCreateItem(value)) {
                    return;
                }
                var sanitisedValue = sanitise(value);
                var userValue = _this.config.allowHtmlUserInput || sanitisedValue === value ? value : { escaped: sanitisedValue, raw: value };
                _this._addChoice(mapInputToChoice({
                    value: userValue,
                    label: userValue,
                    selected: true,
                }, false), true, true);
                addedItem = true;
            }
            _this.clearInput();
            _this.unhighlightAll();
        });
        if (!addedItem) {
            return;
        }
        this._triggerChange(value);
        if (this.config.closeDropdownOnSelect) {
            this.hideDropdown(true);
        }
    };
    Choices.prototype._onEscapeKey = function (event, hasActiveDropdown) {
        if (hasActiveDropdown) {
            event.stopPropagation();
            this.hideDropdown(true);
            this.containerOuter.element.focus();
        }
    };
    Choices.prototype._onDirectionKey = function (event, hasActiveDropdown) {
        var keyCode = event.keyCode;
        // If up or down key is pressed, traverse through options
        if (hasActiveDropdown || this._isSelectOneElement) {
            this.showDropdown();
            this._canSearch = false;
            var directionInt = keyCode === 40 /* KeyCodeMap.DOWN_KEY */ || keyCode === 34 /* KeyCodeMap.PAGE_DOWN_KEY */ ? 1 : -1;
            var skipKey = event.metaKey || keyCode === 34 /* KeyCodeMap.PAGE_DOWN_KEY */ || keyCode === 33 /* KeyCodeMap.PAGE_UP_KEY */;
            var nextEl = void 0;
            if (skipKey) {
                if (directionInt > 0) {
                    nextEl = this.dropdown.element.querySelector("".concat(selectableChoiceIdentifier, ":last-of-type"));
                }
                else {
                    nextEl = this.dropdown.element.querySelector(selectableChoiceIdentifier);
                }
            }
            else {
                var currentEl = this.dropdown.element.querySelector(getClassNamesSelector(this.config.classNames.highlightedState));
                if (currentEl) {
                    nextEl = getAdjacentEl(currentEl, selectableChoiceIdentifier, directionInt);
                }
                else {
                    nextEl = this.dropdown.element.querySelector(selectableChoiceIdentifier);
                }
            }
            if (nextEl) {
                // We prevent default to stop the cursor moving
                // when pressing the arrow
                if (!isScrolledIntoView(nextEl, this.choiceList.element, directionInt)) {
                    this.choiceList.scrollToChildElement(nextEl, directionInt);
                }
                this._highlightChoice(nextEl);
            }
            // Prevent default to maintain cursor position whilst
            // traversing dropdown options
            event.preventDefault();
        }
    };
    Choices.prototype._onDeleteKey = function (event, items, hasFocusedInput) {
        // If backspace or delete key is pressed and the input has no value
        if (!this._isSelectOneElement && !event.target.value && hasFocusedInput) {
            this._handleBackspace(items);
            event.preventDefault();
        }
    };
    Choices.prototype._onTouchMove = function () {
        if (this._wasTap) {
            this._wasTap = false;
        }
    };
    Choices.prototype._onTouchEnd = function (event) {
        var target = (event || event.touches[0]).target;
        var touchWasWithinContainer = this._wasTap && this.containerOuter.element.contains(target);
        if (touchWasWithinContainer) {
            var containerWasExactTarget = target === this.containerOuter.element || target === this.containerInner.element;
            if (containerWasExactTarget) {
                if (this._isTextElement) {
                    this.input.focus();
                }
                else if (this._isSelectMultipleElement) {
                    this.showDropdown();
                }
            }
            // Prevents focus event firing
            event.stopPropagation();
        }
        this._wasTap = true;
    };
    /**
     * Handles mousedown event in capture mode for containetOuter.element
     */
    Choices.prototype._onMouseDown = function (event) {
        var target = event.target;
        if (!(target instanceof HTMLElement)) {
            return;
        }
        // If we have our mouse down on the scrollbar and are on IE11...
        if (IS_IE11 && this.choiceList.element.contains(target)) {
            // check if click was on a scrollbar area
            var firstChoice = this.choiceList.element.firstElementChild;
            this._isScrollingOnIe =
                this._direction === 'ltr' ? event.offsetX >= firstChoice.offsetWidth : event.offsetX < firstChoice.offsetLeft;
        }
        if (target === this.input.element) {
            return;
        }
        var item = target.closest('[data-button],[data-item],[data-choice]');
        if (item instanceof HTMLElement) {
            if ('button' in item.dataset) {
                this._handleButtonAction(item);
            }
            else if ('item' in item.dataset) {
                this._handleItemAction(item, event.shiftKey);
            }
            else if ('choice' in item.dataset) {
                this._handleChoiceAction(item);
            }
        }
        event.preventDefault();
    };
    /**
     * Handles mouseover event over this.dropdown
     * @param {MouseEvent} event
     */
    Choices.prototype._onMouseOver = function (_a) {
        var target = _a.target;
        if (target instanceof HTMLElement && 'choice' in target.dataset) {
            this._highlightChoice(target);
        }
    };
    Choices.prototype._onClick = function (_a) {
        var target = _a.target;
        var containerOuter = this.containerOuter;
        var clickWasWithinContainer = containerOuter.element.contains(target);
        if (clickWasWithinContainer) {
            if (!this.dropdown.isActive && !containerOuter.isDisabled) {
                if (this._isTextElement) {
                    if (document.activeElement !== this.input.element) {
                        this.input.focus();
                    }
                }
                else {
                    this.showDropdown();
                    containerOuter.element.focus();
                }
            }
            else if (this._isSelectOneElement &&
                target !== this.input.element &&
                !this.dropdown.element.contains(target)) {
                this.hideDropdown();
            }
        }
        else {
            containerOuter.removeFocusState();
            this.hideDropdown(true);
            this.unhighlightAll();
        }
    };
    Choices.prototype._onFocus = function (_a) {
        var target = _a.target;
        var containerOuter = this.containerOuter;
        var focusWasWithinContainer = target && containerOuter.element.contains(target);
        if (!focusWasWithinContainer) {
            return;
        }
        var targetIsInput = target === this.input.element;
        if (this._isTextElement) {
            if (targetIsInput) {
                containerOuter.addFocusState();
            }
        }
        else if (this._isSelectMultipleElement) {
            if (targetIsInput) {
                this.showDropdown(true);
                // If element is a select box, the focused element is the container and the dropdown
                // isn't already open, focus and show dropdown
                containerOuter.addFocusState();
            }
        }
        else {
            containerOuter.addFocusState();
            if (targetIsInput) {
                this.showDropdown(true);
            }
        }
    };
    Choices.prototype._onBlur = function (_a) {
        var target = _a.target;
        var containerOuter = this.containerOuter;
        var blurWasWithinContainer = target && containerOuter.element.contains(target);
        if (blurWasWithinContainer && !this._isScrollingOnIe) {
            var targetIsInput = target === this.input.element;
            if (this._isTextElement || this._isSelectMultipleElement) {
                if (targetIsInput) {
                    containerOuter.removeFocusState();
                    this.hideDropdown(true);
                    this.unhighlightAll();
                }
            }
            else {
                containerOuter.removeFocusState();
                if (targetIsInput || (target === containerOuter.element && !this._canSearch)) {
                    this.hideDropdown(true);
                }
            }
        }
        else {
            // On IE11, clicking the scollbar blurs our input and thus
            // closes the dropdown. To stop this, we refocus our input
            // if we know we are on IE *and* are scrolling.
            this._isScrollingOnIe = false;
            this.input.element.focus();
        }
    };
    Choices.prototype._onFormReset = function () {
        var _this = this;
        this._store.withTxn(function () {
            _this.clearInput();
            _this.hideDropdown();
            _this.refresh(false, false, true);
            if (_this._initialItems.length) {
                _this.setChoiceByValue(_this._initialItems);
            }
        });
    };
    Choices.prototype._highlightChoice = function (el) {
        if (el === void 0) { el = null; }
        var choices = Array.from(this.dropdown.element.querySelectorAll(selectableChoiceIdentifier));
        if (!choices.length) {
            return;
        }
        var passedEl = el;
        var highlightedState = this.config.classNames.highlightedState;
        var highlightedChoices = Array.from(this.dropdown.element.querySelectorAll(getClassNamesSelector(highlightedState)));
        // Remove any highlighted choices
        highlightedChoices.forEach(function (choice) {
            removeClassesFromElement(choice, highlightedState);
            choice.setAttribute('aria-selected', 'false');
        });
        if (passedEl) {
            this._highlightPosition = choices.indexOf(passedEl);
        }
        else {
            // Highlight choice based on last known highlight location
            if (choices.length > this._highlightPosition) {
                // If we have an option to highlight
                passedEl = choices[this._highlightPosition];
            }
            else {
                // Otherwise highlight the option before
                passedEl = choices[choices.length - 1];
            }
            if (!passedEl) {
                passedEl = choices[0];
            }
        }
        addClassesToElement(passedEl, highlightedState);
        passedEl.setAttribute('aria-selected', 'true');
        this.passedElement.triggerEvent(EventType.highlightChoice, {
            el: passedEl,
        });
        if (this.dropdown.isActive) {
            // IE11 ignores aria-label and blocks virtual keyboard
            // if aria-activedescendant is set without a dropdown
            this.input.setActiveDescendant(passedEl.id);
            this.containerOuter.setActiveDescendant(passedEl.id);
        }
    };
    Choices.prototype._addItem = function (item, withEvents, userTriggered) {
        if (withEvents === void 0) { withEvents = true; }
        if (userTriggered === void 0) { userTriggered = false; }
        if (!item.id) {
            throw new TypeError('item.id must be set before _addItem is called for a choice/item');
        }
        if (this.config.singleModeForMultiSelect || this._isSelectOneElement) {
            this.removeActiveItems(item.id);
        }
        this._store.dispatch(addItem(item));
        if (withEvents) {
            this.passedElement.triggerEvent(EventType.addItem, this._getChoiceForOutput(item));
            if (userTriggered) {
                this.passedElement.triggerEvent(EventType.choice, this._getChoiceForOutput(item));
            }
        }
    };
    Choices.prototype._removeItem = function (item) {
        if (!item.id) {
            return;
        }
        this._store.dispatch(removeItem$1(item));
        this.passedElement.triggerEvent(EventType.removeItem, this._getChoiceForOutput(item));
    };
    Choices.prototype._addChoice = function (choice, withEvents, userTriggered) {
        if (withEvents === void 0) { withEvents = true; }
        if (userTriggered === void 0) { userTriggered = false; }
        if (choice.id) {
            throw new TypeError('Can not re-add a choice which has already been added');
        }
        var config = this.config;
        if ((this._isSelectElement || !config.duplicateItemsAllowed) &&
            this._store.choices.find(function (c) { return config.valueComparer(c.value, choice.value); })) {
            return;
        }
        // Generate unique id, in-place update is required so chaining _addItem works as expected
        this._lastAddedChoiceId++;
        choice.id = this._lastAddedChoiceId;
        choice.elementId = "".concat(this._baseId, "-").concat(this._idNames.itemChoice, "-").concat(choice.id);
        var prependValue = config.prependValue, appendValue = config.appendValue;
        if (prependValue) {
            choice.value = prependValue + choice.value;
        }
        if (appendValue) {
            choice.value += appendValue.toString();
        }
        if ((prependValue || appendValue) && choice.element) {
            choice.element.value = choice.value;
        }
        this._clearNotice();
        this._store.dispatch(addChoice(choice));
        if (choice.selected) {
            this._addItem(choice, withEvents, userTriggered);
        }
    };
    Choices.prototype._addGroup = function (group, withEvents) {
        var _this = this;
        if (withEvents === void 0) { withEvents = true; }
        if (group.id) {
            throw new TypeError('Can not re-add a group which has already been added');
        }
        this._store.dispatch(addGroup(group));
        if (!group.choices) {
            return;
        }
        // add unique id for the group(s), and do not store the full list of choices in this group
        this._lastAddedGroupId++;
        group.id = this._lastAddedGroupId;
        group.choices.forEach(function (item) {
            item.group = group;
            if (group.disabled) {
                item.disabled = true;
            }
            _this._addChoice(item, withEvents);
        });
    };
    Choices.prototype._createTemplates = function () {
        var _this = this;
        var callbackOnCreateTemplates = this.config.callbackOnCreateTemplates;
        var userTemplates = {};
        if (typeof callbackOnCreateTemplates === 'function') {
            userTemplates = callbackOnCreateTemplates.call(this, strToEl, escapeForTemplate, getClassNames);
        }
        var templating = {};
        Object.keys(this._templates).forEach(function (name) {
            if (name in userTemplates) {
                templating[name] = userTemplates[name].bind(_this);
            }
            else {
                templating[name] = _this._templates[name].bind(_this);
            }
        });
        this._templates = templating;
    };
    Choices.prototype._createElements = function () {
        var templating = this._templates;
        var _a = this, config = _a.config, isSelectOneElement = _a._isSelectOneElement;
        var position = config.position, classNames = config.classNames;
        var elementType = this._elementType;
        this.containerOuter = new Container({
            element: templating.containerOuter(config, this._direction, this._isSelectElement, isSelectOneElement, config.searchEnabled, elementType, config.labelId),
            classNames: classNames,
            type: elementType,
            position: position,
        });
        this.containerInner = new Container({
            element: templating.containerInner(config),
            classNames: classNames,
            type: elementType,
            position: position,
        });
        this.input = new Input({
            element: templating.input(config, this._placeholderValue),
            classNames: classNames,
            type: elementType,
            preventPaste: !config.paste,
        });
        this.choiceList = new List({
            element: templating.choiceList(config, isSelectOneElement),
        });
        this.itemList = new List({
            element: templating.itemList(config, isSelectOneElement),
        });
        this.dropdown = new Dropdown({
            element: templating.dropdown(config),
            classNames: classNames,
            type: elementType,
        });
    };
    Choices.prototype._createStructure = function () {
        var _a = this, containerInner = _a.containerInner, containerOuter = _a.containerOuter, passedElement = _a.passedElement;
        var dropdownElement = this.dropdown.element;
        // Hide original element
        passedElement.conceal();
        // Wrap input in container preserving DOM ordering
        containerInner.wrap(passedElement.element);
        // Wrapper inner container with outer container
        containerOuter.wrap(containerInner.element);
        if (this._isSelectOneElement) {
            this.input.placeholder = this.config.searchPlaceholderValue || '';
        }
        else {
            if (this._placeholderValue) {
                this.input.placeholder = this._placeholderValue;
            }
            this.input.setWidth();
        }
        containerOuter.element.appendChild(containerInner.element);
        containerOuter.element.appendChild(dropdownElement);
        containerInner.element.appendChild(this.itemList.element);
        dropdownElement.appendChild(this.choiceList.element);
        if (!this._isSelectOneElement) {
            containerInner.element.appendChild(this.input.element);
        }
        else if (this.config.searchEnabled) {
            dropdownElement.insertBefore(this.input.element, dropdownElement.firstChild);
        }
        this._highlightPosition = 0;
        this._isSearching = false;
    };
    Choices.prototype._initStore = function () {
        var _this = this;
        this._store.subscribe(this._render).withTxn(function () {
            _this._addPredefinedChoices(_this._presetChoices, _this._isSelectOneElement && !_this._hasNonChoicePlaceholder, false);
        });
        if (!this._store.choices.length || (this._isSelectOneElement && this._hasNonChoicePlaceholder)) {
            this._render();
        }
    };
    Choices.prototype._addPredefinedChoices = function (choices, selectFirstOption, withEvents) {
        var _this = this;
        if (selectFirstOption === void 0) { selectFirstOption = false; }
        if (withEvents === void 0) { withEvents = true; }
        if (selectFirstOption) {
            /**
             * If there is a selected choice already or the choice is not the first in
             * the array, add each choice normally.
             *
             * Otherwise we pre-select the first enabled choice in the array ("select-one" only)
             */
            var noSelectedChoices = choices.findIndex(function (choice) { return choice.selected; }) === -1;
            if (noSelectedChoices) {
                choices.some(function (choice) {
                    if (choice.disabled || 'choices' in choice) {
                        return false;
                    }
                    choice.selected = true;
                    return true;
                });
            }
        }
        choices.forEach(function (item) {
            if ('choices' in item) {
                if (_this._isSelectElement) {
                    _this._addGroup(item, withEvents);
                }
            }
            else {
                _this._addChoice(item, withEvents);
            }
        });
    };
    Choices.prototype._findAndSelectChoiceByValue = function (value, userTriggered) {
        var _this = this;
        if (userTriggered === void 0) { userTriggered = false; }
        // Check 'value' property exists and the choice isn't already selected
        var foundChoice = this._store.choices.find(function (choice) { return _this.config.valueComparer(choice.value, value); });
        if (foundChoice && !foundChoice.disabled && !foundChoice.selected) {
            this._addItem(foundChoice, true, userTriggered);
            return true;
        }
        return false;
    };
    Choices.prototype._generatePlaceholderValue = function () {
        var config = this.config;
        if (!config.placeholder) {
            return null;
        }
        if (this._hasNonChoicePlaceholder) {
            return config.placeholderValue;
        }
        if (this._isSelectElement) {
            var placeholderOption = this.passedElement.placeholderOption;
            return placeholderOption ? placeholderOption.text : null;
        }
        return null;
    };
    Choices.prototype._warnChoicesInitFailed = function (caller) {
        if (this.config.silent) {
            return;
        }
        if (!this.initialised) {
            throw new TypeError("".concat(caller, " called on a non-initialised instance of Choices"));
        }
        else if (!this.initialisedOK) {
            throw new TypeError("".concat(caller, " called for an element which has multiple instances of Choices initialised on it"));
        }
    };
    Choices.version = '11.0.2';
    return Choices;
}());




/***/ }),

/***/ "./node_modules/swiper/modules/a11y.mjs":
/*!**********************************************!*\
  !*** ./node_modules/swiper/modules/a11y.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ A11y)
/* harmony export */ });
/* harmony import */ var _shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/ssr-window.esm.mjs */ "./node_modules/swiper/shared/ssr-window.esm.mjs");
/* harmony import */ var _shared_classes_to_selector_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/classes-to-selector.mjs */ "./node_modules/swiper/shared/classes-to-selector.mjs");
/* harmony import */ var _shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/utils.mjs */ "./node_modules/swiper/shared/utils.mjs");




function A11y(_ref) {
  let {
    swiper,
    extendParams,
    on
  } = _ref;
  extendParams({
    a11y: {
      enabled: true,
      notificationClass: 'swiper-notification',
      prevSlideMessage: 'Previous slide',
      nextSlideMessage: 'Next slide',
      firstSlideMessage: 'This is the first slide',
      lastSlideMessage: 'This is the last slide',
      paginationBulletMessage: 'Go to slide {{index}}',
      slideLabelMessage: '{{index}} / {{slidesLength}}',
      containerMessage: null,
      containerRoleDescriptionMessage: null,
      containerRole: null,
      itemRoleDescriptionMessage: null,
      slideRole: 'group',
      id: null,
      scrollOnFocus: true
    }
  });
  swiper.a11y = {
    clicked: false
  };
  let liveRegion = null;
  let preventFocusHandler;
  let focusTargetSlideEl;
  let visibilityChangedTimestamp = new Date().getTime();
  function notify(message) {
    const notification = liveRegion;
    if (notification.length === 0) return;
    notification.innerHTML = '';
    notification.innerHTML = message;
  }
  function getRandomNumber(size) {
    if (size === void 0) {
      size = 16;
    }
    const randomChar = () => Math.round(16 * Math.random()).toString(16);
    return 'x'.repeat(size).replace(/x/g, randomChar);
  }
  function makeElFocusable(el) {
    el = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(el);
    el.forEach(subEl => {
      subEl.setAttribute('tabIndex', '0');
    });
  }
  function makeElNotFocusable(el) {
    el = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(el);
    el.forEach(subEl => {
      subEl.setAttribute('tabIndex', '-1');
    });
  }
  function addElRole(el, role) {
    el = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(el);
    el.forEach(subEl => {
      subEl.setAttribute('role', role);
    });
  }
  function addElRoleDescription(el, description) {
    el = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(el);
    el.forEach(subEl => {
      subEl.setAttribute('aria-roledescription', description);
    });
  }
  function addElControls(el, controls) {
    el = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(el);
    el.forEach(subEl => {
      subEl.setAttribute('aria-controls', controls);
    });
  }
  function addElLabel(el, label) {
    el = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(el);
    el.forEach(subEl => {
      subEl.setAttribute('aria-label', label);
    });
  }
  function addElId(el, id) {
    el = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(el);
    el.forEach(subEl => {
      subEl.setAttribute('id', id);
    });
  }
  function addElLive(el, live) {
    el = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(el);
    el.forEach(subEl => {
      subEl.setAttribute('aria-live', live);
    });
  }
  function disableEl(el) {
    el = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(el);
    el.forEach(subEl => {
      subEl.setAttribute('aria-disabled', true);
    });
  }
  function enableEl(el) {
    el = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(el);
    el.forEach(subEl => {
      subEl.setAttribute('aria-disabled', false);
    });
  }
  function onEnterOrSpaceKey(e) {
    if (e.keyCode !== 13 && e.keyCode !== 32) return;
    const params = swiper.params.a11y;
    const targetEl = e.target;
    if (swiper.pagination && swiper.pagination.el && (targetEl === swiper.pagination.el || swiper.pagination.el.contains(e.target))) {
      if (!e.target.matches((0,_shared_classes_to_selector_mjs__WEBPACK_IMPORTED_MODULE_1__.c)(swiper.params.pagination.bulletClass))) return;
    }
    if (swiper.navigation && swiper.navigation.prevEl && swiper.navigation.nextEl) {
      const prevEls = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(swiper.navigation.prevEl);
      const nextEls = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(swiper.navigation.nextEl);
      if (nextEls.includes(targetEl)) {
        if (!(swiper.isEnd && !swiper.params.loop)) {
          swiper.slideNext();
        }
        if (swiper.isEnd) {
          notify(params.lastSlideMessage);
        } else {
          notify(params.nextSlideMessage);
        }
      }
      if (prevEls.includes(targetEl)) {
        if (!(swiper.isBeginning && !swiper.params.loop)) {
          swiper.slidePrev();
        }
        if (swiper.isBeginning) {
          notify(params.firstSlideMessage);
        } else {
          notify(params.prevSlideMessage);
        }
      }
    }
    if (swiper.pagination && targetEl.matches((0,_shared_classes_to_selector_mjs__WEBPACK_IMPORTED_MODULE_1__.c)(swiper.params.pagination.bulletClass))) {
      targetEl.click();
    }
  }
  function updateNavigation() {
    if (swiper.params.loop || swiper.params.rewind || !swiper.navigation) return;
    const {
      nextEl,
      prevEl
    } = swiper.navigation;
    if (prevEl) {
      if (swiper.isBeginning) {
        disableEl(prevEl);
        makeElNotFocusable(prevEl);
      } else {
        enableEl(prevEl);
        makeElFocusable(prevEl);
      }
    }
    if (nextEl) {
      if (swiper.isEnd) {
        disableEl(nextEl);
        makeElNotFocusable(nextEl);
      } else {
        enableEl(nextEl);
        makeElFocusable(nextEl);
      }
    }
  }
  function hasPagination() {
    return swiper.pagination && swiper.pagination.bullets && swiper.pagination.bullets.length;
  }
  function hasClickablePagination() {
    return hasPagination() && swiper.params.pagination.clickable;
  }
  function updatePagination() {
    const params = swiper.params.a11y;
    if (!hasPagination()) return;
    swiper.pagination.bullets.forEach(bulletEl => {
      if (swiper.params.pagination.clickable) {
        makeElFocusable(bulletEl);
        if (!swiper.params.pagination.renderBullet) {
          addElRole(bulletEl, 'button');
          addElLabel(bulletEl, params.paginationBulletMessage.replace(/\{\{index\}\}/, (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.h)(bulletEl) + 1));
        }
      }
      if (bulletEl.matches((0,_shared_classes_to_selector_mjs__WEBPACK_IMPORTED_MODULE_1__.c)(swiper.params.pagination.bulletActiveClass))) {
        bulletEl.setAttribute('aria-current', 'true');
      } else {
        bulletEl.removeAttribute('aria-current');
      }
    });
  }
  const initNavEl = (el, wrapperId, message) => {
    makeElFocusable(el);
    if (el.tagName !== 'BUTTON') {
      addElRole(el, 'button');
      el.addEventListener('keydown', onEnterOrSpaceKey);
    }
    addElLabel(el, message);
    addElControls(el, wrapperId);
  };
  const handlePointerDown = e => {
    if (focusTargetSlideEl && focusTargetSlideEl !== e.target && !focusTargetSlideEl.contains(e.target)) {
      preventFocusHandler = true;
    }
    swiper.a11y.clicked = true;
  };
  const handlePointerUp = () => {
    preventFocusHandler = false;
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        if (!swiper.destroyed) {
          swiper.a11y.clicked = false;
        }
      });
    });
  };
  const onVisibilityChange = e => {
    visibilityChangedTimestamp = new Date().getTime();
  };
  const handleFocus = e => {
    if (swiper.a11y.clicked || !swiper.params.a11y.scrollOnFocus) return;
    if (new Date().getTime() - visibilityChangedTimestamp < 100) return;
    const slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);
    if (!slideEl || !swiper.slides.includes(slideEl)) return;
    focusTargetSlideEl = slideEl;
    const isActive = swiper.slides.indexOf(slideEl) === swiper.activeIndex;
    const isVisible = swiper.params.watchSlidesProgress && swiper.visibleSlides && swiper.visibleSlides.includes(slideEl);
    if (isActive || isVisible) return;
    if (e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents) return;
    if (swiper.isHorizontal()) {
      swiper.el.scrollLeft = 0;
    } else {
      swiper.el.scrollTop = 0;
    }
    requestAnimationFrame(() => {
      if (preventFocusHandler) return;
      if (swiper.params.loop) {
        swiper.slideToLoop(parseInt(slideEl.getAttribute('data-swiper-slide-index')), 0);
      } else {
        swiper.slideTo(swiper.slides.indexOf(slideEl), 0);
      }
      preventFocusHandler = false;
    });
  };
  const initSlides = () => {
    const params = swiper.params.a11y;
    if (params.itemRoleDescriptionMessage) {
      addElRoleDescription(swiper.slides, params.itemRoleDescriptionMessage);
    }
    if (params.slideRole) {
      addElRole(swiper.slides, params.slideRole);
    }
    const slidesLength = swiper.slides.length;
    if (params.slideLabelMessage) {
      swiper.slides.forEach((slideEl, index) => {
        const slideIndex = swiper.params.loop ? parseInt(slideEl.getAttribute('data-swiper-slide-index'), 10) : index;
        const ariaLabelMessage = params.slideLabelMessage.replace(/\{\{index\}\}/, slideIndex + 1).replace(/\{\{slidesLength\}\}/, slidesLength);
        addElLabel(slideEl, ariaLabelMessage);
      });
    }
  };
  const init = () => {
    const params = swiper.params.a11y;
    swiper.el.append(liveRegion);

    // Container
    const containerEl = swiper.el;
    if (params.containerRoleDescriptionMessage) {
      addElRoleDescription(containerEl, params.containerRoleDescriptionMessage);
    }
    if (params.containerMessage) {
      addElLabel(containerEl, params.containerMessage);
    }
    if (params.containerRole) {
      addElRole(containerEl, params.containerRole);
    }

    // Wrapper
    const wrapperEl = swiper.wrapperEl;
    const wrapperId = params.id || wrapperEl.getAttribute('id') || `swiper-wrapper-${getRandomNumber(16)}`;
    const live = swiper.params.autoplay && swiper.params.autoplay.enabled ? 'off' : 'polite';
    addElId(wrapperEl, wrapperId);
    addElLive(wrapperEl, live);

    // Slide
    initSlides();

    // Navigation
    let {
      nextEl,
      prevEl
    } = swiper.navigation ? swiper.navigation : {};
    nextEl = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(nextEl);
    prevEl = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(prevEl);
    if (nextEl) {
      nextEl.forEach(el => initNavEl(el, wrapperId, params.nextSlideMessage));
    }
    if (prevEl) {
      prevEl.forEach(el => initNavEl(el, wrapperId, params.prevSlideMessage));
    }

    // Pagination
    if (hasClickablePagination()) {
      const paginationEl = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(swiper.pagination.el);
      paginationEl.forEach(el => {
        el.addEventListener('keydown', onEnterOrSpaceKey);
      });
    }

    // Tab focus
    const document = (0,_shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();
    document.addEventListener('visibilitychange', onVisibilityChange);
    swiper.el.addEventListener('focus', handleFocus, true);
    swiper.el.addEventListener('focus', handleFocus, true);
    swiper.el.addEventListener('pointerdown', handlePointerDown, true);
    swiper.el.addEventListener('pointerup', handlePointerUp, true);
  };
  function destroy() {
    if (liveRegion) liveRegion.remove();
    let {
      nextEl,
      prevEl
    } = swiper.navigation ? swiper.navigation : {};
    nextEl = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(nextEl);
    prevEl = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(prevEl);
    if (nextEl) {
      nextEl.forEach(el => el.removeEventListener('keydown', onEnterOrSpaceKey));
    }
    if (prevEl) {
      prevEl.forEach(el => el.removeEventListener('keydown', onEnterOrSpaceKey));
    }

    // Pagination
    if (hasClickablePagination()) {
      const paginationEl = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(swiper.pagination.el);
      paginationEl.forEach(el => {
        el.removeEventListener('keydown', onEnterOrSpaceKey);
      });
    }
    const document = (0,_shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();
    document.removeEventListener('visibilitychange', onVisibilityChange);
    // Tab focus
    if (swiper.el && typeof swiper.el !== 'string') {
      swiper.el.removeEventListener('focus', handleFocus, true);
      swiper.el.removeEventListener('pointerdown', handlePointerDown, true);
      swiper.el.removeEventListener('pointerup', handlePointerUp, true);
    }
  }
  on('beforeInit', () => {
    liveRegion = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.c)('span', swiper.params.a11y.notificationClass);
    liveRegion.setAttribute('aria-live', 'assertive');
    liveRegion.setAttribute('aria-atomic', 'true');
  });
  on('afterInit', () => {
    if (!swiper.params.a11y.enabled) return;
    init();
  });
  on('slidesLengthChange snapGridLengthChange slidesGridLengthChange', () => {
    if (!swiper.params.a11y.enabled) return;
    initSlides();
  });
  on('fromEdge toEdge afterInit lock unlock', () => {
    if (!swiper.params.a11y.enabled) return;
    updateNavigation();
  });
  on('paginationUpdate', () => {
    if (!swiper.params.a11y.enabled) return;
    updatePagination();
  });
  on('destroy', () => {
    if (!swiper.params.a11y.enabled) return;
    destroy();
  });
}




/***/ }),

/***/ "./node_modules/swiper/modules/autoplay.mjs":
/*!**************************************************!*\
  !*** ./node_modules/swiper/modules/autoplay.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Autoplay)
/* harmony export */ });
/* harmony import */ var _shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/ssr-window.esm.mjs */ "./node_modules/swiper/shared/ssr-window.esm.mjs");


/* eslint no-underscore-dangle: "off" */
/* eslint no-use-before-define: "off" */
function Autoplay(_ref) {
  let {
    swiper,
    extendParams,
    on,
    emit,
    params
  } = _ref;
  swiper.autoplay = {
    running: false,
    paused: false,
    timeLeft: 0
  };
  extendParams({
    autoplay: {
      enabled: false,
      delay: 3000,
      waitForTransition: true,
      disableOnInteraction: false,
      stopOnLastSlide: false,
      reverseDirection: false,
      pauseOnMouseEnter: false
    }
  });
  let timeout;
  let raf;
  let autoplayDelayTotal = params && params.autoplay ? params.autoplay.delay : 3000;
  let autoplayDelayCurrent = params && params.autoplay ? params.autoplay.delay : 3000;
  let autoplayTimeLeft;
  let autoplayStartTime = new Date().getTime();
  let wasPaused;
  let isTouched;
  let pausedByTouch;
  let touchStartTimeout;
  let slideChanged;
  let pausedByInteraction;
  let pausedByPointerEnter;
  function onTransitionEnd(e) {
    if (!swiper || swiper.destroyed || !swiper.wrapperEl) return;
    if (e.target !== swiper.wrapperEl) return;
    swiper.wrapperEl.removeEventListener('transitionend', onTransitionEnd);
    if (pausedByPointerEnter || e.detail && e.detail.bySwiperTouchMove) {
      return;
    }
    resume();
  }
  const calcTimeLeft = () => {
    if (swiper.destroyed || !swiper.autoplay.running) return;
    if (swiper.autoplay.paused) {
      wasPaused = true;
    } else if (wasPaused) {
      autoplayDelayCurrent = autoplayTimeLeft;
      wasPaused = false;
    }
    const timeLeft = swiper.autoplay.paused ? autoplayTimeLeft : autoplayStartTime + autoplayDelayCurrent - new Date().getTime();
    swiper.autoplay.timeLeft = timeLeft;
    emit('autoplayTimeLeft', timeLeft, timeLeft / autoplayDelayTotal);
    raf = requestAnimationFrame(() => {
      calcTimeLeft();
    });
  };
  const getSlideDelay = () => {
    let activeSlideEl;
    if (swiper.virtual && swiper.params.virtual.enabled) {
      activeSlideEl = swiper.slides.filter(slideEl => slideEl.classList.contains('swiper-slide-active'))[0];
    } else {
      activeSlideEl = swiper.slides[swiper.activeIndex];
    }
    if (!activeSlideEl) return undefined;
    const currentSlideDelay = parseInt(activeSlideEl.getAttribute('data-swiper-autoplay'), 10);
    return currentSlideDelay;
  };
  const run = delayForce => {
    if (swiper.destroyed || !swiper.autoplay.running) return;
    cancelAnimationFrame(raf);
    calcTimeLeft();
    let delay = typeof delayForce === 'undefined' ? swiper.params.autoplay.delay : delayForce;
    autoplayDelayTotal = swiper.params.autoplay.delay;
    autoplayDelayCurrent = swiper.params.autoplay.delay;
    const currentSlideDelay = getSlideDelay();
    if (!Number.isNaN(currentSlideDelay) && currentSlideDelay > 0 && typeof delayForce === 'undefined') {
      delay = currentSlideDelay;
      autoplayDelayTotal = currentSlideDelay;
      autoplayDelayCurrent = currentSlideDelay;
    }
    autoplayTimeLeft = delay;
    const speed = swiper.params.speed;
    const proceed = () => {
      if (!swiper || swiper.destroyed) return;
      if (swiper.params.autoplay.reverseDirection) {
        if (!swiper.isBeginning || swiper.params.loop || swiper.params.rewind) {
          swiper.slidePrev(speed, true, true);
          emit('autoplay');
        } else if (!swiper.params.autoplay.stopOnLastSlide) {
          swiper.slideTo(swiper.slides.length - 1, speed, true, true);
          emit('autoplay');
        }
      } else {
        if (!swiper.isEnd || swiper.params.loop || swiper.params.rewind) {
          swiper.slideNext(speed, true, true);
          emit('autoplay');
        } else if (!swiper.params.autoplay.stopOnLastSlide) {
          swiper.slideTo(0, speed, true, true);
          emit('autoplay');
        }
      }
      if (swiper.params.cssMode) {
        autoplayStartTime = new Date().getTime();
        requestAnimationFrame(() => {
          run();
        });
      }
    };
    if (delay > 0) {
      clearTimeout(timeout);
      timeout = setTimeout(() => {
        proceed();
      }, delay);
    } else {
      requestAnimationFrame(() => {
        proceed();
      });
    }

    // eslint-disable-next-line
    return delay;
  };
  const start = () => {
    autoplayStartTime = new Date().getTime();
    swiper.autoplay.running = true;
    run();
    emit('autoplayStart');
  };
  const stop = () => {
    swiper.autoplay.running = false;
    clearTimeout(timeout);
    cancelAnimationFrame(raf);
    emit('autoplayStop');
  };
  const pause = (internal, reset) => {
    if (swiper.destroyed || !swiper.autoplay.running) return;
    clearTimeout(timeout);
    if (!internal) {
      pausedByInteraction = true;
    }
    const proceed = () => {
      emit('autoplayPause');
      if (swiper.params.autoplay.waitForTransition) {
        swiper.wrapperEl.addEventListener('transitionend', onTransitionEnd);
      } else {
        resume();
      }
    };
    swiper.autoplay.paused = true;
    if (reset) {
      if (slideChanged) {
        autoplayTimeLeft = swiper.params.autoplay.delay;
      }
      slideChanged = false;
      proceed();
      return;
    }
    const delay = autoplayTimeLeft || swiper.params.autoplay.delay;
    autoplayTimeLeft = delay - (new Date().getTime() - autoplayStartTime);
    if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop) return;
    if (autoplayTimeLeft < 0) autoplayTimeLeft = 0;
    proceed();
  };
  const resume = () => {
    if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop || swiper.destroyed || !swiper.autoplay.running) return;
    autoplayStartTime = new Date().getTime();
    if (pausedByInteraction) {
      pausedByInteraction = false;
      run(autoplayTimeLeft);
    } else {
      run();
    }
    swiper.autoplay.paused = false;
    emit('autoplayResume');
  };
  const onVisibilityChange = () => {
    if (swiper.destroyed || !swiper.autoplay.running) return;
    const document = (0,_shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();
    if (document.visibilityState === 'hidden') {
      pausedByInteraction = true;
      pause(true);
    }
    if (document.visibilityState === 'visible') {
      resume();
    }
  };
  const onPointerEnter = e => {
    if (e.pointerType !== 'mouse') return;
    pausedByInteraction = true;
    pausedByPointerEnter = true;
    if (swiper.animating || swiper.autoplay.paused) return;
    pause(true);
  };
  const onPointerLeave = e => {
    if (e.pointerType !== 'mouse') return;
    pausedByPointerEnter = false;
    if (swiper.autoplay.paused) {
      resume();
    }
  };
  const attachMouseEvents = () => {
    if (swiper.params.autoplay.pauseOnMouseEnter) {
      swiper.el.addEventListener('pointerenter', onPointerEnter);
      swiper.el.addEventListener('pointerleave', onPointerLeave);
    }
  };
  const detachMouseEvents = () => {
    if (swiper.el && typeof swiper.el !== 'string') {
      swiper.el.removeEventListener('pointerenter', onPointerEnter);
      swiper.el.removeEventListener('pointerleave', onPointerLeave);
    }
  };
  const attachDocumentEvents = () => {
    const document = (0,_shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();
    document.addEventListener('visibilitychange', onVisibilityChange);
  };
  const detachDocumentEvents = () => {
    const document = (0,_shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();
    document.removeEventListener('visibilitychange', onVisibilityChange);
  };
  on('init', () => {
    if (swiper.params.autoplay.enabled) {
      attachMouseEvents();
      attachDocumentEvents();
      start();
    }
  });
  on('destroy', () => {
    detachMouseEvents();
    detachDocumentEvents();
    if (swiper.autoplay.running) {
      stop();
    }
  });
  on('_freeModeStaticRelease', () => {
    if (pausedByTouch || pausedByInteraction) {
      resume();
    }
  });
  on('_freeModeNoMomentumRelease', () => {
    if (!swiper.params.autoplay.disableOnInteraction) {
      pause(true, true);
    } else {
      stop();
    }
  });
  on('beforeTransitionStart', (_s, speed, internal) => {
    if (swiper.destroyed || !swiper.autoplay.running) return;
    if (internal || !swiper.params.autoplay.disableOnInteraction) {
      pause(true, true);
    } else {
      stop();
    }
  });
  on('sliderFirstMove', () => {
    if (swiper.destroyed || !swiper.autoplay.running) return;
    if (swiper.params.autoplay.disableOnInteraction) {
      stop();
      return;
    }
    isTouched = true;
    pausedByTouch = false;
    pausedByInteraction = false;
    touchStartTimeout = setTimeout(() => {
      pausedByInteraction = true;
      pausedByTouch = true;
      pause(true);
    }, 200);
  });
  on('touchEnd', () => {
    if (swiper.destroyed || !swiper.autoplay.running || !isTouched) return;
    clearTimeout(touchStartTimeout);
    clearTimeout(timeout);
    if (swiper.params.autoplay.disableOnInteraction) {
      pausedByTouch = false;
      isTouched = false;
      return;
    }
    if (pausedByTouch && swiper.params.cssMode) resume();
    pausedByTouch = false;
    isTouched = false;
  });
  on('slideChange', () => {
    if (swiper.destroyed || !swiper.autoplay.running) return;
    slideChanged = true;
  });
  Object.assign(swiper.autoplay, {
    start,
    stop,
    pause,
    resume
  });
}




/***/ }),

/***/ "./node_modules/swiper/modules/controller.mjs":
/*!****************************************************!*\
  !*** ./node_modules/swiper/modules/controller.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Controller)
/* harmony export */ });
/* harmony import */ var _shared_utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/utils.mjs */ "./node_modules/swiper/shared/utils.mjs");


/* eslint no-bitwise: ["error", { "allow": [">>"] }] */
function Controller(_ref) {
  let {
    swiper,
    extendParams,
    on
  } = _ref;
  extendParams({
    controller: {
      control: undefined,
      inverse: false,
      by: 'slide' // or 'container'
    }
  });

  swiper.controller = {
    control: undefined
  };
  function LinearSpline(x, y) {
    const binarySearch = function search() {
      let maxIndex;
      let minIndex;
      let guess;
      return (array, val) => {
        minIndex = -1;
        maxIndex = array.length;
        while (maxIndex - minIndex > 1) {
          guess = maxIndex + minIndex >> 1;
          if (array[guess] <= val) {
            minIndex = guess;
          } else {
            maxIndex = guess;
          }
        }
        return maxIndex;
      };
    }();
    this.x = x;
    this.y = y;
    this.lastIndex = x.length - 1;
    // Given an x value (x2), return the expected y2 value:
    // (x1,y1) is the known point before given value,
    // (x3,y3) is the known point after given value.
    let i1;
    let i3;
    this.interpolate = function interpolate(x2) {
      if (!x2) return 0;

      // Get the indexes of x1 and x3 (the array indexes before and after given x2):
      i3 = binarySearch(this.x, x2);
      i1 = i3 - 1;

      // We have our indexes i1 & i3, so we can calculate already:
      // y2 := ((x2−x1) × (y3−y1)) ÷ (x3−x1) + y1
      return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];
    };
    return this;
  }
  function getInterpolateFunction(c) {
    swiper.controller.spline = swiper.params.loop ? new LinearSpline(swiper.slidesGrid, c.slidesGrid) : new LinearSpline(swiper.snapGrid, c.snapGrid);
  }
  function setTranslate(_t, byController) {
    const controlled = swiper.controller.control;
    let multiplier;
    let controlledTranslate;
    const Swiper = swiper.constructor;
    function setControlledTranslate(c) {
      if (c.destroyed) return;

      // this will create an Interpolate function based on the snapGrids
      // x is the Grid of the scrolled scroller and y will be the controlled scroller
      // it makes sense to create this only once and recall it for the interpolation
      // the function does a lot of value caching for performance
      const translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;
      if (swiper.params.controller.by === 'slide') {
        getInterpolateFunction(c);
        // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid
        // but it did not work out
        controlledTranslate = -swiper.controller.spline.interpolate(-translate);
      }
      if (!controlledTranslate || swiper.params.controller.by === 'container') {
        multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());
        if (Number.isNaN(multiplier) || !Number.isFinite(multiplier)) {
          multiplier = 1;
        }
        controlledTranslate = (translate - swiper.minTranslate()) * multiplier + c.minTranslate();
      }
      if (swiper.params.controller.inverse) {
        controlledTranslate = c.maxTranslate() - controlledTranslate;
      }
      c.updateProgress(controlledTranslate);
      c.setTranslate(controlledTranslate, swiper);
      c.updateActiveIndex();
      c.updateSlidesClasses();
    }
    if (Array.isArray(controlled)) {
      for (let i = 0; i < controlled.length; i += 1) {
        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
          setControlledTranslate(controlled[i]);
        }
      }
    } else if (controlled instanceof Swiper && byController !== controlled) {
      setControlledTranslate(controlled);
    }
  }
  function setTransition(duration, byController) {
    const Swiper = swiper.constructor;
    const controlled = swiper.controller.control;
    let i;
    function setControlledTransition(c) {
      if (c.destroyed) return;
      c.setTransition(duration, swiper);
      if (duration !== 0) {
        c.transitionStart();
        if (c.params.autoHeight) {
          (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.n)(() => {
            c.updateAutoHeight();
          });
        }
        (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(c.wrapperEl, () => {
          if (!controlled) return;
          c.transitionEnd();
        });
      }
    }
    if (Array.isArray(controlled)) {
      for (i = 0; i < controlled.length; i += 1) {
        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
          setControlledTransition(controlled[i]);
        }
      }
    } else if (controlled instanceof Swiper && byController !== controlled) {
      setControlledTransition(controlled);
    }
  }
  function removeSpline() {
    if (!swiper.controller.control) return;
    if (swiper.controller.spline) {
      swiper.controller.spline = undefined;
      delete swiper.controller.spline;
    }
  }
  on('beforeInit', () => {
    if (typeof window !== 'undefined' && (
    // eslint-disable-line
    typeof swiper.params.controller.control === 'string' || swiper.params.controller.control instanceof HTMLElement)) {
      const controlElements = typeof swiper.params.controller.control === 'string' ? [...document.querySelectorAll(swiper.params.controller.control)] : [swiper.params.controller.control];
      controlElements.forEach(controlElement => {
        if (!swiper.controller.control) swiper.controller.control = [];
        if (controlElement && controlElement.swiper) {
          swiper.controller.control.push(controlElement.swiper);
        } else if (controlElement) {
          const eventName = `${swiper.params.eventsPrefix}init`;
          const onControllerSwiper = e => {
            swiper.controller.control.push(e.detail[0]);
            swiper.update();
            controlElement.removeEventListener(eventName, onControllerSwiper);
          };
          controlElement.addEventListener(eventName, onControllerSwiper);
        }
      });
      return;
    }
    swiper.controller.control = swiper.params.controller.control;
  });
  on('update', () => {
    removeSpline();
  });
  on('resize', () => {
    removeSpline();
  });
  on('observerUpdate', () => {
    removeSpline();
  });
  on('setTranslate', (_s, translate, byController) => {
    if (!swiper.controller.control || swiper.controller.control.destroyed) return;
    swiper.controller.setTranslate(translate, byController);
  });
  on('setTransition', (_s, duration, byController) => {
    if (!swiper.controller.control || swiper.controller.control.destroyed) return;
    swiper.controller.setTransition(duration, byController);
  });
  Object.assign(swiper.controller, {
    setTranslate,
    setTransition
  });
}




/***/ }),

/***/ "./node_modules/swiper/modules/effect-cards.mjs":
/*!******************************************************!*\
  !*** ./node_modules/swiper/modules/effect-cards.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EffectCards)
/* harmony export */ });
/* harmony import */ var _shared_create_shadow_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/create-shadow.mjs */ "./node_modules/swiper/shared/create-shadow.mjs");
/* harmony import */ var _shared_effect_init_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/effect-init.mjs */ "./node_modules/swiper/shared/effect-init.mjs");
/* harmony import */ var _shared_effect_target_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/effect-target.mjs */ "./node_modules/swiper/shared/effect-target.mjs");
/* harmony import */ var _shared_effect_virtual_transition_end_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/effect-virtual-transition-end.mjs */ "./node_modules/swiper/shared/effect-virtual-transition-end.mjs");
/* harmony import */ var _shared_utils_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shared/utils.mjs */ "./node_modules/swiper/shared/utils.mjs");






function EffectCards(_ref) {
  let {
    swiper,
    extendParams,
    on
  } = _ref;
  extendParams({
    cardsEffect: {
      slideShadows: true,
      rotate: true,
      perSlideRotate: 2,
      perSlideOffset: 8
    }
  });
  const setTranslate = () => {
    const {
      slides,
      activeIndex,
      rtlTranslate: rtl
    } = swiper;
    const params = swiper.params.cardsEffect;
    const {
      startTranslate,
      isTouched
    } = swiper.touchEventsData;
    const currentTranslate = rtl ? -swiper.translate : swiper.translate;
    for (let i = 0; i < slides.length; i += 1) {
      const slideEl = slides[i];
      const slideProgress = slideEl.progress;
      const progress = Math.min(Math.max(slideProgress, -4), 4);
      let offset = slideEl.swiperSlideOffset;
      if (swiper.params.centeredSlides && !swiper.params.cssMode) {
        swiper.wrapperEl.style.transform = `translateX(${swiper.minTranslate()}px)`;
      }
      if (swiper.params.centeredSlides && swiper.params.cssMode) {
        offset -= slides[0].swiperSlideOffset;
      }
      let tX = swiper.params.cssMode ? -offset - swiper.translate : -offset;
      let tY = 0;
      const tZ = -100 * Math.abs(progress);
      let scale = 1;
      let rotate = -params.perSlideRotate * progress;
      let tXAdd = params.perSlideOffset - Math.abs(progress) * 0.75;
      const slideIndex = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.from + i : i;
      const isSwipeToNext = (slideIndex === activeIndex || slideIndex === activeIndex - 1) && progress > 0 && progress < 1 && (isTouched || swiper.params.cssMode) && currentTranslate < startTranslate;
      const isSwipeToPrev = (slideIndex === activeIndex || slideIndex === activeIndex + 1) && progress < 0 && progress > -1 && (isTouched || swiper.params.cssMode) && currentTranslate > startTranslate;
      if (isSwipeToNext || isSwipeToPrev) {
        const subProgress = (1 - Math.abs((Math.abs(progress) - 0.5) / 0.5)) ** 0.5;
        rotate += -28 * progress * subProgress;
        scale += -0.5 * subProgress;
        tXAdd += 96 * subProgress;
        tY = `${-25 * subProgress * Math.abs(progress)}%`;
      }
      if (progress < 0) {
        // next
        tX = `calc(${tX}px ${rtl ? '-' : '+'} (${tXAdd * Math.abs(progress)}%))`;
      } else if (progress > 0) {
        // prev
        tX = `calc(${tX}px ${rtl ? '-' : '+'} (-${tXAdd * Math.abs(progress)}%))`;
      } else {
        tX = `${tX}px`;
      }
      if (!swiper.isHorizontal()) {
        const prevY = tY;
        tY = tX;
        tX = prevY;
      }
      const scaleString = progress < 0 ? `${1 + (1 - scale) * progress}` : `${1 - (1 - scale) * progress}`;

      /* eslint-disable */
      const transform = `
        translate3d(${tX}, ${tY}, ${tZ}px)
        rotateZ(${params.rotate ? rtl ? -rotate : rotate : 0}deg)
        scale(${scaleString})
      `;
      /* eslint-enable */

      if (params.slideShadows) {
        // Set shadows
        let shadowEl = slideEl.querySelector('.swiper-slide-shadow');
        if (!shadowEl) {
          shadowEl = (0,_shared_create_shadow_mjs__WEBPACK_IMPORTED_MODULE_0__.c)('cards', slideEl);
        }
        if (shadowEl) shadowEl.style.opacity = Math.min(Math.max((Math.abs(progress) - 0.5) / 0.5, 0), 1);
      }
      slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;
      const targetEl = (0,_shared_effect_target_mjs__WEBPACK_IMPORTED_MODULE_2__.e)(params, slideEl);
      targetEl.style.transform = transform;
    }
  };
  const setTransition = duration => {
    const transformElements = swiper.slides.map(slideEl => (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_4__.g)(slideEl));
    transformElements.forEach(el => {
      el.style.transitionDuration = `${duration}ms`;
      el.querySelectorAll('.swiper-slide-shadow').forEach(shadowEl => {
        shadowEl.style.transitionDuration = `${duration}ms`;
      });
    });
    (0,_shared_effect_virtual_transition_end_mjs__WEBPACK_IMPORTED_MODULE_3__.e)({
      swiper,
      duration,
      transformElements
    });
  };
  (0,_shared_effect_init_mjs__WEBPACK_IMPORTED_MODULE_1__.e)({
    effect: 'cards',
    swiper,
    on,
    setTranslate,
    setTransition,
    perspective: () => true,
    overwriteParams: () => ({
      watchSlidesProgress: true,
      virtualTranslate: !swiper.params.cssMode
    })
  });
}




/***/ }),

/***/ "./node_modules/swiper/modules/effect-coverflow.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/swiper/modules/effect-coverflow.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EffectCoverflow)
/* harmony export */ });
/* harmony import */ var _shared_create_shadow_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/create-shadow.mjs */ "./node_modules/swiper/shared/create-shadow.mjs");
/* harmony import */ var _shared_effect_init_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/effect-init.mjs */ "./node_modules/swiper/shared/effect-init.mjs");
/* harmony import */ var _shared_effect_target_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/effect-target.mjs */ "./node_modules/swiper/shared/effect-target.mjs");
/* harmony import */ var _shared_utils_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/utils.mjs */ "./node_modules/swiper/shared/utils.mjs");





function EffectCoverflow(_ref) {
  let {
    swiper,
    extendParams,
    on
  } = _ref;
  extendParams({
    coverflowEffect: {
      rotate: 50,
      stretch: 0,
      depth: 100,
      scale: 1,
      modifier: 1,
      slideShadows: true
    }
  });
  const setTranslate = () => {
    const {
      width: swiperWidth,
      height: swiperHeight,
      slides,
      slidesSizesGrid
    } = swiper;
    const params = swiper.params.coverflowEffect;
    const isHorizontal = swiper.isHorizontal();
    const transform = swiper.translate;
    const center = isHorizontal ? -transform + swiperWidth / 2 : -transform + swiperHeight / 2;
    const rotate = isHorizontal ? params.rotate : -params.rotate;
    const translate = params.depth;
    const r = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_3__.o)(swiper);
    // Each slide offset from center
    for (let i = 0, length = slides.length; i < length; i += 1) {
      const slideEl = slides[i];
      const slideSize = slidesSizesGrid[i];
      const slideOffset = slideEl.swiperSlideOffset;
      const centerOffset = (center - slideOffset - slideSize / 2) / slideSize;
      const offsetMultiplier = typeof params.modifier === 'function' ? params.modifier(centerOffset) : centerOffset * params.modifier;
      let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;
      let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;
      // var rotateZ = 0
      let translateZ = -translate * Math.abs(offsetMultiplier);
      let stretch = params.stretch;
      // Allow percentage to make a relative stretch for responsive sliders
      if (typeof stretch === 'string' && stretch.indexOf('%') !== -1) {
        stretch = parseFloat(params.stretch) / 100 * slideSize;
      }
      let translateY = isHorizontal ? 0 : stretch * offsetMultiplier;
      let translateX = isHorizontal ? stretch * offsetMultiplier : 0;
      let scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier);

      // Fix for ultra small values
      if (Math.abs(translateX) < 0.001) translateX = 0;
      if (Math.abs(translateY) < 0.001) translateY = 0;
      if (Math.abs(translateZ) < 0.001) translateZ = 0;
      if (Math.abs(rotateY) < 0.001) rotateY = 0;
      if (Math.abs(rotateX) < 0.001) rotateX = 0;
      if (Math.abs(scale) < 0.001) scale = 0;
      const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${r(rotateX)}deg) rotateY(${r(rotateY)}deg) scale(${scale})`;
      const targetEl = (0,_shared_effect_target_mjs__WEBPACK_IMPORTED_MODULE_2__.e)(params, slideEl);
      targetEl.style.transform = slideTransform;
      slideEl.style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;
      if (params.slideShadows) {
        // Set shadows
        let shadowBeforeEl = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-left') : slideEl.querySelector('.swiper-slide-shadow-top');
        let shadowAfterEl = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-right') : slideEl.querySelector('.swiper-slide-shadow-bottom');
        if (!shadowBeforeEl) {
          shadowBeforeEl = (0,_shared_create_shadow_mjs__WEBPACK_IMPORTED_MODULE_0__.c)('coverflow', slideEl, isHorizontal ? 'left' : 'top');
        }
        if (!shadowAfterEl) {
          shadowAfterEl = (0,_shared_create_shadow_mjs__WEBPACK_IMPORTED_MODULE_0__.c)('coverflow', slideEl, isHorizontal ? 'right' : 'bottom');
        }
        if (shadowBeforeEl) shadowBeforeEl.style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
        if (shadowAfterEl) shadowAfterEl.style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;
      }
    }
  };
  const setTransition = duration => {
    const transformElements = swiper.slides.map(slideEl => (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_3__.g)(slideEl));
    transformElements.forEach(el => {
      el.style.transitionDuration = `${duration}ms`;
      el.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(shadowEl => {
        shadowEl.style.transitionDuration = `${duration}ms`;
      });
    });
  };
  (0,_shared_effect_init_mjs__WEBPACK_IMPORTED_MODULE_1__.e)({
    effect: 'coverflow',
    swiper,
    on,
    setTranslate,
    setTransition,
    perspective: () => true,
    overwriteParams: () => ({
      watchSlidesProgress: true
    })
  });
}




/***/ }),

/***/ "./node_modules/swiper/modules/effect-creative.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/swiper/modules/effect-creative.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EffectCreative)
/* harmony export */ });
/* harmony import */ var _shared_create_shadow_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/create-shadow.mjs */ "./node_modules/swiper/shared/create-shadow.mjs");
/* harmony import */ var _shared_effect_init_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/effect-init.mjs */ "./node_modules/swiper/shared/effect-init.mjs");
/* harmony import */ var _shared_effect_target_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/effect-target.mjs */ "./node_modules/swiper/shared/effect-target.mjs");
/* harmony import */ var _shared_effect_virtual_transition_end_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/effect-virtual-transition-end.mjs */ "./node_modules/swiper/shared/effect-virtual-transition-end.mjs");
/* harmony import */ var _shared_utils_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shared/utils.mjs */ "./node_modules/swiper/shared/utils.mjs");






function EffectCreative(_ref) {
  let {
    swiper,
    extendParams,
    on
  } = _ref;
  extendParams({
    creativeEffect: {
      limitProgress: 1,
      shadowPerProgress: false,
      progressMultiplier: 1,
      perspective: true,
      prev: {
        translate: [0, 0, 0],
        rotate: [0, 0, 0],
        opacity: 1,
        scale: 1
      },
      next: {
        translate: [0, 0, 0],
        rotate: [0, 0, 0],
        opacity: 1,
        scale: 1
      }
    }
  });
  const getTranslateValue = value => {
    if (typeof value === 'string') return value;
    return `${value}px`;
  };
  const setTranslate = () => {
    const {
      slides,
      wrapperEl,
      slidesSizesGrid
    } = swiper;
    const params = swiper.params.creativeEffect;
    const {
      progressMultiplier: multiplier
    } = params;
    const isCenteredSlides = swiper.params.centeredSlides;
    const rotateFix = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_4__.o)(swiper);
    if (isCenteredSlides) {
      const margin = slidesSizesGrid[0] / 2 - swiper.params.slidesOffsetBefore || 0;
      wrapperEl.style.transform = `translateX(calc(50% - ${margin}px))`;
    }
    for (let i = 0; i < slides.length; i += 1) {
      const slideEl = slides[i];
      const slideProgress = slideEl.progress;
      const progress = Math.min(Math.max(slideEl.progress, -params.limitProgress), params.limitProgress);
      let originalProgress = progress;
      if (!isCenteredSlides) {
        originalProgress = Math.min(Math.max(slideEl.originalProgress, -params.limitProgress), params.limitProgress);
      }
      const offset = slideEl.swiperSlideOffset;
      const t = [swiper.params.cssMode ? -offset - swiper.translate : -offset, 0, 0];
      const r = [0, 0, 0];
      let custom = false;
      if (!swiper.isHorizontal()) {
        t[1] = t[0];
        t[0] = 0;
      }
      let data = {
        translate: [0, 0, 0],
        rotate: [0, 0, 0],
        scale: 1,
        opacity: 1
      };
      if (progress < 0) {
        data = params.next;
        custom = true;
      } else if (progress > 0) {
        data = params.prev;
        custom = true;
      }
      // set translate
      t.forEach((value, index) => {
        t[index] = `calc(${value}px + (${getTranslateValue(data.translate[index])} * ${Math.abs(progress * multiplier)}))`;
      });
      // set rotates
      r.forEach((value, index) => {
        let val = data.rotate[index] * Math.abs(progress * multiplier);
        r[index] = val;
      });
      slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;
      const translateString = t.join(', ');
      const rotateString = `rotateX(${rotateFix(r[0])}deg) rotateY(${rotateFix(r[1])}deg) rotateZ(${rotateFix(r[2])}deg)`;
      const scaleString = originalProgress < 0 ? `scale(${1 + (1 - data.scale) * originalProgress * multiplier})` : `scale(${1 - (1 - data.scale) * originalProgress * multiplier})`;
      const opacityString = originalProgress < 0 ? 1 + (1 - data.opacity) * originalProgress * multiplier : 1 - (1 - data.opacity) * originalProgress * multiplier;
      const transform = `translate3d(${translateString}) ${rotateString} ${scaleString}`;

      // Set shadows
      if (custom && data.shadow || !custom) {
        let shadowEl = slideEl.querySelector('.swiper-slide-shadow');
        if (!shadowEl && data.shadow) {
          shadowEl = (0,_shared_create_shadow_mjs__WEBPACK_IMPORTED_MODULE_0__.c)('creative', slideEl);
        }
        if (shadowEl) {
          const shadowOpacity = params.shadowPerProgress ? progress * (1 / params.limitProgress) : progress;
          shadowEl.style.opacity = Math.min(Math.max(Math.abs(shadowOpacity), 0), 1);
        }
      }
      const targetEl = (0,_shared_effect_target_mjs__WEBPACK_IMPORTED_MODULE_2__.e)(params, slideEl);
      targetEl.style.transform = transform;
      targetEl.style.opacity = opacityString;
      if (data.origin) {
        targetEl.style.transformOrigin = data.origin;
      }
    }
  };
  const setTransition = duration => {
    const transformElements = swiper.slides.map(slideEl => (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_4__.g)(slideEl));
    transformElements.forEach(el => {
      el.style.transitionDuration = `${duration}ms`;
      el.querySelectorAll('.swiper-slide-shadow').forEach(shadowEl => {
        shadowEl.style.transitionDuration = `${duration}ms`;
      });
    });
    (0,_shared_effect_virtual_transition_end_mjs__WEBPACK_IMPORTED_MODULE_3__.e)({
      swiper,
      duration,
      transformElements,
      allSlides: true
    });
  };
  (0,_shared_effect_init_mjs__WEBPACK_IMPORTED_MODULE_1__.e)({
    effect: 'creative',
    swiper,
    on,
    setTranslate,
    setTransition,
    perspective: () => swiper.params.creativeEffect.perspective,
    overwriteParams: () => ({
      watchSlidesProgress: true,
      virtualTranslate: !swiper.params.cssMode
    })
  });
}




/***/ }),

/***/ "./node_modules/swiper/modules/effect-cube.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/swiper/modules/effect-cube.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EffectCube)
/* harmony export */ });
/* harmony import */ var _shared_effect_init_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/effect-init.mjs */ "./node_modules/swiper/shared/effect-init.mjs");
/* harmony import */ var _shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.mjs */ "./node_modules/swiper/shared/utils.mjs");



function EffectCube(_ref) {
  let {
    swiper,
    extendParams,
    on
  } = _ref;
  extendParams({
    cubeEffect: {
      slideShadows: true,
      shadow: true,
      shadowOffset: 20,
      shadowScale: 0.94
    }
  });
  const createSlideShadows = (slideEl, progress, isHorizontal) => {
    let shadowBefore = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-left') : slideEl.querySelector('.swiper-slide-shadow-top');
    let shadowAfter = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-right') : slideEl.querySelector('.swiper-slide-shadow-bottom');
    if (!shadowBefore) {
      shadowBefore = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.c)('div', `swiper-slide-shadow-cube swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}`.split(' '));
      slideEl.append(shadowBefore);
    }
    if (!shadowAfter) {
      shadowAfter = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.c)('div', `swiper-slide-shadow-cube swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}`.split(' '));
      slideEl.append(shadowAfter);
    }
    if (shadowBefore) shadowBefore.style.opacity = Math.max(-progress, 0);
    if (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0);
  };
  const recreateShadows = () => {
    // create new ones
    const isHorizontal = swiper.isHorizontal();
    swiper.slides.forEach(slideEl => {
      const progress = Math.max(Math.min(slideEl.progress, 1), -1);
      createSlideShadows(slideEl, progress, isHorizontal);
    });
  };
  const setTranslate = () => {
    const {
      el,
      wrapperEl,
      slides,
      width: swiperWidth,
      height: swiperHeight,
      rtlTranslate: rtl,
      size: swiperSize,
      browser
    } = swiper;
    const r = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.o)(swiper);
    const params = swiper.params.cubeEffect;
    const isHorizontal = swiper.isHorizontal();
    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    let wrapperRotate = 0;
    let cubeShadowEl;
    if (params.shadow) {
      if (isHorizontal) {
        cubeShadowEl = swiper.wrapperEl.querySelector('.swiper-cube-shadow');
        if (!cubeShadowEl) {
          cubeShadowEl = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.c)('div', 'swiper-cube-shadow');
          swiper.wrapperEl.append(cubeShadowEl);
        }
        cubeShadowEl.style.height = `${swiperWidth}px`;
      } else {
        cubeShadowEl = el.querySelector('.swiper-cube-shadow');
        if (!cubeShadowEl) {
          cubeShadowEl = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.c)('div', 'swiper-cube-shadow');
          el.append(cubeShadowEl);
        }
      }
    }
    for (let i = 0; i < slides.length; i += 1) {
      const slideEl = slides[i];
      let slideIndex = i;
      if (isVirtual) {
        slideIndex = parseInt(slideEl.getAttribute('data-swiper-slide-index'), 10);
      }
      let slideAngle = slideIndex * 90;
      let round = Math.floor(slideAngle / 360);
      if (rtl) {
        slideAngle = -slideAngle;
        round = Math.floor(-slideAngle / 360);
      }
      const progress = Math.max(Math.min(slideEl.progress, 1), -1);
      let tx = 0;
      let ty = 0;
      let tz = 0;
      if (slideIndex % 4 === 0) {
        tx = -round * 4 * swiperSize;
        tz = 0;
      } else if ((slideIndex - 1) % 4 === 0) {
        tx = 0;
        tz = -round * 4 * swiperSize;
      } else if ((slideIndex - 2) % 4 === 0) {
        tx = swiperSize + round * 4 * swiperSize;
        tz = swiperSize;
      } else if ((slideIndex - 3) % 4 === 0) {
        tx = -swiperSize;
        tz = 3 * swiperSize + swiperSize * 4 * round;
      }
      if (rtl) {
        tx = -tx;
      }
      if (!isHorizontal) {
        ty = tx;
        tx = 0;
      }
      const transform = `rotateX(${r(isHorizontal ? 0 : -slideAngle)}deg) rotateY(${r(isHorizontal ? slideAngle : 0)}deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;
      if (progress <= 1 && progress > -1) {
        wrapperRotate = slideIndex * 90 + progress * 90;
        if (rtl) wrapperRotate = -slideIndex * 90 - progress * 90;
      }
      slideEl.style.transform = transform;
      if (params.slideShadows) {
        createSlideShadows(slideEl, progress, isHorizontal);
      }
    }
    wrapperEl.style.transformOrigin = `50% 50% -${swiperSize / 2}px`;
    wrapperEl.style['-webkit-transform-origin'] = `50% 50% -${swiperSize / 2}px`;
    if (params.shadow) {
      if (isHorizontal) {
        cubeShadowEl.style.transform = `translate3d(0px, ${swiperWidth / 2 + params.shadowOffset}px, ${-swiperWidth / 2}px) rotateX(89.99deg) rotateZ(0deg) scale(${params.shadowScale})`;
      } else {
        const shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;
        const multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);
        const scale1 = params.shadowScale;
        const scale2 = params.shadowScale / multiplier;
        const offset = params.shadowOffset;
        cubeShadowEl.style.transform = `scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${swiperHeight / 2 + offset}px, ${-swiperHeight / 2 / scale2}px) rotateX(-89.99deg)`;
      }
    }
    const zFactor = (browser.isSafari || browser.isWebView) && browser.needPerspectiveFix ? -swiperSize / 2 : 0;
    wrapperEl.style.transform = `translate3d(0px,0,${zFactor}px) rotateX(${r(swiper.isHorizontal() ? 0 : wrapperRotate)}deg) rotateY(${r(swiper.isHorizontal() ? -wrapperRotate : 0)}deg)`;
    wrapperEl.style.setProperty('--swiper-cube-translate-z', `${zFactor}px`);
  };
  const setTransition = duration => {
    const {
      el,
      slides
    } = swiper;
    slides.forEach(slideEl => {
      slideEl.style.transitionDuration = `${duration}ms`;
      slideEl.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(subEl => {
        subEl.style.transitionDuration = `${duration}ms`;
      });
    });
    if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
      const shadowEl = el.querySelector('.swiper-cube-shadow');
      if (shadowEl) shadowEl.style.transitionDuration = `${duration}ms`;
    }
  };
  (0,_shared_effect_init_mjs__WEBPACK_IMPORTED_MODULE_0__.e)({
    effect: 'cube',
    swiper,
    on,
    setTranslate,
    setTransition,
    recreateShadows,
    getEffectParams: () => swiper.params.cubeEffect,
    perspective: () => true,
    overwriteParams: () => ({
      slidesPerView: 1,
      slidesPerGroup: 1,
      watchSlidesProgress: true,
      resistanceRatio: 0,
      spaceBetween: 0,
      centeredSlides: false,
      virtualTranslate: true
    })
  });
}




/***/ }),

/***/ "./node_modules/swiper/modules/effect-fade.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/swiper/modules/effect-fade.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EffectFade)
/* harmony export */ });
/* harmony import */ var _shared_effect_init_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/effect-init.mjs */ "./node_modules/swiper/shared/effect-init.mjs");
/* harmony import */ var _shared_effect_target_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/effect-target.mjs */ "./node_modules/swiper/shared/effect-target.mjs");
/* harmony import */ var _shared_effect_virtual_transition_end_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/effect-virtual-transition-end.mjs */ "./node_modules/swiper/shared/effect-virtual-transition-end.mjs");
/* harmony import */ var _shared_utils_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/utils.mjs */ "./node_modules/swiper/shared/utils.mjs");





function EffectFade(_ref) {
  let {
    swiper,
    extendParams,
    on
  } = _ref;
  extendParams({
    fadeEffect: {
      crossFade: false
    }
  });
  const setTranslate = () => {
    const {
      slides
    } = swiper;
    const params = swiper.params.fadeEffect;
    for (let i = 0; i < slides.length; i += 1) {
      const slideEl = swiper.slides[i];
      const offset = slideEl.swiperSlideOffset;
      let tx = -offset;
      if (!swiper.params.virtualTranslate) tx -= swiper.translate;
      let ty = 0;
      if (!swiper.isHorizontal()) {
        ty = tx;
        tx = 0;
      }
      const slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(slideEl.progress), 0) : 1 + Math.min(Math.max(slideEl.progress, -1), 0);
      const targetEl = (0,_shared_effect_target_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(params, slideEl);
      targetEl.style.opacity = slideOpacity;
      targetEl.style.transform = `translate3d(${tx}px, ${ty}px, 0px)`;
    }
  };
  const setTransition = duration => {
    const transformElements = swiper.slides.map(slideEl => (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_3__.g)(slideEl));
    transformElements.forEach(el => {
      el.style.transitionDuration = `${duration}ms`;
    });
    (0,_shared_effect_virtual_transition_end_mjs__WEBPACK_IMPORTED_MODULE_2__.e)({
      swiper,
      duration,
      transformElements,
      allSlides: true
    });
  };
  (0,_shared_effect_init_mjs__WEBPACK_IMPORTED_MODULE_0__.e)({
    effect: 'fade',
    swiper,
    on,
    setTranslate,
    setTransition,
    overwriteParams: () => ({
      slidesPerView: 1,
      slidesPerGroup: 1,
      watchSlidesProgress: true,
      spaceBetween: 0,
      virtualTranslate: !swiper.params.cssMode
    })
  });
}




/***/ }),

/***/ "./node_modules/swiper/modules/effect-flip.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/swiper/modules/effect-flip.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EffectFlip)
/* harmony export */ });
/* harmony import */ var _shared_create_shadow_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/create-shadow.mjs */ "./node_modules/swiper/shared/create-shadow.mjs");
/* harmony import */ var _shared_effect_init_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/effect-init.mjs */ "./node_modules/swiper/shared/effect-init.mjs");
/* harmony import */ var _shared_effect_target_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/effect-target.mjs */ "./node_modules/swiper/shared/effect-target.mjs");
/* harmony import */ var _shared_effect_virtual_transition_end_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/effect-virtual-transition-end.mjs */ "./node_modules/swiper/shared/effect-virtual-transition-end.mjs");
/* harmony import */ var _shared_utils_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shared/utils.mjs */ "./node_modules/swiper/shared/utils.mjs");






function EffectFlip(_ref) {
  let {
    swiper,
    extendParams,
    on
  } = _ref;
  extendParams({
    flipEffect: {
      slideShadows: true,
      limitRotation: true
    }
  });
  const createSlideShadows = (slideEl, progress) => {
    let shadowBefore = swiper.isHorizontal() ? slideEl.querySelector('.swiper-slide-shadow-left') : slideEl.querySelector('.swiper-slide-shadow-top');
    let shadowAfter = swiper.isHorizontal() ? slideEl.querySelector('.swiper-slide-shadow-right') : slideEl.querySelector('.swiper-slide-shadow-bottom');
    if (!shadowBefore) {
      shadowBefore = (0,_shared_create_shadow_mjs__WEBPACK_IMPORTED_MODULE_0__.c)('flip', slideEl, swiper.isHorizontal() ? 'left' : 'top');
    }
    if (!shadowAfter) {
      shadowAfter = (0,_shared_create_shadow_mjs__WEBPACK_IMPORTED_MODULE_0__.c)('flip', slideEl, swiper.isHorizontal() ? 'right' : 'bottom');
    }
    if (shadowBefore) shadowBefore.style.opacity = Math.max(-progress, 0);
    if (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0);
  };
  const recreateShadows = () => {
    // Set shadows
    swiper.params.flipEffect;
    swiper.slides.forEach(slideEl => {
      let progress = slideEl.progress;
      if (swiper.params.flipEffect.limitRotation) {
        progress = Math.max(Math.min(slideEl.progress, 1), -1);
      }
      createSlideShadows(slideEl, progress);
    });
  };
  const setTranslate = () => {
    const {
      slides,
      rtlTranslate: rtl
    } = swiper;
    const params = swiper.params.flipEffect;
    const rotateFix = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_4__.o)(swiper);
    for (let i = 0; i < slides.length; i += 1) {
      const slideEl = slides[i];
      let progress = slideEl.progress;
      if (swiper.params.flipEffect.limitRotation) {
        progress = Math.max(Math.min(slideEl.progress, 1), -1);
      }
      const offset = slideEl.swiperSlideOffset;
      const rotate = -180 * progress;
      let rotateY = rotate;
      let rotateX = 0;
      let tx = swiper.params.cssMode ? -offset - swiper.translate : -offset;
      let ty = 0;
      if (!swiper.isHorizontal()) {
        ty = tx;
        tx = 0;
        rotateX = -rotateY;
        rotateY = 0;
      } else if (rtl) {
        rotateY = -rotateY;
      }
      slideEl.style.zIndex = -Math.abs(Math.round(progress)) + slides.length;
      if (params.slideShadows) {
        createSlideShadows(slideEl, progress);
      }
      const transform = `translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateFix(rotateX)}deg) rotateY(${rotateFix(rotateY)}deg)`;
      const targetEl = (0,_shared_effect_target_mjs__WEBPACK_IMPORTED_MODULE_2__.e)(params, slideEl);
      targetEl.style.transform = transform;
    }
  };
  const setTransition = duration => {
    const transformElements = swiper.slides.map(slideEl => (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_4__.g)(slideEl));
    transformElements.forEach(el => {
      el.style.transitionDuration = `${duration}ms`;
      el.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(shadowEl => {
        shadowEl.style.transitionDuration = `${duration}ms`;
      });
    });
    (0,_shared_effect_virtual_transition_end_mjs__WEBPACK_IMPORTED_MODULE_3__.e)({
      swiper,
      duration,
      transformElements
    });
  };
  (0,_shared_effect_init_mjs__WEBPACK_IMPORTED_MODULE_1__.e)({
    effect: 'flip',
    swiper,
    on,
    setTranslate,
    setTransition,
    recreateShadows,
    getEffectParams: () => swiper.params.flipEffect,
    perspective: () => true,
    overwriteParams: () => ({
      slidesPerView: 1,
      slidesPerGroup: 1,
      watchSlidesProgress: true,
      spaceBetween: 0,
      virtualTranslate: !swiper.params.cssMode
    })
  });
}




/***/ }),

/***/ "./node_modules/swiper/modules/free-mode.mjs":
/*!***************************************************!*\
  !*** ./node_modules/swiper/modules/free-mode.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ freeMode)
/* harmony export */ });
/* harmony import */ var _shared_utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/utils.mjs */ "./node_modules/swiper/shared/utils.mjs");


function freeMode(_ref) {
  let {
    swiper,
    extendParams,
    emit,
    once
  } = _ref;
  extendParams({
    freeMode: {
      enabled: false,
      momentum: true,
      momentumRatio: 1,
      momentumBounce: true,
      momentumBounceRatio: 1,
      momentumVelocityRatio: 1,
      sticky: false,
      minimumVelocity: 0.02
    }
  });
  function onTouchStart() {
    if (swiper.params.cssMode) return;
    const translate = swiper.getTranslate();
    swiper.setTranslate(translate);
    swiper.setTransition(0);
    swiper.touchEventsData.velocities.length = 0;
    swiper.freeMode.onTouchEnd({
      currentPos: swiper.rtl ? swiper.translate : -swiper.translate
    });
  }
  function onTouchMove() {
    if (swiper.params.cssMode) return;
    const {
      touchEventsData: data,
      touches
    } = swiper;
    // Velocity
    if (data.velocities.length === 0) {
      data.velocities.push({
        position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],
        time: data.touchStartTime
      });
    }
    data.velocities.push({
      position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],
      time: (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.d)()
    });
  }
  function onTouchEnd(_ref2) {
    let {
      currentPos
    } = _ref2;
    if (swiper.params.cssMode) return;
    const {
      params,
      wrapperEl,
      rtlTranslate: rtl,
      snapGrid,
      touchEventsData: data
    } = swiper;
    // Time diff
    const touchEndTime = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.d)();
    const timeDiff = touchEndTime - data.touchStartTime;
    if (currentPos < -swiper.minTranslate()) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    if (currentPos > -swiper.maxTranslate()) {
      if (swiper.slides.length < snapGrid.length) {
        swiper.slideTo(snapGrid.length - 1);
      } else {
        swiper.slideTo(swiper.slides.length - 1);
      }
      return;
    }
    if (params.freeMode.momentum) {
      if (data.velocities.length > 1) {
        const lastMoveEvent = data.velocities.pop();
        const velocityEvent = data.velocities.pop();
        const distance = lastMoveEvent.position - velocityEvent.position;
        const time = lastMoveEvent.time - velocityEvent.time;
        swiper.velocity = distance / time;
        swiper.velocity /= 2;
        if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {
          swiper.velocity = 0;
        }
        // this implies that the user stopped moving a finger then released.
        // There would be no events with distance zero, so the last event is stale.
        if (time > 150 || (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.d)() - lastMoveEvent.time > 300) {
          swiper.velocity = 0;
        }
      } else {
        swiper.velocity = 0;
      }
      swiper.velocity *= params.freeMode.momentumVelocityRatio;
      data.velocities.length = 0;
      let momentumDuration = 1000 * params.freeMode.momentumRatio;
      const momentumDistance = swiper.velocity * momentumDuration;
      let newPosition = swiper.translate + momentumDistance;
      if (rtl) newPosition = -newPosition;
      let doBounce = false;
      let afterBouncePosition;
      const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;
      let needsLoopFix;
      if (newPosition < swiper.maxTranslate()) {
        if (params.freeMode.momentumBounce) {
          if (newPosition + swiper.maxTranslate() < -bounceAmount) {
            newPosition = swiper.maxTranslate() - bounceAmount;
          }
          afterBouncePosition = swiper.maxTranslate();
          doBounce = true;
          data.allowMomentumBounce = true;
        } else {
          newPosition = swiper.maxTranslate();
        }
        if (params.loop && params.centeredSlides) needsLoopFix = true;
      } else if (newPosition > swiper.minTranslate()) {
        if (params.freeMode.momentumBounce) {
          if (newPosition - swiper.minTranslate() > bounceAmount) {
            newPosition = swiper.minTranslate() + bounceAmount;
          }
          afterBouncePosition = swiper.minTranslate();
          doBounce = true;
          data.allowMomentumBounce = true;
        } else {
          newPosition = swiper.minTranslate();
        }
        if (params.loop && params.centeredSlides) needsLoopFix = true;
      } else if (params.freeMode.sticky) {
        let nextSlide;
        for (let j = 0; j < snapGrid.length; j += 1) {
          if (snapGrid[j] > -newPosition) {
            nextSlide = j;
            break;
          }
        }
        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {
          newPosition = snapGrid[nextSlide];
        } else {
          newPosition = snapGrid[nextSlide - 1];
        }
        newPosition = -newPosition;
      }
      if (needsLoopFix) {
        once('transitionEnd', () => {
          swiper.loopFix();
        });
      }
      // Fix duration
      if (swiper.velocity !== 0) {
        if (rtl) {
          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
        } else {
          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
        }
        if (params.freeMode.sticky) {
          // If freeMode.sticky is active and the user ends a swipe with a slow-velocity
          // event, then durations can be 20+ seconds to slide one (or zero!) slides.
          // It's easy to see this when simulating touch with mouse events. To fix this,
          // limit single-slide swipes to the default slide duration. This also has the
          // nice side effect of matching slide speed if the user stopped moving before
          // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.
          // For faster swipes, also apply limits (albeit higher ones).
          const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);
          const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];
          if (moveDistance < currentSlideSize) {
            momentumDuration = params.speed;
          } else if (moveDistance < 2 * currentSlideSize) {
            momentumDuration = params.speed * 1.5;
          } else {
            momentumDuration = params.speed * 2.5;
          }
        }
      } else if (params.freeMode.sticky) {
        swiper.slideToClosest();
        return;
      }
      if (params.freeMode.momentumBounce && doBounce) {
        swiper.updateProgress(afterBouncePosition);
        swiper.setTransition(momentumDuration);
        swiper.setTranslate(newPosition);
        swiper.transitionStart(true, swiper.swipeDirection);
        swiper.animating = true;
        (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(wrapperEl, () => {
          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;
          emit('momentumBounce');
          swiper.setTransition(params.speed);
          setTimeout(() => {
            swiper.setTranslate(afterBouncePosition);
            (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(wrapperEl, () => {
              if (!swiper || swiper.destroyed) return;
              swiper.transitionEnd();
            });
          }, 0);
        });
      } else if (swiper.velocity) {
        emit('_freeModeNoMomentumRelease');
        swiper.updateProgress(newPosition);
        swiper.setTransition(momentumDuration);
        swiper.setTranslate(newPosition);
        swiper.transitionStart(true, swiper.swipeDirection);
        if (!swiper.animating) {
          swiper.animating = true;
          (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(wrapperEl, () => {
            if (!swiper || swiper.destroyed) return;
            swiper.transitionEnd();
          });
        }
      } else {
        swiper.updateProgress(newPosition);
      }
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    } else if (params.freeMode.sticky) {
      swiper.slideToClosest();
      return;
    } else if (params.freeMode) {
      emit('_freeModeNoMomentumRelease');
    }
    if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {
      emit('_freeModeStaticRelease');
      swiper.updateProgress();
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
  }
  Object.assign(swiper, {
    freeMode: {
      onTouchStart,
      onTouchMove,
      onTouchEnd
    }
  });
}




/***/ }),

/***/ "./node_modules/swiper/modules/grid.mjs":
/*!**********************************************!*\
  !*** ./node_modules/swiper/modules/grid.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Grid)
/* harmony export */ });
function Grid(_ref) {
  let {
    swiper,
    extendParams,
    on
  } = _ref;
  extendParams({
    grid: {
      rows: 1,
      fill: 'column'
    }
  });
  let slidesNumberEvenToRows;
  let slidesPerRow;
  let numFullColumns;
  let wasMultiRow;
  const getSpaceBetween = () => {
    let spaceBetween = swiper.params.spaceBetween;
    if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
      spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiper.size;
    } else if (typeof spaceBetween === 'string') {
      spaceBetween = parseFloat(spaceBetween);
    }
    return spaceBetween;
  };
  const initSlides = slides => {
    const {
      slidesPerView
    } = swiper.params;
    const {
      rows,
      fill
    } = swiper.params.grid;
    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : slides.length;
    numFullColumns = Math.floor(slidesLength / rows);
    if (Math.floor(slidesLength / rows) === slidesLength / rows) {
      slidesNumberEvenToRows = slidesLength;
    } else {
      slidesNumberEvenToRows = Math.ceil(slidesLength / rows) * rows;
    }
    if (slidesPerView !== 'auto' && fill === 'row') {
      slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, slidesPerView * rows);
    }
    slidesPerRow = slidesNumberEvenToRows / rows;
  };
  const unsetSlides = () => {
    if (swiper.slides) {
      swiper.slides.forEach(slide => {
        if (slide.swiperSlideGridSet) {
          slide.style.height = '';
          slide.style[swiper.getDirectionLabel('margin-top')] = '';
        }
      });
    }
  };
  const updateSlide = (i, slide, slides) => {
    const {
      slidesPerGroup
    } = swiper.params;
    const spaceBetween = getSpaceBetween();
    const {
      rows,
      fill
    } = swiper.params.grid;
    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : slides.length;
    // Set slides order
    let newSlideOrderIndex;
    let column;
    let row;
    if (fill === 'row' && slidesPerGroup > 1) {
      const groupIndex = Math.floor(i / (slidesPerGroup * rows));
      const slideIndexInGroup = i - rows * slidesPerGroup * groupIndex;
      const columnsInGroup = groupIndex === 0 ? slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * rows * slidesPerGroup) / rows), slidesPerGroup);
      row = Math.floor(slideIndexInGroup / columnsInGroup);
      column = slideIndexInGroup - row * columnsInGroup + groupIndex * slidesPerGroup;
      newSlideOrderIndex = column + row * slidesNumberEvenToRows / rows;
      slide.style.order = newSlideOrderIndex;
    } else if (fill === 'column') {
      column = Math.floor(i / rows);
      row = i - column * rows;
      if (column > numFullColumns || column === numFullColumns && row === rows - 1) {
        row += 1;
        if (row >= rows) {
          row = 0;
          column += 1;
        }
      }
    } else {
      row = Math.floor(i / slidesPerRow);
      column = i - row * slidesPerRow;
    }
    slide.row = row;
    slide.column = column;
    slide.style.height = `calc((100% - ${(rows - 1) * spaceBetween}px) / ${rows})`;
    slide.style[swiper.getDirectionLabel('margin-top')] = row !== 0 ? spaceBetween && `${spaceBetween}px` : '';
    slide.swiperSlideGridSet = true;
  };
  const updateWrapperSize = (slideSize, snapGrid) => {
    const {
      centeredSlides,
      roundLengths
    } = swiper.params;
    const spaceBetween = getSpaceBetween();
    const {
      rows
    } = swiper.params.grid;
    swiper.virtualSize = (slideSize + spaceBetween) * slidesNumberEvenToRows;
    swiper.virtualSize = Math.ceil(swiper.virtualSize / rows) - spaceBetween;
    if (!swiper.params.cssMode) {
      swiper.wrapperEl.style[swiper.getDirectionLabel('width')] = `${swiper.virtualSize + spaceBetween}px`;
    }
    if (centeredSlides) {
      const newSlidesGrid = [];
      for (let i = 0; i < snapGrid.length; i += 1) {
        let slidesGridItem = snapGrid[i];
        if (roundLengths) slidesGridItem = Math.floor(slidesGridItem);
        if (snapGrid[i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);
      }
      snapGrid.splice(0, snapGrid.length);
      snapGrid.push(...newSlidesGrid);
    }
  };
  const onInit = () => {
    wasMultiRow = swiper.params.grid && swiper.params.grid.rows > 1;
  };
  const onUpdate = () => {
    const {
      params,
      el
    } = swiper;
    const isMultiRow = params.grid && params.grid.rows > 1;
    if (wasMultiRow && !isMultiRow) {
      el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);
      numFullColumns = 1;
      swiper.emitContainerClasses();
    } else if (!wasMultiRow && isMultiRow) {
      el.classList.add(`${params.containerModifierClass}grid`);
      if (params.grid.fill === 'column') {
        el.classList.add(`${params.containerModifierClass}grid-column`);
      }
      swiper.emitContainerClasses();
    }
    wasMultiRow = isMultiRow;
  };
  on('init', onInit);
  on('update', onUpdate);
  swiper.grid = {
    initSlides,
    unsetSlides,
    updateSlide,
    updateWrapperSize
  };
}




/***/ }),

/***/ "./node_modules/swiper/modules/hash-navigation.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/swiper/modules/hash-navigation.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ HashNavigation)
/* harmony export */ });
/* harmony import */ var _shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/ssr-window.esm.mjs */ "./node_modules/swiper/shared/ssr-window.esm.mjs");
/* harmony import */ var _shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.mjs */ "./node_modules/swiper/shared/utils.mjs");



function HashNavigation(_ref) {
  let {
    swiper,
    extendParams,
    emit,
    on
  } = _ref;
  let initialized = false;
  const document = (0,_shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();
  const window = (0,_shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();
  extendParams({
    hashNavigation: {
      enabled: false,
      replaceState: false,
      watchState: false,
      getSlideIndex(_s, hash) {
        if (swiper.virtual && swiper.params.virtual.enabled) {
          const slideWithHash = swiper.slides.filter(slideEl => slideEl.getAttribute('data-hash') === hash)[0];
          if (!slideWithHash) return 0;
          const index = parseInt(slideWithHash.getAttribute('data-swiper-slide-index'), 10);
          return index;
        }
        return swiper.getSlideIndex((0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(swiper.slidesEl, `.${swiper.params.slideClass}[data-hash="${hash}"], swiper-slide[data-hash="${hash}"]`)[0]);
      }
    }
  });
  const onHashChange = () => {
    emit('hashChange');
    const newHash = document.location.hash.replace('#', '');
    const activeSlideEl = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index="${swiper.activeIndex}"]`) : swiper.slides[swiper.activeIndex];
    const activeSlideHash = activeSlideEl ? activeSlideEl.getAttribute('data-hash') : '';
    if (newHash !== activeSlideHash) {
      const newIndex = swiper.params.hashNavigation.getSlideIndex(swiper, newHash);
      if (typeof newIndex === 'undefined' || Number.isNaN(newIndex)) return;
      swiper.slideTo(newIndex);
    }
  };
  const setHash = () => {
    if (!initialized || !swiper.params.hashNavigation.enabled) return;
    const activeSlideEl = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index="${swiper.activeIndex}"]`) : swiper.slides[swiper.activeIndex];
    const activeSlideHash = activeSlideEl ? activeSlideEl.getAttribute('data-hash') || activeSlideEl.getAttribute('data-history') : '';
    if (swiper.params.hashNavigation.replaceState && window.history && window.history.replaceState) {
      window.history.replaceState(null, null, `#${activeSlideHash}` || '');
      emit('hashSet');
    } else {
      document.location.hash = activeSlideHash || '';
      emit('hashSet');
    }
  };
  const init = () => {
    if (!swiper.params.hashNavigation.enabled || swiper.params.history && swiper.params.history.enabled) return;
    initialized = true;
    const hash = document.location.hash.replace('#', '');
    if (hash) {
      const speed = 0;
      const index = swiper.params.hashNavigation.getSlideIndex(swiper, hash);
      swiper.slideTo(index || 0, speed, swiper.params.runCallbacksOnInit, true);
    }
    if (swiper.params.hashNavigation.watchState) {
      window.addEventListener('hashchange', onHashChange);
    }
  };
  const destroy = () => {
    if (swiper.params.hashNavigation.watchState) {
      window.removeEventListener('hashchange', onHashChange);
    }
  };
  on('init', () => {
    if (swiper.params.hashNavigation.enabled) {
      init();
    }
  });
  on('destroy', () => {
    if (swiper.params.hashNavigation.enabled) {
      destroy();
    }
  });
  on('transitionEnd _freeModeNoMomentumRelease', () => {
    if (initialized) {
      setHash();
    }
  });
  on('slideChange', () => {
    if (initialized && swiper.params.cssMode) {
      setHash();
    }
  });
}




/***/ }),

/***/ "./node_modules/swiper/modules/history.mjs":
/*!*************************************************!*\
  !*** ./node_modules/swiper/modules/history.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ History)
/* harmony export */ });
/* harmony import */ var _shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/ssr-window.esm.mjs */ "./node_modules/swiper/shared/ssr-window.esm.mjs");


function History(_ref) {
  let {
    swiper,
    extendParams,
    on
  } = _ref;
  extendParams({
    history: {
      enabled: false,
      root: '',
      replaceState: false,
      key: 'slides',
      keepQuery: false
    }
  });
  let initialized = false;
  let paths = {};
  const slugify = text => {
    return text.toString().replace(/\s+/g, '-').replace(/[^\w-]+/g, '').replace(/--+/g, '-').replace(/^-+/, '').replace(/-+$/, '');
  };
  const getPathValues = urlOverride => {
    const window = (0,_shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();
    let location;
    if (urlOverride) {
      location = new URL(urlOverride);
    } else {
      location = window.location;
    }
    const pathArray = location.pathname.slice(1).split('/').filter(part => part !== '');
    const total = pathArray.length;
    const key = pathArray[total - 2];
    const value = pathArray[total - 1];
    return {
      key,
      value
    };
  };
  const setHistory = (key, index) => {
    const window = (0,_shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();
    if (!initialized || !swiper.params.history.enabled) return;
    let location;
    if (swiper.params.url) {
      location = new URL(swiper.params.url);
    } else {
      location = window.location;
    }
    const slide = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index="${index}"]`) : swiper.slides[index];
    let value = slugify(slide.getAttribute('data-history'));
    if (swiper.params.history.root.length > 0) {
      let root = swiper.params.history.root;
      if (root[root.length - 1] === '/') root = root.slice(0, root.length - 1);
      value = `${root}/${key ? `${key}/` : ''}${value}`;
    } else if (!location.pathname.includes(key)) {
      value = `${key ? `${key}/` : ''}${value}`;
    }
    if (swiper.params.history.keepQuery) {
      value += location.search;
    }
    const currentState = window.history.state;
    if (currentState && currentState.value === value) {
      return;
    }
    if (swiper.params.history.replaceState) {
      window.history.replaceState({
        value
      }, null, value);
    } else {
      window.history.pushState({
        value
      }, null, value);
    }
  };
  const scrollToSlide = (speed, value, runCallbacks) => {
    if (value) {
      for (let i = 0, length = swiper.slides.length; i < length; i += 1) {
        const slide = swiper.slides[i];
        const slideHistory = slugify(slide.getAttribute('data-history'));
        if (slideHistory === value) {
          const index = swiper.getSlideIndex(slide);
          swiper.slideTo(index, speed, runCallbacks);
        }
      }
    } else {
      swiper.slideTo(0, speed, runCallbacks);
    }
  };
  const setHistoryPopState = () => {
    paths = getPathValues(swiper.params.url);
    scrollToSlide(swiper.params.speed, paths.value, false);
  };
  const init = () => {
    const window = (0,_shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();
    if (!swiper.params.history) return;
    if (!window.history || !window.history.pushState) {
      swiper.params.history.enabled = false;
      swiper.params.hashNavigation.enabled = true;
      return;
    }
    initialized = true;
    paths = getPathValues(swiper.params.url);
    if (!paths.key && !paths.value) {
      if (!swiper.params.history.replaceState) {
        window.addEventListener('popstate', setHistoryPopState);
      }
      return;
    }
    scrollToSlide(0, paths.value, swiper.params.runCallbacksOnInit);
    if (!swiper.params.history.replaceState) {
      window.addEventListener('popstate', setHistoryPopState);
    }
  };
  const destroy = () => {
    const window = (0,_shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();
    if (!swiper.params.history.replaceState) {
      window.removeEventListener('popstate', setHistoryPopState);
    }
  };
  on('init', () => {
    if (swiper.params.history.enabled) {
      init();
    }
  });
  on('destroy', () => {
    if (swiper.params.history.enabled) {
      destroy();
    }
  });
  on('transitionEnd _freeModeNoMomentumRelease', () => {
    if (initialized) {
      setHistory(swiper.params.history.key, swiper.activeIndex);
    }
  });
  on('slideChange', () => {
    if (initialized && swiper.params.cssMode) {
      setHistory(swiper.params.history.key, swiper.activeIndex);
    }
  });
}




/***/ }),

/***/ "./node_modules/swiper/modules/index.mjs":
/*!***********************************************!*\
  !*** ./node_modules/swiper/modules/index.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A11y: () => (/* reexport safe */ _a11y_mjs__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   Autoplay: () => (/* reexport safe */ _autoplay_mjs__WEBPACK_IMPORTED_MODULE_12__["default"]),
/* harmony export */   Controller: () => (/* reexport safe */ _controller_mjs__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   EffectCards: () => (/* reexport safe */ _effect_cards_mjs__WEBPACK_IMPORTED_MODULE_22__["default"]),
/* harmony export */   EffectCoverflow: () => (/* reexport safe */ _effect_coverflow_mjs__WEBPACK_IMPORTED_MODULE_20__["default"]),
/* harmony export */   EffectCreative: () => (/* reexport safe */ _effect_creative_mjs__WEBPACK_IMPORTED_MODULE_21__["default"]),
/* harmony export */   EffectCube: () => (/* reexport safe */ _effect_cube_mjs__WEBPACK_IMPORTED_MODULE_18__["default"]),
/* harmony export */   EffectFade: () => (/* reexport safe */ _effect_fade_mjs__WEBPACK_IMPORTED_MODULE_17__["default"]),
/* harmony export */   EffectFlip: () => (/* reexport safe */ _effect_flip_mjs__WEBPACK_IMPORTED_MODULE_19__["default"]),
/* harmony export */   FreeMode: () => (/* reexport safe */ _free_mode_mjs__WEBPACK_IMPORTED_MODULE_14__["default"]),
/* harmony export */   Grid: () => (/* reexport safe */ _grid_mjs__WEBPACK_IMPORTED_MODULE_15__["default"]),
/* harmony export */   HashNavigation: () => (/* reexport safe */ _hash_navigation_mjs__WEBPACK_IMPORTED_MODULE_11__["default"]),
/* harmony export */   History: () => (/* reexport safe */ _history_mjs__WEBPACK_IMPORTED_MODULE_10__["default"]),
/* harmony export */   Keyboard: () => (/* reexport safe */ _keyboard_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   Manipulation: () => (/* reexport safe */ _manipulation_mjs__WEBPACK_IMPORTED_MODULE_16__["default"]),
/* harmony export */   Mousewheel: () => (/* reexport safe */ _mousewheel_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   Navigation: () => (/* reexport safe */ _navigation_mjs__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   Pagination: () => (/* reexport safe */ _pagination_mjs__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   Parallax: () => (/* reexport safe */ _parallax_mjs__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   Scrollbar: () => (/* reexport safe */ _scrollbar_mjs__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   Thumbs: () => (/* reexport safe */ _thumbs_mjs__WEBPACK_IMPORTED_MODULE_13__["default"]),
/* harmony export */   Virtual: () => (/* reexport safe */ _virtual_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   Zoom: () => (/* reexport safe */ _zoom_mjs__WEBPACK_IMPORTED_MODULE_7__["default"])
/* harmony export */ });
/* harmony import */ var _virtual_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./virtual.mjs */ "./node_modules/swiper/modules/virtual.mjs");
/* harmony import */ var _keyboard_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keyboard.mjs */ "./node_modules/swiper/modules/keyboard.mjs");
/* harmony import */ var _mousewheel_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mousewheel.mjs */ "./node_modules/swiper/modules/mousewheel.mjs");
/* harmony import */ var _navigation_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./navigation.mjs */ "./node_modules/swiper/modules/navigation.mjs");
/* harmony import */ var _pagination_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./pagination.mjs */ "./node_modules/swiper/modules/pagination.mjs");
/* harmony import */ var _scrollbar_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./scrollbar.mjs */ "./node_modules/swiper/modules/scrollbar.mjs");
/* harmony import */ var _parallax_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./parallax.mjs */ "./node_modules/swiper/modules/parallax.mjs");
/* harmony import */ var _zoom_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./zoom.mjs */ "./node_modules/swiper/modules/zoom.mjs");
/* harmony import */ var _controller_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./controller.mjs */ "./node_modules/swiper/modules/controller.mjs");
/* harmony import */ var _a11y_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./a11y.mjs */ "./node_modules/swiper/modules/a11y.mjs");
/* harmony import */ var _history_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./history.mjs */ "./node_modules/swiper/modules/history.mjs");
/* harmony import */ var _hash_navigation_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./hash-navigation.mjs */ "./node_modules/swiper/modules/hash-navigation.mjs");
/* harmony import */ var _autoplay_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./autoplay.mjs */ "./node_modules/swiper/modules/autoplay.mjs");
/* harmony import */ var _thumbs_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./thumbs.mjs */ "./node_modules/swiper/modules/thumbs.mjs");
/* harmony import */ var _free_mode_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./free-mode.mjs */ "./node_modules/swiper/modules/free-mode.mjs");
/* harmony import */ var _grid_mjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./grid.mjs */ "./node_modules/swiper/modules/grid.mjs");
/* harmony import */ var _manipulation_mjs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./manipulation.mjs */ "./node_modules/swiper/modules/manipulation.mjs");
/* harmony import */ var _effect_fade_mjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./effect-fade.mjs */ "./node_modules/swiper/modules/effect-fade.mjs");
/* harmony import */ var _effect_cube_mjs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./effect-cube.mjs */ "./node_modules/swiper/modules/effect-cube.mjs");
/* harmony import */ var _effect_flip_mjs__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./effect-flip.mjs */ "./node_modules/swiper/modules/effect-flip.mjs");
/* harmony import */ var _effect_coverflow_mjs__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./effect-coverflow.mjs */ "./node_modules/swiper/modules/effect-coverflow.mjs");
/* harmony import */ var _effect_creative_mjs__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./effect-creative.mjs */ "./node_modules/swiper/modules/effect-creative.mjs");
/* harmony import */ var _effect_cards_mjs__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./effect-cards.mjs */ "./node_modules/swiper/modules/effect-cards.mjs");
























/***/ }),

/***/ "./node_modules/swiper/modules/keyboard.mjs":
/*!**************************************************!*\
  !*** ./node_modules/swiper/modules/keyboard.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Keyboard)
/* harmony export */ });
/* harmony import */ var _shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/ssr-window.esm.mjs */ "./node_modules/swiper/shared/ssr-window.esm.mjs");
/* harmony import */ var _shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.mjs */ "./node_modules/swiper/shared/utils.mjs");



/* eslint-disable consistent-return */
function Keyboard(_ref) {
  let {
    swiper,
    extendParams,
    on,
    emit
  } = _ref;
  const document = (0,_shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();
  const window = (0,_shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();
  swiper.keyboard = {
    enabled: false
  };
  extendParams({
    keyboard: {
      enabled: false,
      onlyInViewport: true,
      pageUpDown: true
    }
  });
  function handle(event) {
    if (!swiper.enabled) return;
    const {
      rtlTranslate: rtl
    } = swiper;
    let e = event;
    if (e.originalEvent) e = e.originalEvent; // jquery fix
    const kc = e.keyCode || e.charCode;
    const pageUpDown = swiper.params.keyboard.pageUpDown;
    const isPageUp = pageUpDown && kc === 33;
    const isPageDown = pageUpDown && kc === 34;
    const isArrowLeft = kc === 37;
    const isArrowRight = kc === 39;
    const isArrowUp = kc === 38;
    const isArrowDown = kc === 40;
    // Directions locks
    if (!swiper.allowSlideNext && (swiper.isHorizontal() && isArrowRight || swiper.isVertical() && isArrowDown || isPageDown)) {
      return false;
    }
    if (!swiper.allowSlidePrev && (swiper.isHorizontal() && isArrowLeft || swiper.isVertical() && isArrowUp || isPageUp)) {
      return false;
    }
    if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
      return undefined;
    }
    if (document.activeElement && document.activeElement.nodeName && (document.activeElement.nodeName.toLowerCase() === 'input' || document.activeElement.nodeName.toLowerCase() === 'textarea')) {
      return undefined;
    }
    if (swiper.params.keyboard.onlyInViewport && (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)) {
      let inView = false;
      // Check that swiper should be inside of visible area of window
      if ((0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.a)(swiper.el, `.${swiper.params.slideClass}, swiper-slide`).length > 0 && (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.a)(swiper.el, `.${swiper.params.slideActiveClass}`).length === 0) {
        return undefined;
      }
      const el = swiper.el;
      const swiperWidth = el.clientWidth;
      const swiperHeight = el.clientHeight;
      const windowWidth = window.innerWidth;
      const windowHeight = window.innerHeight;
      const swiperOffset = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.b)(el);
      if (rtl) swiperOffset.left -= el.scrollLeft;
      const swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiperWidth, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiperHeight], [swiperOffset.left + swiperWidth, swiperOffset.top + swiperHeight]];
      for (let i = 0; i < swiperCoord.length; i += 1) {
        const point = swiperCoord[i];
        if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {
          if (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line
          inView = true;
        }
      }
      if (!inView) return undefined;
    }
    if (swiper.isHorizontal()) {
      if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {
        if (e.preventDefault) e.preventDefault();else e.returnValue = false;
      }
      if ((isPageDown || isArrowRight) && !rtl || (isPageUp || isArrowLeft) && rtl) swiper.slideNext();
      if ((isPageUp || isArrowLeft) && !rtl || (isPageDown || isArrowRight) && rtl) swiper.slidePrev();
    } else {
      if (isPageUp || isPageDown || isArrowUp || isArrowDown) {
        if (e.preventDefault) e.preventDefault();else e.returnValue = false;
      }
      if (isPageDown || isArrowDown) swiper.slideNext();
      if (isPageUp || isArrowUp) swiper.slidePrev();
    }
    emit('keyPress', kc);
    return undefined;
  }
  function enable() {
    if (swiper.keyboard.enabled) return;
    document.addEventListener('keydown', handle);
    swiper.keyboard.enabled = true;
  }
  function disable() {
    if (!swiper.keyboard.enabled) return;
    document.removeEventListener('keydown', handle);
    swiper.keyboard.enabled = false;
  }
  on('init', () => {
    if (swiper.params.keyboard.enabled) {
      enable();
    }
  });
  on('destroy', () => {
    if (swiper.keyboard.enabled) {
      disable();
    }
  });
  Object.assign(swiper.keyboard, {
    enable,
    disable
  });
}




/***/ }),

/***/ "./node_modules/swiper/modules/manipulation.mjs":
/*!******************************************************!*\
  !*** ./node_modules/swiper/modules/manipulation.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Manipulation)
/* harmony export */ });
function appendSlide(slides) {
  const swiper = this;
  const {
    params,
    slidesEl
  } = swiper;
  if (params.loop) {
    swiper.loopDestroy();
  }
  const appendElement = slideEl => {
    if (typeof slideEl === 'string') {
      const tempDOM = document.createElement('div');
      tempDOM.innerHTML = slideEl;
      slidesEl.append(tempDOM.children[0]);
      tempDOM.innerHTML = '';
    } else {
      slidesEl.append(slideEl);
    }
  };
  if (typeof slides === 'object' && 'length' in slides) {
    for (let i = 0; i < slides.length; i += 1) {
      if (slides[i]) appendElement(slides[i]);
    }
  } else {
    appendElement(slides);
  }
  swiper.recalcSlides();
  if (params.loop) {
    swiper.loopCreate();
  }
  if (!params.observer || swiper.isElement) {
    swiper.update();
  }
}

function prependSlide(slides) {
  const swiper = this;
  const {
    params,
    activeIndex,
    slidesEl
  } = swiper;
  if (params.loop) {
    swiper.loopDestroy();
  }
  let newActiveIndex = activeIndex + 1;
  const prependElement = slideEl => {
    if (typeof slideEl === 'string') {
      const tempDOM = document.createElement('div');
      tempDOM.innerHTML = slideEl;
      slidesEl.prepend(tempDOM.children[0]);
      tempDOM.innerHTML = '';
    } else {
      slidesEl.prepend(slideEl);
    }
  };
  if (typeof slides === 'object' && 'length' in slides) {
    for (let i = 0; i < slides.length; i += 1) {
      if (slides[i]) prependElement(slides[i]);
    }
    newActiveIndex = activeIndex + slides.length;
  } else {
    prependElement(slides);
  }
  swiper.recalcSlides();
  if (params.loop) {
    swiper.loopCreate();
  }
  if (!params.observer || swiper.isElement) {
    swiper.update();
  }
  swiper.slideTo(newActiveIndex, 0, false);
}

function addSlide(index, slides) {
  const swiper = this;
  const {
    params,
    activeIndex,
    slidesEl
  } = swiper;
  let activeIndexBuffer = activeIndex;
  if (params.loop) {
    activeIndexBuffer -= swiper.loopedSlides;
    swiper.loopDestroy();
    swiper.recalcSlides();
  }
  const baseLength = swiper.slides.length;
  if (index <= 0) {
    swiper.prependSlide(slides);
    return;
  }
  if (index >= baseLength) {
    swiper.appendSlide(slides);
    return;
  }
  let newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;
  const slidesBuffer = [];
  for (let i = baseLength - 1; i >= index; i -= 1) {
    const currentSlide = swiper.slides[i];
    currentSlide.remove();
    slidesBuffer.unshift(currentSlide);
  }
  if (typeof slides === 'object' && 'length' in slides) {
    for (let i = 0; i < slides.length; i += 1) {
      if (slides[i]) slidesEl.append(slides[i]);
    }
    newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;
  } else {
    slidesEl.append(slides);
  }
  for (let i = 0; i < slidesBuffer.length; i += 1) {
    slidesEl.append(slidesBuffer[i]);
  }
  swiper.recalcSlides();
  if (params.loop) {
    swiper.loopCreate();
  }
  if (!params.observer || swiper.isElement) {
    swiper.update();
  }
  if (params.loop) {
    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
  } else {
    swiper.slideTo(newActiveIndex, 0, false);
  }
}

function removeSlide(slidesIndexes) {
  const swiper = this;
  const {
    params,
    activeIndex
  } = swiper;
  let activeIndexBuffer = activeIndex;
  if (params.loop) {
    activeIndexBuffer -= swiper.loopedSlides;
    swiper.loopDestroy();
  }
  let newActiveIndex = activeIndexBuffer;
  let indexToRemove;
  if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {
    for (let i = 0; i < slidesIndexes.length; i += 1) {
      indexToRemove = slidesIndexes[i];
      if (swiper.slides[indexToRemove]) swiper.slides[indexToRemove].remove();
      if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
    }
    newActiveIndex = Math.max(newActiveIndex, 0);
  } else {
    indexToRemove = slidesIndexes;
    if (swiper.slides[indexToRemove]) swiper.slides[indexToRemove].remove();
    if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
    newActiveIndex = Math.max(newActiveIndex, 0);
  }
  swiper.recalcSlides();
  if (params.loop) {
    swiper.loopCreate();
  }
  if (!params.observer || swiper.isElement) {
    swiper.update();
  }
  if (params.loop) {
    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
  } else {
    swiper.slideTo(newActiveIndex, 0, false);
  }
}

function removeAllSlides() {
  const swiper = this;
  const slidesIndexes = [];
  for (let i = 0; i < swiper.slides.length; i += 1) {
    slidesIndexes.push(i);
  }
  swiper.removeSlide(slidesIndexes);
}

function Manipulation(_ref) {
  let {
    swiper
  } = _ref;
  Object.assign(swiper, {
    appendSlide: appendSlide.bind(swiper),
    prependSlide: prependSlide.bind(swiper),
    addSlide: addSlide.bind(swiper),
    removeSlide: removeSlide.bind(swiper),
    removeAllSlides: removeAllSlides.bind(swiper)
  });
}




/***/ }),

/***/ "./node_modules/swiper/modules/mousewheel.mjs":
/*!****************************************************!*\
  !*** ./node_modules/swiper/modules/mousewheel.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Mousewheel)
/* harmony export */ });
/* harmony import */ var _shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/ssr-window.esm.mjs */ "./node_modules/swiper/shared/ssr-window.esm.mjs");
/* harmony import */ var _shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.mjs */ "./node_modules/swiper/shared/utils.mjs");



/* eslint-disable consistent-return */
function Mousewheel(_ref) {
  let {
    swiper,
    extendParams,
    on,
    emit
  } = _ref;
  const window = (0,_shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();
  extendParams({
    mousewheel: {
      enabled: false,
      releaseOnEdges: false,
      invert: false,
      forceToAxis: false,
      sensitivity: 1,
      eventsTarget: 'container',
      thresholdDelta: null,
      thresholdTime: null,
      noMousewheelClass: 'swiper-no-mousewheel'
    }
  });
  swiper.mousewheel = {
    enabled: false
  };
  let timeout;
  let lastScrollTime = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.d)();
  let lastEventBeforeSnap;
  const recentWheelEvents = [];
  function normalize(e) {
    // Reasonable defaults
    const PIXEL_STEP = 10;
    const LINE_HEIGHT = 40;
    const PAGE_HEIGHT = 800;
    let sX = 0;
    let sY = 0; // spinX, spinY
    let pX = 0;
    let pY = 0; // pixelX, pixelY

    // Legacy
    if ('detail' in e) {
      sY = e.detail;
    }
    if ('wheelDelta' in e) {
      sY = -e.wheelDelta / 120;
    }
    if ('wheelDeltaY' in e) {
      sY = -e.wheelDeltaY / 120;
    }
    if ('wheelDeltaX' in e) {
      sX = -e.wheelDeltaX / 120;
    }

    // side scrolling on FF with DOMMouseScroll
    if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {
      sX = sY;
      sY = 0;
    }
    pX = sX * PIXEL_STEP;
    pY = sY * PIXEL_STEP;
    if ('deltaY' in e) {
      pY = e.deltaY;
    }
    if ('deltaX' in e) {
      pX = e.deltaX;
    }
    if (e.shiftKey && !pX) {
      // if user scrolls with shift he wants horizontal scroll
      pX = pY;
      pY = 0;
    }
    if ((pX || pY) && e.deltaMode) {
      if (e.deltaMode === 1) {
        // delta in LINE units
        pX *= LINE_HEIGHT;
        pY *= LINE_HEIGHT;
      } else {
        // delta in PAGE units
        pX *= PAGE_HEIGHT;
        pY *= PAGE_HEIGHT;
      }
    }

    // Fall-back if spin cannot be determined
    if (pX && !sX) {
      sX = pX < 1 ? -1 : 1;
    }
    if (pY && !sY) {
      sY = pY < 1 ? -1 : 1;
    }
    return {
      spinX: sX,
      spinY: sY,
      pixelX: pX,
      pixelY: pY
    };
  }
  function handleMouseEnter() {
    if (!swiper.enabled) return;
    swiper.mouseEntered = true;
  }
  function handleMouseLeave() {
    if (!swiper.enabled) return;
    swiper.mouseEntered = false;
  }
  function animateSlider(newEvent) {
    if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) {
      // Prevent if delta of wheel scroll delta is below configured threshold
      return false;
    }
    if (swiper.params.mousewheel.thresholdTime && (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.d)() - lastScrollTime < swiper.params.mousewheel.thresholdTime) {
      // Prevent if time between scrolls is below configured threshold
      return false;
    }

    // If the movement is NOT big enough and
    // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):
    //   Don't go any further (avoid insignificant scroll movement).
    if (newEvent.delta >= 6 && (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.d)() - lastScrollTime < 60) {
      // Return false as a default
      return true;
    }
    // If user is scrolling towards the end:
    //   If the slider hasn't hit the latest slide or
    //   if the slider is a loop and
    //   if the slider isn't moving right now:
    //     Go to next slide and
    //     emit a scroll event.
    // Else (the user is scrolling towards the beginning) and
    // if the slider hasn't hit the first slide or
    // if the slider is a loop and
    // if the slider isn't moving right now:
    //   Go to prev slide and
    //   emit a scroll event.
    if (newEvent.direction < 0) {
      if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
        swiper.slideNext();
        emit('scroll', newEvent.raw);
      }
    } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
      swiper.slidePrev();
      emit('scroll', newEvent.raw);
    }
    // If you got here is because an animation has been triggered so store the current time
    lastScrollTime = new window.Date().getTime();
    // Return false as a default
    return false;
  }
  function releaseScroll(newEvent) {
    const params = swiper.params.mousewheel;
    if (newEvent.direction < 0) {
      if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {
        // Return true to animate scroll on edges
        return true;
      }
    } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {
      // Return true to animate scroll on edges
      return true;
    }
    return false;
  }
  function handle(event) {
    let e = event;
    let disableParentSwiper = true;
    if (!swiper.enabled) return;

    // Ignore event if the target or its parents have the swiper-no-mousewheel class
    if (event.target.closest(`.${swiper.params.mousewheel.noMousewheelClass}`)) return;
    const params = swiper.params.mousewheel;
    if (swiper.params.cssMode) {
      e.preventDefault();
    }
    let targetEl = swiper.el;
    if (swiper.params.mousewheel.eventsTarget !== 'container') {
      targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);
    }
    const targetElContainsTarget = targetEl && targetEl.contains(e.target);
    if (!swiper.mouseEntered && !targetElContainsTarget && !params.releaseOnEdges) return true;
    if (e.originalEvent) e = e.originalEvent; // jquery fix
    let delta = 0;
    const rtlFactor = swiper.rtlTranslate ? -1 : 1;
    const data = normalize(e);
    if (params.forceToAxis) {
      if (swiper.isHorizontal()) {
        if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;else return true;
      } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;else return true;
    } else {
      delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
    }
    if (delta === 0) return true;
    if (params.invert) delta = -delta;

    // Get the scroll positions
    let positions = swiper.getTranslate() + delta * params.sensitivity;
    if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();
    if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate();

    // When loop is true:
    //     the disableParentSwiper will be true.
    // When loop is false:
    //     if the scroll positions is not on edge,
    //     then the disableParentSwiper will be true.
    //     if the scroll on edge positions,
    //     then the disableParentSwiper will be false.
    disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());
    if (disableParentSwiper && swiper.params.nested) e.stopPropagation();
    if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {
      // Register the new event in a variable which stores the relevant data
      const newEvent = {
        time: (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.d)(),
        delta: Math.abs(delta),
        direction: Math.sign(delta),
        raw: event
      };

      // Keep the most recent events
      if (recentWheelEvents.length >= 2) {
        recentWheelEvents.shift(); // only store the last N events
      }

      const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
      recentWheelEvents.push(newEvent);

      // If there is at least one previous recorded event:
      //   If direction has changed or
      //   if the scroll is quicker than the previous one:
      //     Animate the slider.
      // Else (this is the first time the wheel is moved):
      //     Animate the slider.
      if (prevEvent) {
        if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {
          animateSlider(newEvent);
        }
      } else {
        animateSlider(newEvent);
      }

      // If it's time to release the scroll:
      //   Return now so you don't hit the preventDefault.
      if (releaseScroll(newEvent)) {
        return true;
      }
    } else {
      // Freemode or scrollContainer:

      // If we recently snapped after a momentum scroll, then ignore wheel events
      // to give time for the deceleration to finish. Stop ignoring after 500 msecs
      // or if it's a new scroll (larger delta or inverse sign as last event before
      // an end-of-momentum snap).
      const newEvent = {
        time: (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.d)(),
        delta: Math.abs(delta),
        direction: Math.sign(delta)
      };
      const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;
      if (!ignoreWheelEvents) {
        lastEventBeforeSnap = undefined;
        let position = swiper.getTranslate() + delta * params.sensitivity;
        const wasBeginning = swiper.isBeginning;
        const wasEnd = swiper.isEnd;
        if (position >= swiper.minTranslate()) position = swiper.minTranslate();
        if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();
        swiper.setTransition(0);
        swiper.setTranslate(position);
        swiper.updateProgress();
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
        if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {
          swiper.updateSlidesClasses();
        }
        if (swiper.params.loop) {
          swiper.loopFix({
            direction: newEvent.direction < 0 ? 'next' : 'prev',
            byMousewheel: true
          });
        }
        if (swiper.params.freeMode.sticky) {
          // When wheel scrolling starts with sticky (aka snap) enabled, then detect
          // the end of a momentum scroll by storing recent (N=15?) wheel events.
          // 1. do all N events have decreasing or same (absolute value) delta?
          // 2. did all N events arrive in the last M (M=500?) msecs?
          // 3. does the earliest event have an (absolute value) delta that's
          //    at least P (P=1?) larger than the most recent event's delta?
          // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?
          // If 1-4 are "yes" then we're near the end of a momentum scroll deceleration.
          // Snap immediately and ignore remaining wheel events in this scroll.
          // See comment above for "remaining wheel events in this scroll" determination.
          // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.
          clearTimeout(timeout);
          timeout = undefined;
          if (recentWheelEvents.length >= 15) {
            recentWheelEvents.shift(); // only store the last N events
          }

          const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
          const firstEvent = recentWheelEvents[0];
          recentWheelEvents.push(newEvent);
          if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {
            // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.
            recentWheelEvents.splice(0);
          } else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {
            // We're at the end of the deceleration of a momentum scroll, so there's no need
            // to wait for more events. Snap ASAP on the next tick.
            // Also, because there's some remaining momentum we'll bias the snap in the
            // direction of the ongoing scroll because it's better UX for the scroll to snap
            // in the same direction as the scroll instead of reversing to snap.  Therefore,
            // if it's already scrolled more than 20% in the current direction, keep going.
            const snapToThreshold = delta > 0 ? 0.8 : 0.2;
            lastEventBeforeSnap = newEvent;
            recentWheelEvents.splice(0);
            timeout = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.n)(() => {
              if (swiper.destroyed || !swiper.params) return;
              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
            }, 0); // no delay; move on next tick
          }

          if (!timeout) {
            // if we get here, then we haven't detected the end of a momentum scroll, so
            // we'll consider a scroll "complete" when there haven't been any wheel events
            // for 500ms.
            timeout = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.n)(() => {
              if (swiper.destroyed || !swiper.params) return;
              const snapToThreshold = 0.5;
              lastEventBeforeSnap = newEvent;
              recentWheelEvents.splice(0);
              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
            }, 500);
          }
        }

        // Emit event
        if (!ignoreWheelEvents) emit('scroll', e);

        // Stop autoplay
        if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop();
        // Return page scroll on edge positions
        if (params.releaseOnEdges && (position === swiper.minTranslate() || position === swiper.maxTranslate())) {
          return true;
        }
      }
    }
    if (e.preventDefault) e.preventDefault();else e.returnValue = false;
    return false;
  }
  function events(method) {
    let targetEl = swiper.el;
    if (swiper.params.mousewheel.eventsTarget !== 'container') {
      targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);
    }
    targetEl[method]('mouseenter', handleMouseEnter);
    targetEl[method]('mouseleave', handleMouseLeave);
    targetEl[method]('wheel', handle);
  }
  function enable() {
    if (swiper.params.cssMode) {
      swiper.wrapperEl.removeEventListener('wheel', handle);
      return true;
    }
    if (swiper.mousewheel.enabled) return false;
    events('addEventListener');
    swiper.mousewheel.enabled = true;
    return true;
  }
  function disable() {
    if (swiper.params.cssMode) {
      swiper.wrapperEl.addEventListener(event, handle);
      return true;
    }
    if (!swiper.mousewheel.enabled) return false;
    events('removeEventListener');
    swiper.mousewheel.enabled = false;
    return true;
  }
  on('init', () => {
    if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {
      disable();
    }
    if (swiper.params.mousewheel.enabled) enable();
  });
  on('destroy', () => {
    if (swiper.params.cssMode) {
      enable();
    }
    if (swiper.mousewheel.enabled) disable();
  });
  Object.assign(swiper.mousewheel, {
    enable,
    disable
  });
}




/***/ }),

/***/ "./node_modules/swiper/modules/navigation.mjs":
/*!****************************************************!*\
  !*** ./node_modules/swiper/modules/navigation.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Navigation)
/* harmony export */ });
/* harmony import */ var _shared_create_element_if_not_defined_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/create-element-if-not-defined.mjs */ "./node_modules/swiper/shared/create-element-if-not-defined.mjs");
/* harmony import */ var _shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.mjs */ "./node_modules/swiper/shared/utils.mjs");



function Navigation(_ref) {
  let {
    swiper,
    extendParams,
    on,
    emit
  } = _ref;
  extendParams({
    navigation: {
      nextEl: null,
      prevEl: null,
      hideOnClick: false,
      disabledClass: 'swiper-button-disabled',
      hiddenClass: 'swiper-button-hidden',
      lockClass: 'swiper-button-lock',
      navigationDisabledClass: 'swiper-navigation-disabled'
    }
  });
  swiper.navigation = {
    nextEl: null,
    prevEl: null
  };
  function getEl(el) {
    let res;
    if (el && typeof el === 'string' && swiper.isElement) {
      res = swiper.el.querySelector(el) || swiper.hostEl.querySelector(el);
      if (res) return res;
    }
    if (el) {
      if (typeof el === 'string') res = [...document.querySelectorAll(el)];
      if (swiper.params.uniqueNavElements && typeof el === 'string' && res && res.length > 1 && swiper.el.querySelectorAll(el).length === 1) {
        res = swiper.el.querySelector(el);
      } else if (res && res.length === 1) {
        res = res[0];
      }
    }
    if (el && !res) return el;
    // if (Array.isArray(res) && res.length === 1) res = res[0];
    return res;
  }
  function toggleEl(el, disabled) {
    const params = swiper.params.navigation;
    el = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.m)(el);
    el.forEach(subEl => {
      if (subEl) {
        subEl.classList[disabled ? 'add' : 'remove'](...params.disabledClass.split(' '));
        if (subEl.tagName === 'BUTTON') subEl.disabled = disabled;
        if (swiper.params.watchOverflow && swiper.enabled) {
          subEl.classList[swiper.isLocked ? 'add' : 'remove'](params.lockClass);
        }
      }
    });
  }
  function update() {
    // Update Navigation Buttons
    const {
      nextEl,
      prevEl
    } = swiper.navigation;
    if (swiper.params.loop) {
      toggleEl(prevEl, false);
      toggleEl(nextEl, false);
      return;
    }
    toggleEl(prevEl, swiper.isBeginning && !swiper.params.rewind);
    toggleEl(nextEl, swiper.isEnd && !swiper.params.rewind);
  }
  function onPrevClick(e) {
    e.preventDefault();
    if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;
    swiper.slidePrev();
    emit('navigationPrev');
  }
  function onNextClick(e) {
    e.preventDefault();
    if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;
    swiper.slideNext();
    emit('navigationNext');
  }
  function init() {
    const params = swiper.params.navigation;
    swiper.params.navigation = (0,_shared_create_element_if_not_defined_mjs__WEBPACK_IMPORTED_MODULE_0__.c)(swiper, swiper.originalParams.navigation, swiper.params.navigation, {
      nextEl: 'swiper-button-next',
      prevEl: 'swiper-button-prev'
    });
    if (!(params.nextEl || params.prevEl)) return;
    let nextEl = getEl(params.nextEl);
    let prevEl = getEl(params.prevEl);
    Object.assign(swiper.navigation, {
      nextEl,
      prevEl
    });
    nextEl = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.m)(nextEl);
    prevEl = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.m)(prevEl);
    const initButton = (el, dir) => {
      if (el) {
        el.addEventListener('click', dir === 'next' ? onNextClick : onPrevClick);
      }
      if (!swiper.enabled && el) {
        el.classList.add(...params.lockClass.split(' '));
      }
    };
    nextEl.forEach(el => initButton(el, 'next'));
    prevEl.forEach(el => initButton(el, 'prev'));
  }
  function destroy() {
    let {
      nextEl,
      prevEl
    } = swiper.navigation;
    nextEl = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.m)(nextEl);
    prevEl = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.m)(prevEl);
    const destroyButton = (el, dir) => {
      el.removeEventListener('click', dir === 'next' ? onNextClick : onPrevClick);
      el.classList.remove(...swiper.params.navigation.disabledClass.split(' '));
    };
    nextEl.forEach(el => destroyButton(el, 'next'));
    prevEl.forEach(el => destroyButton(el, 'prev'));
  }
  on('init', () => {
    if (swiper.params.navigation.enabled === false) {
      // eslint-disable-next-line
      disable();
    } else {
      init();
      update();
    }
  });
  on('toEdge fromEdge lock unlock', () => {
    update();
  });
  on('destroy', () => {
    destroy();
  });
  on('enable disable', () => {
    let {
      nextEl,
      prevEl
    } = swiper.navigation;
    nextEl = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.m)(nextEl);
    prevEl = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.m)(prevEl);
    if (swiper.enabled) {
      update();
      return;
    }
    [...nextEl, ...prevEl].filter(el => !!el).forEach(el => el.classList.add(swiper.params.navigation.lockClass));
  });
  on('click', (_s, e) => {
    let {
      nextEl,
      prevEl
    } = swiper.navigation;
    nextEl = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.m)(nextEl);
    prevEl = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.m)(prevEl);
    const targetEl = e.target;
    let targetIsButton = prevEl.includes(targetEl) || nextEl.includes(targetEl);
    if (swiper.isElement && !targetIsButton) {
      const path = e.path || e.composedPath && e.composedPath();
      if (path) {
        targetIsButton = path.find(pathEl => nextEl.includes(pathEl) || prevEl.includes(pathEl));
      }
    }
    if (swiper.params.navigation.hideOnClick && !targetIsButton) {
      if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;
      let isHidden;
      if (nextEl.length) {
        isHidden = nextEl[0].classList.contains(swiper.params.navigation.hiddenClass);
      } else if (prevEl.length) {
        isHidden = prevEl[0].classList.contains(swiper.params.navigation.hiddenClass);
      }
      if (isHidden === true) {
        emit('navigationShow');
      } else {
        emit('navigationHide');
      }
      [...nextEl, ...prevEl].filter(el => !!el).forEach(el => el.classList.toggle(swiper.params.navigation.hiddenClass));
    }
  });
  const enable = () => {
    swiper.el.classList.remove(...swiper.params.navigation.navigationDisabledClass.split(' '));
    init();
    update();
  };
  const disable = () => {
    swiper.el.classList.add(...swiper.params.navigation.navigationDisabledClass.split(' '));
    destroy();
  };
  Object.assign(swiper.navigation, {
    enable,
    disable,
    update,
    init,
    destroy
  });
}




/***/ }),

/***/ "./node_modules/swiper/modules/pagination.mjs":
/*!****************************************************!*\
  !*** ./node_modules/swiper/modules/pagination.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Pagination)
/* harmony export */ });
/* harmony import */ var _shared_classes_to_selector_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/classes-to-selector.mjs */ "./node_modules/swiper/shared/classes-to-selector.mjs");
/* harmony import */ var _shared_create_element_if_not_defined_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/create-element-if-not-defined.mjs */ "./node_modules/swiper/shared/create-element-if-not-defined.mjs");
/* harmony import */ var _shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/utils.mjs */ "./node_modules/swiper/shared/utils.mjs");




function Pagination(_ref) {
  let {
    swiper,
    extendParams,
    on,
    emit
  } = _ref;
  const pfx = 'swiper-pagination';
  extendParams({
    pagination: {
      el: null,
      bulletElement: 'span',
      clickable: false,
      hideOnClick: false,
      renderBullet: null,
      renderProgressbar: null,
      renderFraction: null,
      renderCustom: null,
      progressbarOpposite: false,
      type: 'bullets',
      // 'bullets' or 'progressbar' or 'fraction' or 'custom'
      dynamicBullets: false,
      dynamicMainBullets: 1,
      formatFractionCurrent: number => number,
      formatFractionTotal: number => number,
      bulletClass: `${pfx}-bullet`,
      bulletActiveClass: `${pfx}-bullet-active`,
      modifierClass: `${pfx}-`,
      currentClass: `${pfx}-current`,
      totalClass: `${pfx}-total`,
      hiddenClass: `${pfx}-hidden`,
      progressbarFillClass: `${pfx}-progressbar-fill`,
      progressbarOppositeClass: `${pfx}-progressbar-opposite`,
      clickableClass: `${pfx}-clickable`,
      lockClass: `${pfx}-lock`,
      horizontalClass: `${pfx}-horizontal`,
      verticalClass: `${pfx}-vertical`,
      paginationDisabledClass: `${pfx}-disabled`
    }
  });
  swiper.pagination = {
    el: null,
    bullets: []
  };
  let bulletSize;
  let dynamicBulletIndex = 0;
  function isPaginationDisabled() {
    return !swiper.params.pagination.el || !swiper.pagination.el || Array.isArray(swiper.pagination.el) && swiper.pagination.el.length === 0;
  }
  function setSideBullets(bulletEl, position) {
    const {
      bulletActiveClass
    } = swiper.params.pagination;
    if (!bulletEl) return;
    bulletEl = bulletEl[`${position === 'prev' ? 'previous' : 'next'}ElementSibling`];
    if (bulletEl) {
      bulletEl.classList.add(`${bulletActiveClass}-${position}`);
      bulletEl = bulletEl[`${position === 'prev' ? 'previous' : 'next'}ElementSibling`];
      if (bulletEl) {
        bulletEl.classList.add(`${bulletActiveClass}-${position}-${position}`);
      }
    }
  }
  function getMoveDirection(prevIndex, nextIndex, length) {
    prevIndex = prevIndex % length;
    nextIndex = nextIndex % length;
    if (nextIndex === prevIndex + 1) {
      return 'next';
    } else if (nextIndex === prevIndex - 1) {
      return 'previous';
    }
    return;
  }
  function onBulletClick(e) {
    const bulletEl = e.target.closest((0,_shared_classes_to_selector_mjs__WEBPACK_IMPORTED_MODULE_0__.c)(swiper.params.pagination.bulletClass));
    if (!bulletEl) {
      return;
    }
    e.preventDefault();
    const index = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.h)(bulletEl) * swiper.params.slidesPerGroup;
    if (swiper.params.loop) {
      if (swiper.realIndex === index) return;
      const moveDirection = getMoveDirection(swiper.realIndex, index, swiper.slides.length);
      if (moveDirection === 'next') {
        swiper.slideNext();
      } else if (moveDirection === 'previous') {
        swiper.slidePrev();
      } else {
        swiper.slideToLoop(index);
      }
    } else {
      swiper.slideTo(index);
    }
  }
  function update() {
    // Render || Update Pagination bullets/items
    const rtl = swiper.rtl;
    const params = swiper.params.pagination;
    if (isPaginationDisabled()) return;
    let el = swiper.pagination.el;
    el = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(el);
    // Current/Total
    let current;
    let previousIndex;
    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
    const total = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
    if (swiper.params.loop) {
      previousIndex = swiper.previousRealIndex || 0;
      current = swiper.params.slidesPerGroup > 1 ? Math.floor(swiper.realIndex / swiper.params.slidesPerGroup) : swiper.realIndex;
    } else if (typeof swiper.snapIndex !== 'undefined') {
      current = swiper.snapIndex;
      previousIndex = swiper.previousSnapIndex;
    } else {
      previousIndex = swiper.previousIndex || 0;
      current = swiper.activeIndex || 0;
    }
    // Types
    if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
      const bullets = swiper.pagination.bullets;
      let firstIndex;
      let lastIndex;
      let midIndex;
      if (params.dynamicBullets) {
        bulletSize = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.f)(bullets[0], swiper.isHorizontal() ? 'width' : 'height', true);
        el.forEach(subEl => {
          subEl.style[swiper.isHorizontal() ? 'width' : 'height'] = `${bulletSize * (params.dynamicMainBullets + 4)}px`;
        });
        if (params.dynamicMainBullets > 1 && previousIndex !== undefined) {
          dynamicBulletIndex += current - (previousIndex || 0);
          if (dynamicBulletIndex > params.dynamicMainBullets - 1) {
            dynamicBulletIndex = params.dynamicMainBullets - 1;
          } else if (dynamicBulletIndex < 0) {
            dynamicBulletIndex = 0;
          }
        }
        firstIndex = Math.max(current - dynamicBulletIndex, 0);
        lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
        midIndex = (lastIndex + firstIndex) / 2;
      }
      bullets.forEach(bulletEl => {
        const classesToRemove = [...['', '-next', '-next-next', '-prev', '-prev-prev', '-main'].map(suffix => `${params.bulletActiveClass}${suffix}`)].map(s => typeof s === 'string' && s.includes(' ') ? s.split(' ') : s).flat();
        bulletEl.classList.remove(...classesToRemove);
      });
      if (el.length > 1) {
        bullets.forEach(bullet => {
          const bulletIndex = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.h)(bullet);
          if (bulletIndex === current) {
            bullet.classList.add(...params.bulletActiveClass.split(' '));
          } else if (swiper.isElement) {
            bullet.setAttribute('part', 'bullet');
          }
          if (params.dynamicBullets) {
            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
              bullet.classList.add(...`${params.bulletActiveClass}-main`.split(' '));
            }
            if (bulletIndex === firstIndex) {
              setSideBullets(bullet, 'prev');
            }
            if (bulletIndex === lastIndex) {
              setSideBullets(bullet, 'next');
            }
          }
        });
      } else {
        const bullet = bullets[current];
        if (bullet) {
          bullet.classList.add(...params.bulletActiveClass.split(' '));
        }
        if (swiper.isElement) {
          bullets.forEach((bulletEl, bulletIndex) => {
            bulletEl.setAttribute('part', bulletIndex === current ? 'bullet-active' : 'bullet');
          });
        }
        if (params.dynamicBullets) {
          const firstDisplayedBullet = bullets[firstIndex];
          const lastDisplayedBullet = bullets[lastIndex];
          for (let i = firstIndex; i <= lastIndex; i += 1) {
            if (bullets[i]) {
              bullets[i].classList.add(...`${params.bulletActiveClass}-main`.split(' '));
            }
          }
          setSideBullets(firstDisplayedBullet, 'prev');
          setSideBullets(lastDisplayedBullet, 'next');
        }
      }
      if (params.dynamicBullets) {
        const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
        const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;
        const offsetProp = rtl ? 'right' : 'left';
        bullets.forEach(bullet => {
          bullet.style[swiper.isHorizontal() ? offsetProp : 'top'] = `${bulletsOffset}px`;
        });
      }
    }
    el.forEach((subEl, subElIndex) => {
      if (params.type === 'fraction') {
        subEl.querySelectorAll((0,_shared_classes_to_selector_mjs__WEBPACK_IMPORTED_MODULE_0__.c)(params.currentClass)).forEach(fractionEl => {
          fractionEl.textContent = params.formatFractionCurrent(current + 1);
        });
        subEl.querySelectorAll((0,_shared_classes_to_selector_mjs__WEBPACK_IMPORTED_MODULE_0__.c)(params.totalClass)).forEach(totalEl => {
          totalEl.textContent = params.formatFractionTotal(total);
        });
      }
      if (params.type === 'progressbar') {
        let progressbarDirection;
        if (params.progressbarOpposite) {
          progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
        } else {
          progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
        }
        const scale = (current + 1) / total;
        let scaleX = 1;
        let scaleY = 1;
        if (progressbarDirection === 'horizontal') {
          scaleX = scale;
        } else {
          scaleY = scale;
        }
        subEl.querySelectorAll((0,_shared_classes_to_selector_mjs__WEBPACK_IMPORTED_MODULE_0__.c)(params.progressbarFillClass)).forEach(progressEl => {
          progressEl.style.transform = `translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`;
          progressEl.style.transitionDuration = `${swiper.params.speed}ms`;
        });
      }
      if (params.type === 'custom' && params.renderCustom) {
        subEl.innerHTML = params.renderCustom(swiper, current + 1, total);
        if (subElIndex === 0) emit('paginationRender', subEl);
      } else {
        if (subElIndex === 0) emit('paginationRender', subEl);
        emit('paginationUpdate', subEl);
      }
      if (swiper.params.watchOverflow && swiper.enabled) {
        subEl.classList[swiper.isLocked ? 'add' : 'remove'](params.lockClass);
      }
    });
  }
  function render() {
    // Render Container
    const params = swiper.params.pagination;
    if (isPaginationDisabled()) return;
    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.grid && swiper.params.grid.rows > 1 ? swiper.slides.length / Math.ceil(swiper.params.grid.rows) : swiper.slides.length;
    let el = swiper.pagination.el;
    el = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(el);
    let paginationHTML = '';
    if (params.type === 'bullets') {
      let numberOfBullets = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
      if (swiper.params.freeMode && swiper.params.freeMode.enabled && numberOfBullets > slidesLength) {
        numberOfBullets = slidesLength;
      }
      for (let i = 0; i < numberOfBullets; i += 1) {
        if (params.renderBullet) {
          paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
        } else {
          // prettier-ignore
          paginationHTML += `<${params.bulletElement} ${swiper.isElement ? 'part="bullet"' : ''} class="${params.bulletClass}"></${params.bulletElement}>`;
        }
      }
    }
    if (params.type === 'fraction') {
      if (params.renderFraction) {
        paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
      } else {
        paginationHTML = `<span class="${params.currentClass}"></span>` + ' / ' + `<span class="${params.totalClass}"></span>`;
      }
    }
    if (params.type === 'progressbar') {
      if (params.renderProgressbar) {
        paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
      } else {
        paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
      }
    }
    swiper.pagination.bullets = [];
    el.forEach(subEl => {
      if (params.type !== 'custom') {
        subEl.innerHTML = paginationHTML || '';
      }
      if (params.type === 'bullets') {
        swiper.pagination.bullets.push(...subEl.querySelectorAll((0,_shared_classes_to_selector_mjs__WEBPACK_IMPORTED_MODULE_0__.c)(params.bulletClass)));
      }
    });
    if (params.type !== 'custom') {
      emit('paginationRender', el[0]);
    }
  }
  function init() {
    swiper.params.pagination = (0,_shared_create_element_if_not_defined_mjs__WEBPACK_IMPORTED_MODULE_1__.c)(swiper, swiper.originalParams.pagination, swiper.params.pagination, {
      el: 'swiper-pagination'
    });
    const params = swiper.params.pagination;
    if (!params.el) return;
    let el;
    if (typeof params.el === 'string' && swiper.isElement) {
      el = swiper.el.querySelector(params.el);
    }
    if (!el && typeof params.el === 'string') {
      el = [...document.querySelectorAll(params.el)];
    }
    if (!el) {
      el = params.el;
    }
    if (!el || el.length === 0) return;
    if (swiper.params.uniqueNavElements && typeof params.el === 'string' && Array.isArray(el) && el.length > 1) {
      el = [...swiper.el.querySelectorAll(params.el)];
      // check if it belongs to another nested Swiper
      if (el.length > 1) {
        el = el.filter(subEl => {
          if ((0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.a)(subEl, '.swiper')[0] !== swiper.el) return false;
          return true;
        })[0];
      }
    }
    if (Array.isArray(el) && el.length === 1) el = el[0];
    Object.assign(swiper.pagination, {
      el
    });
    el = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(el);
    el.forEach(subEl => {
      if (params.type === 'bullets' && params.clickable) {
        subEl.classList.add(...(params.clickableClass || '').split(' '));
      }
      subEl.classList.add(params.modifierClass + params.type);
      subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
      if (params.type === 'bullets' && params.dynamicBullets) {
        subEl.classList.add(`${params.modifierClass}${params.type}-dynamic`);
        dynamicBulletIndex = 0;
        if (params.dynamicMainBullets < 1) {
          params.dynamicMainBullets = 1;
        }
      }
      if (params.type === 'progressbar' && params.progressbarOpposite) {
        subEl.classList.add(params.progressbarOppositeClass);
      }
      if (params.clickable) {
        subEl.addEventListener('click', onBulletClick);
      }
      if (!swiper.enabled) {
        subEl.classList.add(params.lockClass);
      }
    });
  }
  function destroy() {
    const params = swiper.params.pagination;
    if (isPaginationDisabled()) return;
    let el = swiper.pagination.el;
    if (el) {
      el = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(el);
      el.forEach(subEl => {
        subEl.classList.remove(params.hiddenClass);
        subEl.classList.remove(params.modifierClass + params.type);
        subEl.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
        if (params.clickable) {
          subEl.classList.remove(...(params.clickableClass || '').split(' '));
          subEl.removeEventListener('click', onBulletClick);
        }
      });
    }
    if (swiper.pagination.bullets) swiper.pagination.bullets.forEach(subEl => subEl.classList.remove(...params.bulletActiveClass.split(' ')));
  }
  on('changeDirection', () => {
    if (!swiper.pagination || !swiper.pagination.el) return;
    const params = swiper.params.pagination;
    let {
      el
    } = swiper.pagination;
    el = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(el);
    el.forEach(subEl => {
      subEl.classList.remove(params.horizontalClass, params.verticalClass);
      subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
    });
  });
  on('init', () => {
    if (swiper.params.pagination.enabled === false) {
      // eslint-disable-next-line
      disable();
    } else {
      init();
      render();
      update();
    }
  });
  on('activeIndexChange', () => {
    if (typeof swiper.snapIndex === 'undefined') {
      update();
    }
  });
  on('snapIndexChange', () => {
    update();
  });
  on('snapGridLengthChange', () => {
    render();
    update();
  });
  on('destroy', () => {
    destroy();
  });
  on('enable disable', () => {
    let {
      el
    } = swiper.pagination;
    if (el) {
      el = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(el);
      el.forEach(subEl => subEl.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.pagination.lockClass));
    }
  });
  on('lock unlock', () => {
    update();
  });
  on('click', (_s, e) => {
    const targetEl = e.target;
    const el = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(swiper.pagination.el);
    if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && el && el.length > 0 && !targetEl.classList.contains(swiper.params.pagination.bulletClass)) {
      if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;
      const isHidden = el[0].classList.contains(swiper.params.pagination.hiddenClass);
      if (isHidden === true) {
        emit('paginationShow');
      } else {
        emit('paginationHide');
      }
      el.forEach(subEl => subEl.classList.toggle(swiper.params.pagination.hiddenClass));
    }
  });
  const enable = () => {
    swiper.el.classList.remove(swiper.params.pagination.paginationDisabledClass);
    let {
      el
    } = swiper.pagination;
    if (el) {
      el = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(el);
      el.forEach(subEl => subEl.classList.remove(swiper.params.pagination.paginationDisabledClass));
    }
    init();
    render();
    update();
  };
  const disable = () => {
    swiper.el.classList.add(swiper.params.pagination.paginationDisabledClass);
    let {
      el
    } = swiper.pagination;
    if (el) {
      el = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(el);
      el.forEach(subEl => subEl.classList.add(swiper.params.pagination.paginationDisabledClass));
    }
    destroy();
  };
  Object.assign(swiper.pagination, {
    enable,
    disable,
    render,
    update,
    init,
    destroy
  });
}




/***/ }),

/***/ "./node_modules/swiper/modules/parallax.mjs":
/*!**************************************************!*\
  !*** ./node_modules/swiper/modules/parallax.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Parallax)
/* harmony export */ });
/* harmony import */ var _shared_utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/utils.mjs */ "./node_modules/swiper/shared/utils.mjs");


function Parallax(_ref) {
  let {
    swiper,
    extendParams,
    on
  } = _ref;
  extendParams({
    parallax: {
      enabled: false
    }
  });
  const elementsSelector = '[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]';
  const setTransform = (el, progress) => {
    const {
      rtl
    } = swiper;
    const rtlFactor = rtl ? -1 : 1;
    const p = el.getAttribute('data-swiper-parallax') || '0';
    let x = el.getAttribute('data-swiper-parallax-x');
    let y = el.getAttribute('data-swiper-parallax-y');
    const scale = el.getAttribute('data-swiper-parallax-scale');
    const opacity = el.getAttribute('data-swiper-parallax-opacity');
    const rotate = el.getAttribute('data-swiper-parallax-rotate');
    if (x || y) {
      x = x || '0';
      y = y || '0';
    } else if (swiper.isHorizontal()) {
      x = p;
      y = '0';
    } else {
      y = p;
      x = '0';
    }
    if (x.indexOf('%') >= 0) {
      x = `${parseInt(x, 10) * progress * rtlFactor}%`;
    } else {
      x = `${x * progress * rtlFactor}px`;
    }
    if (y.indexOf('%') >= 0) {
      y = `${parseInt(y, 10) * progress}%`;
    } else {
      y = `${y * progress}px`;
    }
    if (typeof opacity !== 'undefined' && opacity !== null) {
      const currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));
      el.style.opacity = currentOpacity;
    }
    let transform = `translate3d(${x}, ${y}, 0px)`;
    if (typeof scale !== 'undefined' && scale !== null) {
      const currentScale = scale - (scale - 1) * (1 - Math.abs(progress));
      transform += ` scale(${currentScale})`;
    }
    if (rotate && typeof rotate !== 'undefined' && rotate !== null) {
      const currentRotate = rotate * progress * -1;
      transform += ` rotate(${currentRotate}deg)`;
    }
    el.style.transform = transform;
  };
  const setTranslate = () => {
    const {
      el,
      slides,
      progress,
      snapGrid,
      isElement
    } = swiper;
    const elements = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.e)(el, elementsSelector);
    if (swiper.isElement) {
      elements.push(...(0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.e)(swiper.hostEl, elementsSelector));
    }
    elements.forEach(subEl => {
      setTransform(subEl, progress);
    });
    slides.forEach((slideEl, slideIndex) => {
      let slideProgress = slideEl.progress;
      if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {
        slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);
      }
      slideProgress = Math.min(Math.max(slideProgress, -1), 1);
      slideEl.querySelectorAll(`${elementsSelector}, [data-swiper-parallax-rotate]`).forEach(subEl => {
        setTransform(subEl, slideProgress);
      });
    });
  };
  const setTransition = function (duration) {
    if (duration === void 0) {
      duration = swiper.params.speed;
    }
    const {
      el,
      hostEl
    } = swiper;
    const elements = [...el.querySelectorAll(elementsSelector)];
    if (swiper.isElement) {
      elements.push(...hostEl.querySelectorAll(elementsSelector));
    }
    elements.forEach(parallaxEl => {
      let parallaxDuration = parseInt(parallaxEl.getAttribute('data-swiper-parallax-duration'), 10) || duration;
      if (duration === 0) parallaxDuration = 0;
      parallaxEl.style.transitionDuration = `${parallaxDuration}ms`;
    });
  };
  on('beforeInit', () => {
    if (!swiper.params.parallax.enabled) return;
    swiper.params.watchSlidesProgress = true;
    swiper.originalParams.watchSlidesProgress = true;
  });
  on('init', () => {
    if (!swiper.params.parallax.enabled) return;
    setTranslate();
  });
  on('setTranslate', () => {
    if (!swiper.params.parallax.enabled) return;
    setTranslate();
  });
  on('setTransition', (_swiper, duration) => {
    if (!swiper.params.parallax.enabled) return;
    setTransition(duration);
  });
}




/***/ }),

/***/ "./node_modules/swiper/modules/scrollbar.mjs":
/*!***************************************************!*\
  !*** ./node_modules/swiper/modules/scrollbar.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Scrollbar)
/* harmony export */ });
/* harmony import */ var _shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/ssr-window.esm.mjs */ "./node_modules/swiper/shared/ssr-window.esm.mjs");
/* harmony import */ var _shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.mjs */ "./node_modules/swiper/shared/utils.mjs");
/* harmony import */ var _shared_create_element_if_not_defined_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/create-element-if-not-defined.mjs */ "./node_modules/swiper/shared/create-element-if-not-defined.mjs");
/* harmony import */ var _shared_classes_to_selector_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/classes-to-selector.mjs */ "./node_modules/swiper/shared/classes-to-selector.mjs");





function Scrollbar(_ref) {
  let {
    swiper,
    extendParams,
    on,
    emit
  } = _ref;
  const document = (0,_shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();
  let isTouched = false;
  let timeout = null;
  let dragTimeout = null;
  let dragStartPos;
  let dragSize;
  let trackSize;
  let divider;
  extendParams({
    scrollbar: {
      el: null,
      dragSize: 'auto',
      hide: false,
      draggable: false,
      snapOnRelease: true,
      lockClass: 'swiper-scrollbar-lock',
      dragClass: 'swiper-scrollbar-drag',
      scrollbarDisabledClass: 'swiper-scrollbar-disabled',
      horizontalClass: `swiper-scrollbar-horizontal`,
      verticalClass: `swiper-scrollbar-vertical`
    }
  });
  swiper.scrollbar = {
    el: null,
    dragEl: null
  };
  function setTranslate() {
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    const {
      scrollbar,
      rtlTranslate: rtl
    } = swiper;
    const {
      dragEl,
      el
    } = scrollbar;
    const params = swiper.params.scrollbar;
    const progress = swiper.params.loop ? swiper.progressLoop : swiper.progress;
    let newSize = dragSize;
    let newPos = (trackSize - dragSize) * progress;
    if (rtl) {
      newPos = -newPos;
      if (newPos > 0) {
        newSize = dragSize - newPos;
        newPos = 0;
      } else if (-newPos + dragSize > trackSize) {
        newSize = trackSize + newPos;
      }
    } else if (newPos < 0) {
      newSize = dragSize + newPos;
      newPos = 0;
    } else if (newPos + dragSize > trackSize) {
      newSize = trackSize - newPos;
    }
    if (swiper.isHorizontal()) {
      dragEl.style.transform = `translate3d(${newPos}px, 0, 0)`;
      dragEl.style.width = `${newSize}px`;
    } else {
      dragEl.style.transform = `translate3d(0px, ${newPos}px, 0)`;
      dragEl.style.height = `${newSize}px`;
    }
    if (params.hide) {
      clearTimeout(timeout);
      el.style.opacity = 1;
      timeout = setTimeout(() => {
        el.style.opacity = 0;
        el.style.transitionDuration = '400ms';
      }, 1000);
    }
  }
  function setTransition(duration) {
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    swiper.scrollbar.dragEl.style.transitionDuration = `${duration}ms`;
  }
  function updateSize() {
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    const {
      scrollbar
    } = swiper;
    const {
      dragEl,
      el
    } = scrollbar;
    dragEl.style.width = '';
    dragEl.style.height = '';
    trackSize = swiper.isHorizontal() ? el.offsetWidth : el.offsetHeight;
    divider = swiper.size / (swiper.virtualSize + swiper.params.slidesOffsetBefore - (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));
    if (swiper.params.scrollbar.dragSize === 'auto') {
      dragSize = trackSize * divider;
    } else {
      dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
    }
    if (swiper.isHorizontal()) {
      dragEl.style.width = `${dragSize}px`;
    } else {
      dragEl.style.height = `${dragSize}px`;
    }
    if (divider >= 1) {
      el.style.display = 'none';
    } else {
      el.style.display = '';
    }
    if (swiper.params.scrollbar.hide) {
      el.style.opacity = 0;
    }
    if (swiper.params.watchOverflow && swiper.enabled) {
      scrollbar.el.classList[swiper.isLocked ? 'add' : 'remove'](swiper.params.scrollbar.lockClass);
    }
  }
  function getPointerPosition(e) {
    return swiper.isHorizontal() ? e.clientX : e.clientY;
  }
  function setDragPosition(e) {
    const {
      scrollbar,
      rtlTranslate: rtl
    } = swiper;
    const {
      el
    } = scrollbar;
    let positionRatio;
    positionRatio = (getPointerPosition(e) - (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.b)(el)[swiper.isHorizontal() ? 'left' : 'top'] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);
    positionRatio = Math.max(Math.min(positionRatio, 1), 0);
    if (rtl) {
      positionRatio = 1 - positionRatio;
    }
    const position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;
    swiper.updateProgress(position);
    swiper.setTranslate(position);
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }
  function onDragStart(e) {
    const params = swiper.params.scrollbar;
    const {
      scrollbar,
      wrapperEl
    } = swiper;
    const {
      el,
      dragEl
    } = scrollbar;
    isTouched = true;
    dragStartPos = e.target === dragEl ? getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top'] : null;
    e.preventDefault();
    e.stopPropagation();
    wrapperEl.style.transitionDuration = '100ms';
    dragEl.style.transitionDuration = '100ms';
    setDragPosition(e);
    clearTimeout(dragTimeout);
    el.style.transitionDuration = '0ms';
    if (params.hide) {
      el.style.opacity = 1;
    }
    if (swiper.params.cssMode) {
      swiper.wrapperEl.style['scroll-snap-type'] = 'none';
    }
    emit('scrollbarDragStart', e);
  }
  function onDragMove(e) {
    const {
      scrollbar,
      wrapperEl
    } = swiper;
    const {
      el,
      dragEl
    } = scrollbar;
    if (!isTouched) return;
    if (e.preventDefault && e.cancelable) e.preventDefault();else e.returnValue = false;
    setDragPosition(e);
    wrapperEl.style.transitionDuration = '0ms';
    el.style.transitionDuration = '0ms';
    dragEl.style.transitionDuration = '0ms';
    emit('scrollbarDragMove', e);
  }
  function onDragEnd(e) {
    const params = swiper.params.scrollbar;
    const {
      scrollbar,
      wrapperEl
    } = swiper;
    const {
      el
    } = scrollbar;
    if (!isTouched) return;
    isTouched = false;
    if (swiper.params.cssMode) {
      swiper.wrapperEl.style['scroll-snap-type'] = '';
      wrapperEl.style.transitionDuration = '';
    }
    if (params.hide) {
      clearTimeout(dragTimeout);
      dragTimeout = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.n)(() => {
        el.style.opacity = 0;
        el.style.transitionDuration = '400ms';
      }, 1000);
    }
    emit('scrollbarDragEnd', e);
    if (params.snapOnRelease) {
      swiper.slideToClosest();
    }
  }
  function events(method) {
    const {
      scrollbar,
      params
    } = swiper;
    const el = scrollbar.el;
    if (!el) return;
    const target = el;
    const activeListener = params.passiveListeners ? {
      passive: false,
      capture: false
    } : false;
    const passiveListener = params.passiveListeners ? {
      passive: true,
      capture: false
    } : false;
    if (!target) return;
    const eventMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';
    target[eventMethod]('pointerdown', onDragStart, activeListener);
    document[eventMethod]('pointermove', onDragMove, activeListener);
    document[eventMethod]('pointerup', onDragEnd, passiveListener);
  }
  function enableDraggable() {
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    events('on');
  }
  function disableDraggable() {
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    events('off');
  }
  function init() {
    const {
      scrollbar,
      el: swiperEl
    } = swiper;
    swiper.params.scrollbar = (0,_shared_create_element_if_not_defined_mjs__WEBPACK_IMPORTED_MODULE_2__.c)(swiper, swiper.originalParams.scrollbar, swiper.params.scrollbar, {
      el: 'swiper-scrollbar'
    });
    const params = swiper.params.scrollbar;
    if (!params.el) return;
    let el;
    if (typeof params.el === 'string' && swiper.isElement) {
      el = swiper.el.querySelector(params.el);
    }
    if (!el && typeof params.el === 'string') {
      el = document.querySelectorAll(params.el);
      if (!el.length) return;
    } else if (!el) {
      el = params.el;
    }
    if (swiper.params.uniqueNavElements && typeof params.el === 'string' && el.length > 1 && swiperEl.querySelectorAll(params.el).length === 1) {
      el = swiperEl.querySelector(params.el);
    }
    if (el.length > 0) el = el[0];
    el.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
    let dragEl;
    if (el) {
      dragEl = el.querySelector((0,_shared_classes_to_selector_mjs__WEBPACK_IMPORTED_MODULE_3__.c)(swiper.params.scrollbar.dragClass));
      if (!dragEl) {
        dragEl = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.c)('div', swiper.params.scrollbar.dragClass);
        el.append(dragEl);
      }
    }
    Object.assign(scrollbar, {
      el,
      dragEl
    });
    if (params.draggable) {
      enableDraggable();
    }
    if (el) {
      el.classList[swiper.enabled ? 'remove' : 'add'](...(0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.i)(swiper.params.scrollbar.lockClass));
    }
  }
  function destroy() {
    const params = swiper.params.scrollbar;
    const el = swiper.scrollbar.el;
    if (el) {
      el.classList.remove(...(0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.i)(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass));
    }
    disableDraggable();
  }
  on('changeDirection', () => {
    if (!swiper.scrollbar || !swiper.scrollbar.el) return;
    const params = swiper.params.scrollbar;
    let {
      el
    } = swiper.scrollbar;
    el = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.m)(el);
    el.forEach(subEl => {
      subEl.classList.remove(params.horizontalClass, params.verticalClass);
      subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
    });
  });
  on('init', () => {
    if (swiper.params.scrollbar.enabled === false) {
      // eslint-disable-next-line
      disable();
    } else {
      init();
      updateSize();
      setTranslate();
    }
  });
  on('update resize observerUpdate lock unlock changeDirection', () => {
    updateSize();
  });
  on('setTranslate', () => {
    setTranslate();
  });
  on('setTransition', (_s, duration) => {
    setTransition(duration);
  });
  on('enable disable', () => {
    const {
      el
    } = swiper.scrollbar;
    if (el) {
      el.classList[swiper.enabled ? 'remove' : 'add'](...(0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.i)(swiper.params.scrollbar.lockClass));
    }
  });
  on('destroy', () => {
    destroy();
  });
  const enable = () => {
    swiper.el.classList.remove(...(0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.i)(swiper.params.scrollbar.scrollbarDisabledClass));
    if (swiper.scrollbar.el) {
      swiper.scrollbar.el.classList.remove(...(0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.i)(swiper.params.scrollbar.scrollbarDisabledClass));
    }
    init();
    updateSize();
    setTranslate();
  };
  const disable = () => {
    swiper.el.classList.add(...(0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.i)(swiper.params.scrollbar.scrollbarDisabledClass));
    if (swiper.scrollbar.el) {
      swiper.scrollbar.el.classList.add(...(0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.i)(swiper.params.scrollbar.scrollbarDisabledClass));
    }
    destroy();
  };
  Object.assign(swiper.scrollbar, {
    enable,
    disable,
    updateSize,
    setTranslate,
    init,
    destroy
  });
}




/***/ }),

/***/ "./node_modules/swiper/modules/thumbs.mjs":
/*!************************************************!*\
  !*** ./node_modules/swiper/modules/thumbs.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Thumb)
/* harmony export */ });
/* harmony import */ var _shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/ssr-window.esm.mjs */ "./node_modules/swiper/shared/ssr-window.esm.mjs");
/* harmony import */ var _shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.mjs */ "./node_modules/swiper/shared/utils.mjs");



function Thumb(_ref) {
  let {
    swiper,
    extendParams,
    on
  } = _ref;
  extendParams({
    thumbs: {
      swiper: null,
      multipleActiveThumbs: true,
      autoScrollOffset: 0,
      slideThumbActiveClass: 'swiper-slide-thumb-active',
      thumbsContainerClass: 'swiper-thumbs'
    }
  });
  let initialized = false;
  let swiperCreated = false;
  swiper.thumbs = {
    swiper: null
  };
  function onThumbClick() {
    const thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper || thumbsSwiper.destroyed) return;
    const clickedIndex = thumbsSwiper.clickedIndex;
    const clickedSlide = thumbsSwiper.clickedSlide;
    if (clickedSlide && clickedSlide.classList.contains(swiper.params.thumbs.slideThumbActiveClass)) return;
    if (typeof clickedIndex === 'undefined' || clickedIndex === null) return;
    let slideToIndex;
    if (thumbsSwiper.params.loop) {
      slideToIndex = parseInt(thumbsSwiper.clickedSlide.getAttribute('data-swiper-slide-index'), 10);
    } else {
      slideToIndex = clickedIndex;
    }
    if (swiper.params.loop) {
      swiper.slideToLoop(slideToIndex);
    } else {
      swiper.slideTo(slideToIndex);
    }
  }
  function init() {
    const {
      thumbs: thumbsParams
    } = swiper.params;
    if (initialized) return false;
    initialized = true;
    const SwiperClass = swiper.constructor;
    if (thumbsParams.swiper instanceof SwiperClass) {
      swiper.thumbs.swiper = thumbsParams.swiper;
      Object.assign(swiper.thumbs.swiper.originalParams, {
        watchSlidesProgress: true,
        slideToClickedSlide: false
      });
      Object.assign(swiper.thumbs.swiper.params, {
        watchSlidesProgress: true,
        slideToClickedSlide: false
      });
      swiper.thumbs.swiper.update();
    } else if ((0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.l)(thumbsParams.swiper)) {
      const thumbsSwiperParams = Object.assign({}, thumbsParams.swiper);
      Object.assign(thumbsSwiperParams, {
        watchSlidesProgress: true,
        slideToClickedSlide: false
      });
      swiper.thumbs.swiper = new SwiperClass(thumbsSwiperParams);
      swiperCreated = true;
    }
    swiper.thumbs.swiper.el.classList.add(swiper.params.thumbs.thumbsContainerClass);
    swiper.thumbs.swiper.on('tap', onThumbClick);
    return true;
  }
  function update(initial) {
    const thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper || thumbsSwiper.destroyed) return;
    const slidesPerView = thumbsSwiper.params.slidesPerView === 'auto' ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;

    // Activate thumbs
    let thumbsToActivate = 1;
    const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;
    if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {
      thumbsToActivate = swiper.params.slidesPerView;
    }
    if (!swiper.params.thumbs.multipleActiveThumbs) {
      thumbsToActivate = 1;
    }
    thumbsToActivate = Math.floor(thumbsToActivate);
    thumbsSwiper.slides.forEach(slideEl => slideEl.classList.remove(thumbActiveClass));
    if (thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) {
      for (let i = 0; i < thumbsToActivate; i += 1) {
        (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(thumbsSwiper.slidesEl, `[data-swiper-slide-index="${swiper.realIndex + i}"]`).forEach(slideEl => {
          slideEl.classList.add(thumbActiveClass);
        });
      }
    } else {
      for (let i = 0; i < thumbsToActivate; i += 1) {
        if (thumbsSwiper.slides[swiper.realIndex + i]) {
          thumbsSwiper.slides[swiper.realIndex + i].classList.add(thumbActiveClass);
        }
      }
    }
    const autoScrollOffset = swiper.params.thumbs.autoScrollOffset;
    const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;
    if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {
      const currentThumbsIndex = thumbsSwiper.activeIndex;
      let newThumbsIndex;
      let direction;
      if (thumbsSwiper.params.loop) {
        const newThumbsSlide = thumbsSwiper.slides.filter(slideEl => slideEl.getAttribute('data-swiper-slide-index') === `${swiper.realIndex}`)[0];
        newThumbsIndex = thumbsSwiper.slides.indexOf(newThumbsSlide);
        direction = swiper.activeIndex > swiper.previousIndex ? 'next' : 'prev';
      } else {
        newThumbsIndex = swiper.realIndex;
        direction = newThumbsIndex > swiper.previousIndex ? 'next' : 'prev';
      }
      if (useOffset) {
        newThumbsIndex += direction === 'next' ? autoScrollOffset : -1 * autoScrollOffset;
      }
      if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {
        if (thumbsSwiper.params.centeredSlides) {
          if (newThumbsIndex > currentThumbsIndex) {
            newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;
          } else {
            newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;
          }
        } else if (newThumbsIndex > currentThumbsIndex && thumbsSwiper.params.slidesPerGroup === 1) ;
        thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);
      }
    }
  }
  on('beforeInit', () => {
    const {
      thumbs
    } = swiper.params;
    if (!thumbs || !thumbs.swiper) return;
    if (typeof thumbs.swiper === 'string' || thumbs.swiper instanceof HTMLElement) {
      const document = (0,_shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();
      const getThumbsElementAndInit = () => {
        const thumbsElement = typeof thumbs.swiper === 'string' ? document.querySelector(thumbs.swiper) : thumbs.swiper;
        if (thumbsElement && thumbsElement.swiper) {
          thumbs.swiper = thumbsElement.swiper;
          init();
          update(true);
        } else if (thumbsElement) {
          const eventName = `${swiper.params.eventsPrefix}init`;
          const onThumbsSwiper = e => {
            thumbs.swiper = e.detail[0];
            thumbsElement.removeEventListener(eventName, onThumbsSwiper);
            init();
            update(true);
            thumbs.swiper.update();
            swiper.update();
          };
          thumbsElement.addEventListener(eventName, onThumbsSwiper);
        }
        return thumbsElement;
      };
      const watchForThumbsToAppear = () => {
        if (swiper.destroyed) return;
        const thumbsElement = getThumbsElementAndInit();
        if (!thumbsElement) {
          requestAnimationFrame(watchForThumbsToAppear);
        }
      };
      requestAnimationFrame(watchForThumbsToAppear);
    } else {
      init();
      update(true);
    }
  });
  on('slideChange update resize observerUpdate', () => {
    update();
  });
  on('setTransition', (_s, duration) => {
    const thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper || thumbsSwiper.destroyed) return;
    thumbsSwiper.setTransition(duration);
  });
  on('beforeDestroy', () => {
    const thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper || thumbsSwiper.destroyed) return;
    if (swiperCreated) {
      thumbsSwiper.destroy();
    }
  });
  Object.assign(swiper.thumbs, {
    init,
    update
  });
}




/***/ }),

/***/ "./node_modules/swiper/modules/virtual.mjs":
/*!*************************************************!*\
  !*** ./node_modules/swiper/modules/virtual.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Virtual)
/* harmony export */ });
/* harmony import */ var _shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/ssr-window.esm.mjs */ "./node_modules/swiper/shared/ssr-window.esm.mjs");
/* harmony import */ var _shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.mjs */ "./node_modules/swiper/shared/utils.mjs");



function Virtual(_ref) {
  let {
    swiper,
    extendParams,
    on,
    emit
  } = _ref;
  extendParams({
    virtual: {
      enabled: false,
      slides: [],
      cache: true,
      renderSlide: null,
      renderExternal: null,
      renderExternalUpdate: true,
      addSlidesBefore: 0,
      addSlidesAfter: 0
    }
  });
  let cssModeTimeout;
  const document = (0,_shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();
  swiper.virtual = {
    cache: {},
    from: undefined,
    to: undefined,
    slides: [],
    offset: 0,
    slidesGrid: []
  };
  const tempDOM = document.createElement('div');
  function renderSlide(slide, index) {
    const params = swiper.params.virtual;
    if (params.cache && swiper.virtual.cache[index]) {
      return swiper.virtual.cache[index];
    }
    // eslint-disable-next-line
    let slideEl;
    if (params.renderSlide) {
      slideEl = params.renderSlide.call(swiper, slide, index);
      if (typeof slideEl === 'string') {
        tempDOM.innerHTML = slideEl;
        slideEl = tempDOM.children[0];
      }
    } else if (swiper.isElement) {
      slideEl = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.c)('swiper-slide');
    } else {
      slideEl = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.c)('div', swiper.params.slideClass);
    }
    slideEl.setAttribute('data-swiper-slide-index', index);
    if (!params.renderSlide) {
      slideEl.innerHTML = slide;
    }
    if (params.cache) {
      swiper.virtual.cache[index] = slideEl;
    }
    return slideEl;
  }
  function update(force, beforeInit) {
    const {
      slidesPerView,
      slidesPerGroup,
      centeredSlides,
      loop: isLoop,
      initialSlide
    } = swiper.params;
    if (beforeInit && !isLoop && initialSlide > 0) {
      return;
    }
    const {
      addSlidesBefore,
      addSlidesAfter
    } = swiper.params.virtual;
    const {
      from: previousFrom,
      to: previousTo,
      slides,
      slidesGrid: previousSlidesGrid,
      offset: previousOffset
    } = swiper.virtual;
    if (!swiper.params.cssMode) {
      swiper.updateActiveIndex();
    }
    const activeIndex = swiper.activeIndex || 0;
    let offsetProp;
    if (swiper.rtlTranslate) offsetProp = 'right';else offsetProp = swiper.isHorizontal() ? 'left' : 'top';
    let slidesAfter;
    let slidesBefore;
    if (centeredSlides) {
      slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;
      slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;
    } else {
      slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesAfter;
      slidesBefore = (isLoop ? slidesPerView : slidesPerGroup) + addSlidesBefore;
    }
    let from = activeIndex - slidesBefore;
    let to = activeIndex + slidesAfter;
    if (!isLoop) {
      from = Math.max(from, 0);
      to = Math.min(to, slides.length - 1);
    }
    let offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);
    if (isLoop && activeIndex >= slidesBefore) {
      from -= slidesBefore;
      if (!centeredSlides) offset += swiper.slidesGrid[0];
    } else if (isLoop && activeIndex < slidesBefore) {
      from = -slidesBefore;
      if (centeredSlides) offset += swiper.slidesGrid[0];
    }
    Object.assign(swiper.virtual, {
      from,
      to,
      offset,
      slidesGrid: swiper.slidesGrid,
      slidesBefore,
      slidesAfter
    });
    function onRendered() {
      swiper.updateSlides();
      swiper.updateProgress();
      swiper.updateSlidesClasses();
      emit('virtualUpdate');
    }
    if (previousFrom === from && previousTo === to && !force) {
      if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {
        swiper.slides.forEach(slideEl => {
          slideEl.style[offsetProp] = `${offset - Math.abs(swiper.cssOverflowAdjustment())}px`;
        });
      }
      swiper.updateProgress();
      emit('virtualUpdate');
      return;
    }
    if (swiper.params.virtual.renderExternal) {
      swiper.params.virtual.renderExternal.call(swiper, {
        offset,
        from,
        to,
        slides: function getSlides() {
          const slidesToRender = [];
          for (let i = from; i <= to; i += 1) {
            slidesToRender.push(slides[i]);
          }
          return slidesToRender;
        }()
      });
      if (swiper.params.virtual.renderExternalUpdate) {
        onRendered();
      } else {
        emit('virtualUpdate');
      }
      return;
    }
    const prependIndexes = [];
    const appendIndexes = [];
    const getSlideIndex = index => {
      let slideIndex = index;
      if (index < 0) {
        slideIndex = slides.length + index;
      } else if (slideIndex >= slides.length) {
        // eslint-disable-next-line
        slideIndex = slideIndex - slides.length;
      }
      return slideIndex;
    };
    if (force) {
      swiper.slides.filter(el => el.matches(`.${swiper.params.slideClass}, swiper-slide`)).forEach(slideEl => {
        slideEl.remove();
      });
    } else {
      for (let i = previousFrom; i <= previousTo; i += 1) {
        if (i < from || i > to) {
          const slideIndex = getSlideIndex(i);
          swiper.slides.filter(el => el.matches(`.${swiper.params.slideClass}[data-swiper-slide-index="${slideIndex}"], swiper-slide[data-swiper-slide-index="${slideIndex}"]`)).forEach(slideEl => {
            slideEl.remove();
          });
        }
      }
    }
    const loopFrom = isLoop ? -slides.length : 0;
    const loopTo = isLoop ? slides.length * 2 : slides.length;
    for (let i = loopFrom; i < loopTo; i += 1) {
      if (i >= from && i <= to) {
        const slideIndex = getSlideIndex(i);
        if (typeof previousTo === 'undefined' || force) {
          appendIndexes.push(slideIndex);
        } else {
          if (i > previousTo) appendIndexes.push(slideIndex);
          if (i < previousFrom) prependIndexes.push(slideIndex);
        }
      }
    }
    appendIndexes.forEach(index => {
      swiper.slidesEl.append(renderSlide(slides[index], index));
    });
    if (isLoop) {
      for (let i = prependIndexes.length - 1; i >= 0; i -= 1) {
        const index = prependIndexes[i];
        swiper.slidesEl.prepend(renderSlide(slides[index], index));
      }
    } else {
      prependIndexes.sort((a, b) => b - a);
      prependIndexes.forEach(index => {
        swiper.slidesEl.prepend(renderSlide(slides[index], index));
      });
    }
    (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(swiper.slidesEl, '.swiper-slide, swiper-slide').forEach(slideEl => {
      slideEl.style[offsetProp] = `${offset - Math.abs(swiper.cssOverflowAdjustment())}px`;
    });
    onRendered();
  }
  function appendSlide(slides) {
    if (typeof slides === 'object' && 'length' in slides) {
      for (let i = 0; i < slides.length; i += 1) {
        if (slides[i]) swiper.virtual.slides.push(slides[i]);
      }
    } else {
      swiper.virtual.slides.push(slides);
    }
    update(true);
  }
  function prependSlide(slides) {
    const activeIndex = swiper.activeIndex;
    let newActiveIndex = activeIndex + 1;
    let numberOfNewSlides = 1;
    if (Array.isArray(slides)) {
      for (let i = 0; i < slides.length; i += 1) {
        if (slides[i]) swiper.virtual.slides.unshift(slides[i]);
      }
      newActiveIndex = activeIndex + slides.length;
      numberOfNewSlides = slides.length;
    } else {
      swiper.virtual.slides.unshift(slides);
    }
    if (swiper.params.virtual.cache) {
      const cache = swiper.virtual.cache;
      const newCache = {};
      Object.keys(cache).forEach(cachedIndex => {
        const cachedEl = cache[cachedIndex];
        const cachedElIndex = cachedEl.getAttribute('data-swiper-slide-index');
        if (cachedElIndex) {
          cachedEl.setAttribute('data-swiper-slide-index', parseInt(cachedElIndex, 10) + numberOfNewSlides);
        }
        newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = cachedEl;
      });
      swiper.virtual.cache = newCache;
    }
    update(true);
    swiper.slideTo(newActiveIndex, 0);
  }
  function removeSlide(slidesIndexes) {
    if (typeof slidesIndexes === 'undefined' || slidesIndexes === null) return;
    let activeIndex = swiper.activeIndex;
    if (Array.isArray(slidesIndexes)) {
      for (let i = slidesIndexes.length - 1; i >= 0; i -= 1) {
        if (swiper.params.virtual.cache) {
          delete swiper.virtual.cache[slidesIndexes[i]];
          // shift cache indexes
          Object.keys(swiper.virtual.cache).forEach(key => {
            if (key > slidesIndexes) {
              swiper.virtual.cache[key - 1] = swiper.virtual.cache[key];
              swiper.virtual.cache[key - 1].setAttribute('data-swiper-slide-index', key - 1);
              delete swiper.virtual.cache[key];
            }
          });
        }
        swiper.virtual.slides.splice(slidesIndexes[i], 1);
        if (slidesIndexes[i] < activeIndex) activeIndex -= 1;
        activeIndex = Math.max(activeIndex, 0);
      }
    } else {
      if (swiper.params.virtual.cache) {
        delete swiper.virtual.cache[slidesIndexes];
        // shift cache indexes
        Object.keys(swiper.virtual.cache).forEach(key => {
          if (key > slidesIndexes) {
            swiper.virtual.cache[key - 1] = swiper.virtual.cache[key];
            swiper.virtual.cache[key - 1].setAttribute('data-swiper-slide-index', key - 1);
            delete swiper.virtual.cache[key];
          }
        });
      }
      swiper.virtual.slides.splice(slidesIndexes, 1);
      if (slidesIndexes < activeIndex) activeIndex -= 1;
      activeIndex = Math.max(activeIndex, 0);
    }
    update(true);
    swiper.slideTo(activeIndex, 0);
  }
  function removeAllSlides() {
    swiper.virtual.slides = [];
    if (swiper.params.virtual.cache) {
      swiper.virtual.cache = {};
    }
    update(true);
    swiper.slideTo(0, 0);
  }
  on('beforeInit', () => {
    if (!swiper.params.virtual.enabled) return;
    let domSlidesAssigned;
    if (typeof swiper.passedParams.virtual.slides === 'undefined') {
      const slides = [...swiper.slidesEl.children].filter(el => el.matches(`.${swiper.params.slideClass}, swiper-slide`));
      if (slides && slides.length) {
        swiper.virtual.slides = [...slides];
        domSlidesAssigned = true;
        slides.forEach((slideEl, slideIndex) => {
          slideEl.setAttribute('data-swiper-slide-index', slideIndex);
          swiper.virtual.cache[slideIndex] = slideEl;
          slideEl.remove();
        });
      }
    }
    if (!domSlidesAssigned) {
      swiper.virtual.slides = swiper.params.virtual.slides;
    }
    swiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);
    swiper.params.watchSlidesProgress = true;
    swiper.originalParams.watchSlidesProgress = true;
    update(false, true);
  });
  on('setTranslate', () => {
    if (!swiper.params.virtual.enabled) return;
    if (swiper.params.cssMode && !swiper._immediateVirtual) {
      clearTimeout(cssModeTimeout);
      cssModeTimeout = setTimeout(() => {
        update();
      }, 100);
    } else {
      update();
    }
  });
  on('init update resize', () => {
    if (!swiper.params.virtual.enabled) return;
    if (swiper.params.cssMode) {
      (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.s)(swiper.wrapperEl, '--swiper-virtual-size', `${swiper.virtualSize}px`);
    }
  });
  Object.assign(swiper.virtual, {
    appendSlide,
    prependSlide,
    removeSlide,
    removeAllSlides,
    update
  });
}




/***/ }),

/***/ "./node_modules/swiper/modules/zoom.mjs":
/*!**********************************************!*\
  !*** ./node_modules/swiper/modules/zoom.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Zoom)
/* harmony export */ });
/* harmony import */ var _shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/ssr-window.esm.mjs */ "./node_modules/swiper/shared/ssr-window.esm.mjs");
/* harmony import */ var _shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.mjs */ "./node_modules/swiper/shared/utils.mjs");



function Zoom(_ref) {
  let {
    swiper,
    extendParams,
    on,
    emit
  } = _ref;
  const window = (0,_shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();
  extendParams({
    zoom: {
      enabled: false,
      limitToOriginalSize: false,
      maxRatio: 3,
      minRatio: 1,
      toggle: true,
      containerClass: 'swiper-zoom-container',
      zoomedSlideClass: 'swiper-slide-zoomed'
    }
  });
  swiper.zoom = {
    enabled: false
  };
  let currentScale = 1;
  let isScaling = false;
  let fakeGestureTouched;
  let fakeGestureMoved;
  const evCache = [];
  const gesture = {
    originX: 0,
    originY: 0,
    slideEl: undefined,
    slideWidth: undefined,
    slideHeight: undefined,
    imageEl: undefined,
    imageWrapEl: undefined,
    maxRatio: 3
  };
  const image = {
    isTouched: undefined,
    isMoved: undefined,
    currentX: undefined,
    currentY: undefined,
    minX: undefined,
    minY: undefined,
    maxX: undefined,
    maxY: undefined,
    width: undefined,
    height: undefined,
    startX: undefined,
    startY: undefined,
    touchesStart: {},
    touchesCurrent: {}
  };
  const velocity = {
    x: undefined,
    y: undefined,
    prevPositionX: undefined,
    prevPositionY: undefined,
    prevTime: undefined
  };
  let scale = 1;
  Object.defineProperty(swiper.zoom, 'scale', {
    get() {
      return scale;
    },
    set(value) {
      if (scale !== value) {
        const imageEl = gesture.imageEl;
        const slideEl = gesture.slideEl;
        emit('zoomChange', value, imageEl, slideEl);
      }
      scale = value;
    }
  });
  function getDistanceBetweenTouches() {
    if (evCache.length < 2) return 1;
    const x1 = evCache[0].pageX;
    const y1 = evCache[0].pageY;
    const x2 = evCache[1].pageX;
    const y2 = evCache[1].pageY;
    const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
    return distance;
  }
  function getMaxRatio() {
    const params = swiper.params.zoom;
    const maxRatio = gesture.imageWrapEl.getAttribute('data-swiper-zoom') || params.maxRatio;
    if (params.limitToOriginalSize && gesture.imageEl && gesture.imageEl.naturalWidth) {
      const imageMaxRatio = gesture.imageEl.naturalWidth / gesture.imageEl.offsetWidth;
      return Math.min(imageMaxRatio, maxRatio);
    }
    return maxRatio;
  }
  function getScaleOrigin() {
    if (evCache.length < 2) return {
      x: null,
      y: null
    };
    const box = gesture.imageEl.getBoundingClientRect();
    return [(evCache[0].pageX + (evCache[1].pageX - evCache[0].pageX) / 2 - box.x - window.scrollX) / currentScale, (evCache[0].pageY + (evCache[1].pageY - evCache[0].pageY) / 2 - box.y - window.scrollY) / currentScale];
  }
  function getSlideSelector() {
    return swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;
  }
  function eventWithinSlide(e) {
    const slideSelector = getSlideSelector();
    if (e.target.matches(slideSelector)) return true;
    if (swiper.slides.filter(slideEl => slideEl.contains(e.target)).length > 0) return true;
    return false;
  }
  function eventWithinZoomContainer(e) {
    const selector = `.${swiper.params.zoom.containerClass}`;
    if (e.target.matches(selector)) return true;
    if ([...swiper.hostEl.querySelectorAll(selector)].filter(containerEl => containerEl.contains(e.target)).length > 0) return true;
    return false;
  }

  // Events
  function onGestureStart(e) {
    if (e.pointerType === 'mouse') {
      evCache.splice(0, evCache.length);
    }
    if (!eventWithinSlide(e)) return;
    const params = swiper.params.zoom;
    fakeGestureTouched = false;
    fakeGestureMoved = false;
    evCache.push(e);
    if (evCache.length < 2) {
      return;
    }
    fakeGestureTouched = true;
    gesture.scaleStart = getDistanceBetweenTouches();
    if (!gesture.slideEl) {
      gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);
      if (!gesture.slideEl) gesture.slideEl = swiper.slides[swiper.activeIndex];
      let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);
      if (imageEl) {
        imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];
      }
      gesture.imageEl = imageEl;
      if (imageEl) {
        gesture.imageWrapEl = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.a)(gesture.imageEl, `.${params.containerClass}`)[0];
      } else {
        gesture.imageWrapEl = undefined;
      }
      if (!gesture.imageWrapEl) {
        gesture.imageEl = undefined;
        return;
      }
      gesture.maxRatio = getMaxRatio();
    }
    if (gesture.imageEl) {
      const [originX, originY] = getScaleOrigin();
      gesture.originX = originX;
      gesture.originY = originY;
      gesture.imageEl.style.transitionDuration = '0ms';
    }
    isScaling = true;
  }
  function onGestureChange(e) {
    if (!eventWithinSlide(e)) return;
    const params = swiper.params.zoom;
    const zoom = swiper.zoom;
    const pointerIndex = evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);
    if (pointerIndex >= 0) evCache[pointerIndex] = e;
    if (evCache.length < 2) {
      return;
    }
    fakeGestureMoved = true;
    gesture.scaleMove = getDistanceBetweenTouches();
    if (!gesture.imageEl) {
      return;
    }
    zoom.scale = gesture.scaleMove / gesture.scaleStart * currentScale;
    if (zoom.scale > gesture.maxRatio) {
      zoom.scale = gesture.maxRatio - 1 + (zoom.scale - gesture.maxRatio + 1) ** 0.5;
    }
    if (zoom.scale < params.minRatio) {
      zoom.scale = params.minRatio + 1 - (params.minRatio - zoom.scale + 1) ** 0.5;
    }
    gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;
  }
  function onGestureEnd(e) {
    if (!eventWithinSlide(e)) return;
    if (e.pointerType === 'mouse' && e.type === 'pointerout') return;
    const params = swiper.params.zoom;
    const zoom = swiper.zoom;
    const pointerIndex = evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);
    if (pointerIndex >= 0) evCache.splice(pointerIndex, 1);
    if (!fakeGestureTouched || !fakeGestureMoved) {
      return;
    }
    fakeGestureTouched = false;
    fakeGestureMoved = false;
    if (!gesture.imageEl) return;
    zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);
    gesture.imageEl.style.transitionDuration = `${swiper.params.speed}ms`;
    gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;
    currentScale = zoom.scale;
    isScaling = false;
    if (zoom.scale > 1 && gesture.slideEl) {
      gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);
    } else if (zoom.scale <= 1 && gesture.slideEl) {
      gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);
    }
    if (zoom.scale === 1) {
      gesture.originX = 0;
      gesture.originY = 0;
      gesture.slideEl = undefined;
    }
  }
  let allowTouchMoveTimeout;
  function allowTouchMove() {
    swiper.touchEventsData.preventTouchMoveFromPointerMove = false;
  }
  function preventTouchMove() {
    clearTimeout(allowTouchMoveTimeout);
    swiper.touchEventsData.preventTouchMoveFromPointerMove = true;
    allowTouchMoveTimeout = setTimeout(() => {
      if (swiper.destroyed) return;
      allowTouchMove();
    });
  }
  function onTouchStart(e) {
    const device = swiper.device;
    if (!gesture.imageEl) return;
    if (image.isTouched) return;
    if (device.android && e.cancelable) e.preventDefault();
    image.isTouched = true;
    const event = evCache.length > 0 ? evCache[0] : e;
    image.touchesStart.x = event.pageX;
    image.touchesStart.y = event.pageY;
  }
  function onTouchMove(e) {
    if (!eventWithinSlide(e) || !eventWithinZoomContainer(e)) {
      return;
    }
    const zoom = swiper.zoom;
    if (!gesture.imageEl) {
      return;
    }
    if (!image.isTouched || !gesture.slideEl) {
      return;
    }
    if (!image.isMoved) {
      image.width = gesture.imageEl.offsetWidth || gesture.imageEl.clientWidth;
      image.height = gesture.imageEl.offsetHeight || gesture.imageEl.clientHeight;
      image.startX = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.j)(gesture.imageWrapEl, 'x') || 0;
      image.startY = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.j)(gesture.imageWrapEl, 'y') || 0;
      gesture.slideWidth = gesture.slideEl.offsetWidth;
      gesture.slideHeight = gesture.slideEl.offsetHeight;
      gesture.imageWrapEl.style.transitionDuration = '0ms';
    }
    // Define if we need image drag
    const scaledWidth = image.width * zoom.scale;
    const scaledHeight = image.height * zoom.scale;
    image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
    image.maxX = -image.minX;
    image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
    image.maxY = -image.minY;
    image.touchesCurrent.x = evCache.length > 0 ? evCache[0].pageX : e.pageX;
    image.touchesCurrent.y = evCache.length > 0 ? evCache[0].pageY : e.pageY;
    const touchesDiff = Math.max(Math.abs(image.touchesCurrent.x - image.touchesStart.x), Math.abs(image.touchesCurrent.y - image.touchesStart.y));
    if (touchesDiff > 5) {
      swiper.allowClick = false;
    }
    if (!image.isMoved && !isScaling) {
      if (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {
        image.isTouched = false;
        allowTouchMove();
        return;
      }
      if (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {
        image.isTouched = false;
        allowTouchMove();
        return;
      }
    }
    if (e.cancelable) {
      e.preventDefault();
    }
    e.stopPropagation();
    preventTouchMove();
    image.isMoved = true;
    const scaleRatio = (zoom.scale - currentScale) / (gesture.maxRatio - swiper.params.zoom.minRatio);
    const {
      originX,
      originY
    } = gesture;
    image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX + scaleRatio * (image.width - originX * 2);
    image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY + scaleRatio * (image.height - originY * 2);
    if (image.currentX < image.minX) {
      image.currentX = image.minX + 1 - (image.minX - image.currentX + 1) ** 0.8;
    }
    if (image.currentX > image.maxX) {
      image.currentX = image.maxX - 1 + (image.currentX - image.maxX + 1) ** 0.8;
    }
    if (image.currentY < image.minY) {
      image.currentY = image.minY + 1 - (image.minY - image.currentY + 1) ** 0.8;
    }
    if (image.currentY > image.maxY) {
      image.currentY = image.maxY - 1 + (image.currentY - image.maxY + 1) ** 0.8;
    }

    // Velocity
    if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;
    if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;
    if (!velocity.prevTime) velocity.prevTime = Date.now();
    velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;
    velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;
    if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;
    if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;
    velocity.prevPositionX = image.touchesCurrent.x;
    velocity.prevPositionY = image.touchesCurrent.y;
    velocity.prevTime = Date.now();
    gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;
  }
  function onTouchEnd() {
    const zoom = swiper.zoom;
    if (!gesture.imageEl) return;
    if (!image.isTouched || !image.isMoved) {
      image.isTouched = false;
      image.isMoved = false;
      return;
    }
    image.isTouched = false;
    image.isMoved = false;
    let momentumDurationX = 300;
    let momentumDurationY = 300;
    const momentumDistanceX = velocity.x * momentumDurationX;
    const newPositionX = image.currentX + momentumDistanceX;
    const momentumDistanceY = velocity.y * momentumDurationY;
    const newPositionY = image.currentY + momentumDistanceY;

    // Fix duration
    if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);
    if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);
    const momentumDuration = Math.max(momentumDurationX, momentumDurationY);
    image.currentX = newPositionX;
    image.currentY = newPositionY;
    // Define if we need image drag
    const scaledWidth = image.width * zoom.scale;
    const scaledHeight = image.height * zoom.scale;
    image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
    image.maxX = -image.minX;
    image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
    image.maxY = -image.minY;
    image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);
    image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);
    gesture.imageWrapEl.style.transitionDuration = `${momentumDuration}ms`;
    gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;
  }
  function onTransitionEnd() {
    const zoom = swiper.zoom;
    if (gesture.slideEl && swiper.activeIndex !== swiper.slides.indexOf(gesture.slideEl)) {
      if (gesture.imageEl) {
        gesture.imageEl.style.transform = 'translate3d(0,0,0) scale(1)';
      }
      if (gesture.imageWrapEl) {
        gesture.imageWrapEl.style.transform = 'translate3d(0,0,0)';
      }
      gesture.slideEl.classList.remove(`${swiper.params.zoom.zoomedSlideClass}`);
      zoom.scale = 1;
      currentScale = 1;
      gesture.slideEl = undefined;
      gesture.imageEl = undefined;
      gesture.imageWrapEl = undefined;
      gesture.originX = 0;
      gesture.originY = 0;
    }
  }
  function zoomIn(e) {
    const zoom = swiper.zoom;
    const params = swiper.params.zoom;
    if (!gesture.slideEl) {
      if (e && e.target) {
        gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);
      }
      if (!gesture.slideEl) {
        if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
          gesture.slideEl = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];
        } else {
          gesture.slideEl = swiper.slides[swiper.activeIndex];
        }
      }
      let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);
      if (imageEl) {
        imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];
      }
      gesture.imageEl = imageEl;
      if (imageEl) {
        gesture.imageWrapEl = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.a)(gesture.imageEl, `.${params.containerClass}`)[0];
      } else {
        gesture.imageWrapEl = undefined;
      }
    }
    if (!gesture.imageEl || !gesture.imageWrapEl) return;
    if (swiper.params.cssMode) {
      swiper.wrapperEl.style.overflow = 'hidden';
      swiper.wrapperEl.style.touchAction = 'none';
    }
    gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);
    let touchX;
    let touchY;
    let offsetX;
    let offsetY;
    let diffX;
    let diffY;
    let translateX;
    let translateY;
    let imageWidth;
    let imageHeight;
    let scaledWidth;
    let scaledHeight;
    let translateMinX;
    let translateMinY;
    let translateMaxX;
    let translateMaxY;
    let slideWidth;
    let slideHeight;
    if (typeof image.touchesStart.x === 'undefined' && e) {
      touchX = e.pageX;
      touchY = e.pageY;
    } else {
      touchX = image.touchesStart.x;
      touchY = image.touchesStart.y;
    }
    const forceZoomRatio = typeof e === 'number' ? e : null;
    if (currentScale === 1 && forceZoomRatio) {
      touchX = undefined;
      touchY = undefined;
      image.touchesStart.x = undefined;
      image.touchesStart.y = undefined;
    }
    const maxRatio = getMaxRatio();
    zoom.scale = forceZoomRatio || maxRatio;
    currentScale = forceZoomRatio || maxRatio;
    if (e && !(currentScale === 1 && forceZoomRatio)) {
      slideWidth = gesture.slideEl.offsetWidth;
      slideHeight = gesture.slideEl.offsetHeight;
      offsetX = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.b)(gesture.slideEl).left + window.scrollX;
      offsetY = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.b)(gesture.slideEl).top + window.scrollY;
      diffX = offsetX + slideWidth / 2 - touchX;
      diffY = offsetY + slideHeight / 2 - touchY;
      imageWidth = gesture.imageEl.offsetWidth || gesture.imageEl.clientWidth;
      imageHeight = gesture.imageEl.offsetHeight || gesture.imageEl.clientHeight;
      scaledWidth = imageWidth * zoom.scale;
      scaledHeight = imageHeight * zoom.scale;
      translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);
      translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);
      translateMaxX = -translateMinX;
      translateMaxY = -translateMinY;
      translateX = diffX * zoom.scale;
      translateY = diffY * zoom.scale;
      if (translateX < translateMinX) {
        translateX = translateMinX;
      }
      if (translateX > translateMaxX) {
        translateX = translateMaxX;
      }
      if (translateY < translateMinY) {
        translateY = translateMinY;
      }
      if (translateY > translateMaxY) {
        translateY = translateMaxY;
      }
    } else {
      translateX = 0;
      translateY = 0;
    }
    if (forceZoomRatio && zoom.scale === 1) {
      gesture.originX = 0;
      gesture.originY = 0;
    }
    gesture.imageWrapEl.style.transitionDuration = '300ms';
    gesture.imageWrapEl.style.transform = `translate3d(${translateX}px, ${translateY}px,0)`;
    gesture.imageEl.style.transitionDuration = '300ms';
    gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;
  }
  function zoomOut() {
    const zoom = swiper.zoom;
    const params = swiper.params.zoom;
    if (!gesture.slideEl) {
      if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
        gesture.slideEl = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];
      } else {
        gesture.slideEl = swiper.slides[swiper.activeIndex];
      }
      let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);
      if (imageEl) {
        imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];
      }
      gesture.imageEl = imageEl;
      if (imageEl) {
        gesture.imageWrapEl = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.a)(gesture.imageEl, `.${params.containerClass}`)[0];
      } else {
        gesture.imageWrapEl = undefined;
      }
    }
    if (!gesture.imageEl || !gesture.imageWrapEl) return;
    if (swiper.params.cssMode) {
      swiper.wrapperEl.style.overflow = '';
      swiper.wrapperEl.style.touchAction = '';
    }
    zoom.scale = 1;
    currentScale = 1;
    image.touchesStart.x = undefined;
    image.touchesStart.y = undefined;
    gesture.imageWrapEl.style.transitionDuration = '300ms';
    gesture.imageWrapEl.style.transform = 'translate3d(0,0,0)';
    gesture.imageEl.style.transitionDuration = '300ms';
    gesture.imageEl.style.transform = 'translate3d(0,0,0) scale(1)';
    gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);
    gesture.slideEl = undefined;
    gesture.originX = 0;
    gesture.originY = 0;
  }

  // Toggle Zoom
  function zoomToggle(e) {
    const zoom = swiper.zoom;
    if (zoom.scale && zoom.scale !== 1) {
      // Zoom Out
      zoomOut();
    } else {
      // Zoom In
      zoomIn(e);
    }
  }
  function getListeners() {
    const passiveListener = swiper.params.passiveListeners ? {
      passive: true,
      capture: false
    } : false;
    const activeListenerWithCapture = swiper.params.passiveListeners ? {
      passive: false,
      capture: true
    } : true;
    return {
      passiveListener,
      activeListenerWithCapture
    };
  }

  // Attach/Detach Events
  function enable() {
    const zoom = swiper.zoom;
    if (zoom.enabled) return;
    zoom.enabled = true;
    const {
      passiveListener,
      activeListenerWithCapture
    } = getListeners();

    // Scale image
    swiper.wrapperEl.addEventListener('pointerdown', onGestureStart, passiveListener);
    swiper.wrapperEl.addEventListener('pointermove', onGestureChange, activeListenerWithCapture);
    ['pointerup', 'pointercancel', 'pointerout'].forEach(eventName => {
      swiper.wrapperEl.addEventListener(eventName, onGestureEnd, passiveListener);
    });

    // Move image
    swiper.wrapperEl.addEventListener('pointermove', onTouchMove, activeListenerWithCapture);
  }
  function disable() {
    const zoom = swiper.zoom;
    if (!zoom.enabled) return;
    zoom.enabled = false;
    const {
      passiveListener,
      activeListenerWithCapture
    } = getListeners();

    // Scale image
    swiper.wrapperEl.removeEventListener('pointerdown', onGestureStart, passiveListener);
    swiper.wrapperEl.removeEventListener('pointermove', onGestureChange, activeListenerWithCapture);
    ['pointerup', 'pointercancel', 'pointerout'].forEach(eventName => {
      swiper.wrapperEl.removeEventListener(eventName, onGestureEnd, passiveListener);
    });

    // Move image
    swiper.wrapperEl.removeEventListener('pointermove', onTouchMove, activeListenerWithCapture);
  }
  on('init', () => {
    if (swiper.params.zoom.enabled) {
      enable();
    }
  });
  on('destroy', () => {
    disable();
  });
  on('touchStart', (_s, e) => {
    if (!swiper.zoom.enabled) return;
    onTouchStart(e);
  });
  on('touchEnd', (_s, e) => {
    if (!swiper.zoom.enabled) return;
    onTouchEnd();
  });
  on('doubleTap', (_s, e) => {
    if (!swiper.animating && swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {
      zoomToggle(e);
    }
  });
  on('transitionEnd', () => {
    if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
      onTransitionEnd();
    }
  });
  on('slideChange', () => {
    if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {
      onTransitionEnd();
    }
  });
  Object.assign(swiper.zoom, {
    enable,
    disable,
    in: zoomIn,
    out: zoomOut,
    toggle: zoomToggle
  });
}




/***/ }),

/***/ "./node_modules/swiper/shared/classes-to-selector.mjs":
/*!************************************************************!*\
  !*** ./node_modules/swiper/shared/classes-to-selector.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ classesToSelector)
/* harmony export */ });
function classesToSelector(classes) {
  if (classes === void 0) {
    classes = '';
  }
  return `.${classes.trim().replace(/([\.:!+\/])/g, '\\$1') // eslint-disable-line
  .replace(/ /g, '.')}`;
}




/***/ }),

/***/ "./node_modules/swiper/shared/create-element-if-not-defined.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/swiper/shared/create-element-if-not-defined.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ createElementIfNotDefined)
/* harmony export */ });
/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.mjs */ "./node_modules/swiper/shared/utils.mjs");


function createElementIfNotDefined(swiper, originalParams, params, checkProps) {
  if (swiper.params.createElements) {
    Object.keys(checkProps).forEach(key => {
      if (!params[key] && params.auto === true) {
        let element = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.e)(swiper.el, `.${checkProps[key]}`)[0];
        if (!element) {
          element = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.c)('div', checkProps[key]);
          element.className = checkProps[key];
          swiper.el.append(element);
        }
        params[key] = element;
        originalParams[key] = element;
      }
    });
  }
  return params;
}




/***/ }),

/***/ "./node_modules/swiper/shared/create-shadow.mjs":
/*!******************************************************!*\
  !*** ./node_modules/swiper/shared/create-shadow.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ createShadow)
/* harmony export */ });
/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.mjs */ "./node_modules/swiper/shared/utils.mjs");


function createShadow(suffix, slideEl, side) {
  const shadowClass = `swiper-slide-shadow${side ? `-${side}` : ''}${suffix ? ` swiper-slide-shadow-${suffix}` : ''}`;
  const shadowContainer = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(slideEl);
  let shadowEl = shadowContainer.querySelector(`.${shadowClass.split(' ').join('.')}`);
  if (!shadowEl) {
    shadowEl = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.c)('div', shadowClass.split(' '));
    shadowContainer.append(shadowEl);
  }
  return shadowEl;
}




/***/ }),

/***/ "./node_modules/swiper/shared/effect-init.mjs":
/*!****************************************************!*\
  !*** ./node_modules/swiper/shared/effect-init.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   e: () => (/* binding */ effectInit)
/* harmony export */ });
function effectInit(params) {
  const {
    effect,
    swiper,
    on,
    setTranslate,
    setTransition,
    overwriteParams,
    perspective,
    recreateShadows,
    getEffectParams
  } = params;
  on('beforeInit', () => {
    if (swiper.params.effect !== effect) return;
    swiper.classNames.push(`${swiper.params.containerModifierClass}${effect}`);
    if (perspective && perspective()) {
      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);
    }
    const overwriteParamsResult = overwriteParams ? overwriteParams() : {};
    Object.assign(swiper.params, overwriteParamsResult);
    Object.assign(swiper.originalParams, overwriteParamsResult);
  });
  on('setTranslate', () => {
    if (swiper.params.effect !== effect) return;
    setTranslate();
  });
  on('setTransition', (_s, duration) => {
    if (swiper.params.effect !== effect) return;
    setTransition(duration);
  });
  on('transitionEnd', () => {
    if (swiper.params.effect !== effect) return;
    if (recreateShadows) {
      if (!getEffectParams || !getEffectParams().slideShadows) return;
      // remove shadows
      swiper.slides.forEach(slideEl => {
        slideEl.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(shadowEl => shadowEl.remove());
      });
      // create new one
      recreateShadows();
    }
  });
  let requireUpdateOnVirtual;
  on('virtualUpdate', () => {
    if (swiper.params.effect !== effect) return;
    if (!swiper.slides.length) {
      requireUpdateOnVirtual = true;
    }
    requestAnimationFrame(() => {
      if (requireUpdateOnVirtual && swiper.slides && swiper.slides.length) {
        setTranslate();
        requireUpdateOnVirtual = false;
      }
    });
  });
}




/***/ }),

/***/ "./node_modules/swiper/shared/effect-target.mjs":
/*!******************************************************!*\
  !*** ./node_modules/swiper/shared/effect-target.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   e: () => (/* binding */ effectTarget)
/* harmony export */ });
/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.mjs */ "./node_modules/swiper/shared/utils.mjs");


function effectTarget(effectParams, slideEl) {
  const transformEl = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(slideEl);
  if (transformEl !== slideEl) {
    transformEl.style.backfaceVisibility = 'hidden';
    transformEl.style['-webkit-backface-visibility'] = 'hidden';
  }
  return transformEl;
}




/***/ }),

/***/ "./node_modules/swiper/shared/effect-virtual-transition-end.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/swiper/shared/effect-virtual-transition-end.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   e: () => (/* binding */ effectVirtualTransitionEnd)
/* harmony export */ });
/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.mjs */ "./node_modules/swiper/shared/utils.mjs");


function effectVirtualTransitionEnd(_ref) {
  let {
    swiper,
    duration,
    transformElements,
    allSlides
  } = _ref;
  const {
    activeIndex
  } = swiper;
  const getSlide = el => {
    if (!el.parentElement) {
      // assume shadow root
      const slide = swiper.slides.filter(slideEl => slideEl.shadowRoot && slideEl.shadowRoot === el.parentNode)[0];
      return slide;
    }
    return el.parentElement;
  };
  if (swiper.params.virtualTranslate && duration !== 0) {
    let eventTriggered = false;
    let transitionEndTarget;
    if (allSlides) {
      transitionEndTarget = transformElements;
    } else {
      transitionEndTarget = transformElements.filter(transformEl => {
        const el = transformEl.classList.contains('swiper-slide-transform') ? getSlide(transformEl) : transformEl;
        return swiper.getSlideIndex(el) === activeIndex;
      });
    }
    transitionEndTarget.forEach(el => {
      (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(el, () => {
        if (eventTriggered) return;
        if (!swiper || swiper.destroyed) return;
        eventTriggered = true;
        swiper.animating = false;
        const evt = new window.CustomEvent('transitionend', {
          bubbles: true,
          cancelable: true
        });
        swiper.wrapperEl.dispatchEvent(evt);
      });
    });
  }
}




/***/ }),

/***/ "./node_modules/swiper/shared/ssr-window.esm.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/swiper/shared/ssr-window.esm.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ getWindow),
/* harmony export */   g: () => (/* binding */ getDocument)
/* harmony export */ });
/**
 * SSR Window 4.0.2
 * Better handling for window object in SSR environment
 * https://github.com/nolimits4web/ssr-window
 *
 * Copyright 2021, Vladimir Kharlampidi
 *
 * Licensed under MIT
 *
 * Released on: December 13, 2021
 */
/* eslint-disable no-param-reassign */
function isObject(obj) {
  return obj !== null && typeof obj === 'object' && 'constructor' in obj && obj.constructor === Object;
}
function extend(target, src) {
  if (target === void 0) {
    target = {};
  }
  if (src === void 0) {
    src = {};
  }
  Object.keys(src).forEach(key => {
    if (typeof target[key] === 'undefined') target[key] = src[key];else if (isObject(src[key]) && isObject(target[key]) && Object.keys(src[key]).length > 0) {
      extend(target[key], src[key]);
    }
  });
}
const ssrDocument = {
  body: {},
  addEventListener() {},
  removeEventListener() {},
  activeElement: {
    blur() {},
    nodeName: ''
  },
  querySelector() {
    return null;
  },
  querySelectorAll() {
    return [];
  },
  getElementById() {
    return null;
  },
  createEvent() {
    return {
      initEvent() {}
    };
  },
  createElement() {
    return {
      children: [],
      childNodes: [],
      style: {},
      setAttribute() {},
      getElementsByTagName() {
        return [];
      }
    };
  },
  createElementNS() {
    return {};
  },
  importNode() {
    return null;
  },
  location: {
    hash: '',
    host: '',
    hostname: '',
    href: '',
    origin: '',
    pathname: '',
    protocol: '',
    search: ''
  }
};
function getDocument() {
  const doc = typeof document !== 'undefined' ? document : {};
  extend(doc, ssrDocument);
  return doc;
}
const ssrWindow = {
  document: ssrDocument,
  navigator: {
    userAgent: ''
  },
  location: {
    hash: '',
    host: '',
    hostname: '',
    href: '',
    origin: '',
    pathname: '',
    protocol: '',
    search: ''
  },
  history: {
    replaceState() {},
    pushState() {},
    go() {},
    back() {}
  },
  CustomEvent: function CustomEvent() {
    return this;
  },
  addEventListener() {},
  removeEventListener() {},
  getComputedStyle() {
    return {
      getPropertyValue() {
        return '';
      }
    };
  },
  Image() {},
  Date() {},
  screen: {},
  setTimeout() {},
  clearTimeout() {},
  matchMedia() {
    return {};
  },
  requestAnimationFrame(callback) {
    if (typeof setTimeout === 'undefined') {
      callback();
      return null;
    }
    return setTimeout(callback, 0);
  },
  cancelAnimationFrame(id) {
    if (typeof setTimeout === 'undefined') {
      return;
    }
    clearTimeout(id);
  }
};
function getWindow() {
  const win = typeof window !== 'undefined' ? window : {};
  extend(win, ssrWindow);
  return win;
}




/***/ }),

/***/ "./node_modules/swiper/shared/swiper-core.mjs":
/*!****************************************************!*\
  !*** ./node_modules/swiper/shared/swiper-core.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   S: () => (/* binding */ Swiper),
/* harmony export */   d: () => (/* binding */ defaults)
/* harmony export */ });
/* harmony import */ var _ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ssr-window.esm.mjs */ "./node_modules/swiper/shared/ssr-window.esm.mjs");
/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.mjs */ "./node_modules/swiper/shared/utils.mjs");



let support;
function calcSupport() {
  const window = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();
  const document = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();
  return {
    smoothScroll: document.documentElement && document.documentElement.style && 'scrollBehavior' in document.documentElement.style,
    touch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch)
  };
}
function getSupport() {
  if (!support) {
    support = calcSupport();
  }
  return support;
}

let deviceCached;
function calcDevice(_temp) {
  let {
    userAgent
  } = _temp === void 0 ? {} : _temp;
  const support = getSupport();
  const window = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();
  const platform = window.navigator.platform;
  const ua = userAgent || window.navigator.userAgent;
  const device = {
    ios: false,
    android: false
  };
  const screenWidth = window.screen.width;
  const screenHeight = window.screen.height;
  const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line
  let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
  const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
  const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
  const windows = platform === 'Win32';
  let macos = platform === 'MacIntel';

  // iPadOs 13 fix
  const iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];
  if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
    ipad = ua.match(/(Version)\/([\d.]+)/);
    if (!ipad) ipad = [0, 1, '13_0_0'];
    macos = false;
  }

  // Android
  if (android && !windows) {
    device.os = 'android';
    device.android = true;
  }
  if (ipad || iphone || ipod) {
    device.os = 'ios';
    device.ios = true;
  }

  // Export object
  return device;
}
function getDevice(overrides) {
  if (overrides === void 0) {
    overrides = {};
  }
  if (!deviceCached) {
    deviceCached = calcDevice(overrides);
  }
  return deviceCached;
}

let browser;
function calcBrowser() {
  const window = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();
  const device = getDevice();
  let needPerspectiveFix = false;
  function isSafari() {
    const ua = window.navigator.userAgent.toLowerCase();
    return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;
  }
  if (isSafari()) {
    const ua = String(window.navigator.userAgent);
    if (ua.includes('Version/')) {
      const [major, minor] = ua.split('Version/')[1].split(' ')[0].split('.').map(num => Number(num));
      needPerspectiveFix = major < 16 || major === 16 && minor < 2;
    }
  }
  const isWebView = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent);
  const isSafariBrowser = isSafari();
  const need3dFix = isSafariBrowser || isWebView && device.ios;
  return {
    isSafari: needPerspectiveFix || isSafariBrowser,
    needPerspectiveFix,
    need3dFix,
    isWebView
  };
}
function getBrowser() {
  if (!browser) {
    browser = calcBrowser();
  }
  return browser;
}

function Resize(_ref) {
  let {
    swiper,
    on,
    emit
  } = _ref;
  const window = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();
  let observer = null;
  let animationFrame = null;
  const resizeHandler = () => {
    if (!swiper || swiper.destroyed || !swiper.initialized) return;
    emit('beforeResize');
    emit('resize');
  };
  const createObserver = () => {
    if (!swiper || swiper.destroyed || !swiper.initialized) return;
    observer = new ResizeObserver(entries => {
      animationFrame = window.requestAnimationFrame(() => {
        const {
          width,
          height
        } = swiper;
        let newWidth = width;
        let newHeight = height;
        entries.forEach(_ref2 => {
          let {
            contentBoxSize,
            contentRect,
            target
          } = _ref2;
          if (target && target !== swiper.el) return;
          newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
          newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
        });
        if (newWidth !== width || newHeight !== height) {
          resizeHandler();
        }
      });
    });
    observer.observe(swiper.el);
  };
  const removeObserver = () => {
    if (animationFrame) {
      window.cancelAnimationFrame(animationFrame);
    }
    if (observer && observer.unobserve && swiper.el) {
      observer.unobserve(swiper.el);
      observer = null;
    }
  };
  const orientationChangeHandler = () => {
    if (!swiper || swiper.destroyed || !swiper.initialized) return;
    emit('orientationchange');
  };
  on('init', () => {
    if (swiper.params.resizeObserver && typeof window.ResizeObserver !== 'undefined') {
      createObserver();
      return;
    }
    window.addEventListener('resize', resizeHandler);
    window.addEventListener('orientationchange', orientationChangeHandler);
  });
  on('destroy', () => {
    removeObserver();
    window.removeEventListener('resize', resizeHandler);
    window.removeEventListener('orientationchange', orientationChangeHandler);
  });
}

function Observer(_ref) {
  let {
    swiper,
    extendParams,
    on,
    emit
  } = _ref;
  const observers = [];
  const window = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();
  const attach = function (target, options) {
    if (options === void 0) {
      options = {};
    }
    const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
    const observer = new ObserverFunc(mutations => {
      // The observerUpdate event should only be triggered
      // once despite the number of mutations.  Additional
      // triggers are redundant and are very costly
      if (swiper.__preventObserver__) return;
      if (mutations.length === 1) {
        emit('observerUpdate', mutations[0]);
        return;
      }
      const observerUpdate = function observerUpdate() {
        emit('observerUpdate', mutations[0]);
      };
      if (window.requestAnimationFrame) {
        window.requestAnimationFrame(observerUpdate);
      } else {
        window.setTimeout(observerUpdate, 0);
      }
    });
    observer.observe(target, {
      attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
      childList: swiper.isElement || (typeof options.childList === 'undefined' ? true : options).childList,
      characterData: typeof options.characterData === 'undefined' ? true : options.characterData
    });
    observers.push(observer);
  };
  const init = () => {
    if (!swiper.params.observer) return;
    if (swiper.params.observeParents) {
      const containerParents = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.a)(swiper.hostEl);
      for (let i = 0; i < containerParents.length; i += 1) {
        attach(containerParents[i]);
      }
    }
    // Observe container
    attach(swiper.hostEl, {
      childList: swiper.params.observeSlideChildren
    });

    // Observe wrapper
    attach(swiper.wrapperEl, {
      attributes: false
    });
  };
  const destroy = () => {
    observers.forEach(observer => {
      observer.disconnect();
    });
    observers.splice(0, observers.length);
  };
  extendParams({
    observer: false,
    observeParents: false,
    observeSlideChildren: false
  });
  on('init', init);
  on('destroy', destroy);
}

/* eslint-disable no-underscore-dangle */

var eventsEmitter = {
  on(events, handler, priority) {
    const self = this;
    if (!self.eventsListeners || self.destroyed) return self;
    if (typeof handler !== 'function') return self;
    const method = priority ? 'unshift' : 'push';
    events.split(' ').forEach(event => {
      if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
      self.eventsListeners[event][method](handler);
    });
    return self;
  },
  once(events, handler, priority) {
    const self = this;
    if (!self.eventsListeners || self.destroyed) return self;
    if (typeof handler !== 'function') return self;
    function onceHandler() {
      self.off(events, onceHandler);
      if (onceHandler.__emitterProxy) {
        delete onceHandler.__emitterProxy;
      }
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      handler.apply(self, args);
    }
    onceHandler.__emitterProxy = handler;
    return self.on(events, onceHandler, priority);
  },
  onAny(handler, priority) {
    const self = this;
    if (!self.eventsListeners || self.destroyed) return self;
    if (typeof handler !== 'function') return self;
    const method = priority ? 'unshift' : 'push';
    if (self.eventsAnyListeners.indexOf(handler) < 0) {
      self.eventsAnyListeners[method](handler);
    }
    return self;
  },
  offAny(handler) {
    const self = this;
    if (!self.eventsListeners || self.destroyed) return self;
    if (!self.eventsAnyListeners) return self;
    const index = self.eventsAnyListeners.indexOf(handler);
    if (index >= 0) {
      self.eventsAnyListeners.splice(index, 1);
    }
    return self;
  },
  off(events, handler) {
    const self = this;
    if (!self.eventsListeners || self.destroyed) return self;
    if (!self.eventsListeners) return self;
    events.split(' ').forEach(event => {
      if (typeof handler === 'undefined') {
        self.eventsListeners[event] = [];
      } else if (self.eventsListeners[event]) {
        self.eventsListeners[event].forEach((eventHandler, index) => {
          if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
            self.eventsListeners[event].splice(index, 1);
          }
        });
      }
    });
    return self;
  },
  emit() {
    const self = this;
    if (!self.eventsListeners || self.destroyed) return self;
    if (!self.eventsListeners) return self;
    let events;
    let data;
    let context;
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    if (typeof args[0] === 'string' || Array.isArray(args[0])) {
      events = args[0];
      data = args.slice(1, args.length);
      context = self;
    } else {
      events = args[0].events;
      data = args[0].data;
      context = args[0].context || self;
    }
    data.unshift(context);
    const eventsArray = Array.isArray(events) ? events : events.split(' ');
    eventsArray.forEach(event => {
      if (self.eventsAnyListeners && self.eventsAnyListeners.length) {
        self.eventsAnyListeners.forEach(eventHandler => {
          eventHandler.apply(context, [event, ...data]);
        });
      }
      if (self.eventsListeners && self.eventsListeners[event]) {
        self.eventsListeners[event].forEach(eventHandler => {
          eventHandler.apply(context, data);
        });
      }
    });
    return self;
  }
};

function updateSize() {
  const swiper = this;
  let width;
  let height;
  const el = swiper.el;
  if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {
    width = swiper.params.width;
  } else {
    width = el.clientWidth;
  }
  if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {
    height = swiper.params.height;
  } else {
    height = el.clientHeight;
  }
  if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
    return;
  }

  // Subtract paddings
  width = width - parseInt((0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.p)(el, 'padding-left') || 0, 10) - parseInt((0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.p)(el, 'padding-right') || 0, 10);
  height = height - parseInt((0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.p)(el, 'padding-top') || 0, 10) - parseInt((0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.p)(el, 'padding-bottom') || 0, 10);
  if (Number.isNaN(width)) width = 0;
  if (Number.isNaN(height)) height = 0;
  Object.assign(swiper, {
    width,
    height,
    size: swiper.isHorizontal() ? width : height
  });
}

function updateSlides() {
  const swiper = this;
  function getDirectionPropertyValue(node, label) {
    return parseFloat(node.getPropertyValue(swiper.getDirectionLabel(label)) || 0);
  }
  const params = swiper.params;
  const {
    wrapperEl,
    slidesEl,
    size: swiperSize,
    rtlTranslate: rtl,
    wrongRTL
  } = swiper;
  const isVirtual = swiper.virtual && params.virtual.enabled;
  const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
  const slides = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);
  const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
  let snapGrid = [];
  const slidesGrid = [];
  const slidesSizesGrid = [];
  let offsetBefore = params.slidesOffsetBefore;
  if (typeof offsetBefore === 'function') {
    offsetBefore = params.slidesOffsetBefore.call(swiper);
  }
  let offsetAfter = params.slidesOffsetAfter;
  if (typeof offsetAfter === 'function') {
    offsetAfter = params.slidesOffsetAfter.call(swiper);
  }
  const previousSnapGridLength = swiper.snapGrid.length;
  const previousSlidesGridLength = swiper.slidesGrid.length;
  let spaceBetween = params.spaceBetween;
  let slidePosition = -offsetBefore;
  let prevSlideSize = 0;
  let index = 0;
  if (typeof swiperSize === 'undefined') {
    return;
  }
  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
    spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;
  } else if (typeof spaceBetween === 'string') {
    spaceBetween = parseFloat(spaceBetween);
  }
  swiper.virtualSize = -spaceBetween;

  // reset margins
  slides.forEach(slideEl => {
    if (rtl) {
      slideEl.style.marginLeft = '';
    } else {
      slideEl.style.marginRight = '';
    }
    slideEl.style.marginBottom = '';
    slideEl.style.marginTop = '';
  });

  // reset cssMode offsets
  if (params.centeredSlides && params.cssMode) {
    (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.s)(wrapperEl, '--swiper-centered-offset-before', '');
    (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.s)(wrapperEl, '--swiper-centered-offset-after', '');
  }
  const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;
  if (gridEnabled) {
    swiper.grid.initSlides(slides);
  } else if (swiper.grid) {
    swiper.grid.unsetSlides();
  }

  // Calc slides
  let slideSize;
  const shouldResetSlideSize = params.slidesPerView === 'auto' && params.breakpoints && Object.keys(params.breakpoints).filter(key => {
    return typeof params.breakpoints[key].slidesPerView !== 'undefined';
  }).length > 0;
  for (let i = 0; i < slidesLength; i += 1) {
    slideSize = 0;
    let slide;
    if (slides[i]) slide = slides[i];
    if (gridEnabled) {
      swiper.grid.updateSlide(i, slide, slides);
    }
    if (slides[i] && (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.p)(slide, 'display') === 'none') continue; // eslint-disable-line

    if (params.slidesPerView === 'auto') {
      if (shouldResetSlideSize) {
        slides[i].style[swiper.getDirectionLabel('width')] = ``;
      }
      const slideStyles = getComputedStyle(slide);
      const currentTransform = slide.style.transform;
      const currentWebKitTransform = slide.style.webkitTransform;
      if (currentTransform) {
        slide.style.transform = 'none';
      }
      if (currentWebKitTransform) {
        slide.style.webkitTransform = 'none';
      }
      if (params.roundLengths) {
        slideSize = swiper.isHorizontal() ? (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.f)(slide, 'width', true) : (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.f)(slide, 'height', true);
      } else {
        // eslint-disable-next-line
        const width = getDirectionPropertyValue(slideStyles, 'width');
        const paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');
        const paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');
        const marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');
        const marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');
        const boxSizing = slideStyles.getPropertyValue('box-sizing');
        if (boxSizing && boxSizing === 'border-box') {
          slideSize = width + marginLeft + marginRight;
        } else {
          const {
            clientWidth,
            offsetWidth
          } = slide;
          slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
        }
      }
      if (currentTransform) {
        slide.style.transform = currentTransform;
      }
      if (currentWebKitTransform) {
        slide.style.webkitTransform = currentWebKitTransform;
      }
      if (params.roundLengths) slideSize = Math.floor(slideSize);
    } else {
      slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
      if (params.roundLengths) slideSize = Math.floor(slideSize);
      if (slides[i]) {
        slides[i].style[swiper.getDirectionLabel('width')] = `${slideSize}px`;
      }
    }
    if (slides[i]) {
      slides[i].swiperSlideSize = slideSize;
    }
    slidesSizesGrid.push(slideSize);
    if (params.centeredSlides) {
      slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
      if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
      if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
      if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
      if (params.roundLengths) slidePosition = Math.floor(slidePosition);
      if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
    } else {
      if (params.roundLengths) slidePosition = Math.floor(slidePosition);
      if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
      slidePosition = slidePosition + slideSize + spaceBetween;
    }
    swiper.virtualSize += slideSize + spaceBetween;
    prevSlideSize = slideSize;
    index += 1;
  }
  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
  if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
    wrapperEl.style.width = `${swiper.virtualSize + spaceBetween}px`;
  }
  if (params.setWrapperSize) {
    wrapperEl.style[swiper.getDirectionLabel('width')] = `${swiper.virtualSize + spaceBetween}px`;
  }
  if (gridEnabled) {
    swiper.grid.updateWrapperSize(slideSize, snapGrid);
  }

  // Remove last grid elements depending on width
  if (!params.centeredSlides) {
    const newSlidesGrid = [];
    for (let i = 0; i < snapGrid.length; i += 1) {
      let slidesGridItem = snapGrid[i];
      if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
      if (snapGrid[i] <= swiper.virtualSize - swiperSize) {
        newSlidesGrid.push(slidesGridItem);
      }
    }
    snapGrid = newSlidesGrid;
    if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
      snapGrid.push(swiper.virtualSize - swiperSize);
    }
  }
  if (isVirtual && params.loop) {
    const size = slidesSizesGrid[0] + spaceBetween;
    if (params.slidesPerGroup > 1) {
      const groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);
      const groupSize = size * params.slidesPerGroup;
      for (let i = 0; i < groups; i += 1) {
        snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);
      }
    }
    for (let i = 0; i < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i += 1) {
      if (params.slidesPerGroup === 1) {
        snapGrid.push(snapGrid[snapGrid.length - 1] + size);
      }
      slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);
      swiper.virtualSize += size;
    }
  }
  if (snapGrid.length === 0) snapGrid = [0];
  if (spaceBetween !== 0) {
    const key = swiper.isHorizontal() && rtl ? 'marginLeft' : swiper.getDirectionLabel('marginRight');
    slides.filter((_, slideIndex) => {
      if (!params.cssMode || params.loop) return true;
      if (slideIndex === slides.length - 1) {
        return false;
      }
      return true;
    }).forEach(slideEl => {
      slideEl.style[key] = `${spaceBetween}px`;
    });
  }
  if (params.centeredSlides && params.centeredSlidesBounds) {
    let allSlidesSize = 0;
    slidesSizesGrid.forEach(slideSizeValue => {
      allSlidesSize += slideSizeValue + (spaceBetween || 0);
    });
    allSlidesSize -= spaceBetween;
    const maxSnap = allSlidesSize > swiperSize ? allSlidesSize - swiperSize : 0;
    snapGrid = snapGrid.map(snap => {
      if (snap <= 0) return -offsetBefore;
      if (snap > maxSnap) return maxSnap + offsetAfter;
      return snap;
    });
  }
  if (params.centerInsufficientSlides) {
    let allSlidesSize = 0;
    slidesSizesGrid.forEach(slideSizeValue => {
      allSlidesSize += slideSizeValue + (spaceBetween || 0);
    });
    allSlidesSize -= spaceBetween;
    const offsetSize = (params.slidesOffsetBefore || 0) + (params.slidesOffsetAfter || 0);
    if (allSlidesSize + offsetSize < swiperSize) {
      const allSlidesOffset = (swiperSize - allSlidesSize - offsetSize) / 2;
      snapGrid.forEach((snap, snapIndex) => {
        snapGrid[snapIndex] = snap - allSlidesOffset;
      });
      slidesGrid.forEach((snap, snapIndex) => {
        slidesGrid[snapIndex] = snap + allSlidesOffset;
      });
    }
  }
  Object.assign(swiper, {
    slides,
    snapGrid,
    slidesGrid,
    slidesSizesGrid
  });
  if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
    (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.s)(wrapperEl, '--swiper-centered-offset-before', `${-snapGrid[0]}px`);
    (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.s)(wrapperEl, '--swiper-centered-offset-after', `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
    const addToSnapGrid = -swiper.snapGrid[0];
    const addToSlidesGrid = -swiper.slidesGrid[0];
    swiper.snapGrid = swiper.snapGrid.map(v => v + addToSnapGrid);
    swiper.slidesGrid = swiper.slidesGrid.map(v => v + addToSlidesGrid);
  }
  if (slidesLength !== previousSlidesLength) {
    swiper.emit('slidesLengthChange');
  }
  if (snapGrid.length !== previousSnapGridLength) {
    if (swiper.params.watchOverflow) swiper.checkOverflow();
    swiper.emit('snapGridLengthChange');
  }
  if (slidesGrid.length !== previousSlidesGridLength) {
    swiper.emit('slidesGridLengthChange');
  }
  if (params.watchSlidesProgress) {
    swiper.updateSlidesOffset();
  }
  swiper.emit('slidesUpdated');
  if (!isVirtual && !params.cssMode && (params.effect === 'slide' || params.effect === 'fade')) {
    const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
    const hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);
    if (slidesLength <= params.maxBackfaceHiddenSlides) {
      if (!hasClassBackfaceClassAdded) swiper.el.classList.add(backFaceHiddenClass);
    } else if (hasClassBackfaceClassAdded) {
      swiper.el.classList.remove(backFaceHiddenClass);
    }
  }
}

function updateAutoHeight(speed) {
  const swiper = this;
  const activeSlides = [];
  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
  let newHeight = 0;
  let i;
  if (typeof speed === 'number') {
    swiper.setTransition(speed);
  } else if (speed === true) {
    swiper.setTransition(swiper.params.speed);
  }
  const getSlideByIndex = index => {
    if (isVirtual) {
      return swiper.slides[swiper.getSlideIndexByData(index)];
    }
    return swiper.slides[index];
  };
  // Find slides currently in view
  if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
    if (swiper.params.centeredSlides) {
      (swiper.visibleSlides || []).forEach(slide => {
        activeSlides.push(slide);
      });
    } else {
      for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
        const index = swiper.activeIndex + i;
        if (index > swiper.slides.length && !isVirtual) break;
        activeSlides.push(getSlideByIndex(index));
      }
    }
  } else {
    activeSlides.push(getSlideByIndex(swiper.activeIndex));
  }

  // Find new height from highest slide in view
  for (i = 0; i < activeSlides.length; i += 1) {
    if (typeof activeSlides[i] !== 'undefined') {
      const height = activeSlides[i].offsetHeight;
      newHeight = height > newHeight ? height : newHeight;
    }
  }

  // Update Height
  if (newHeight || newHeight === 0) swiper.wrapperEl.style.height = `${newHeight}px`;
}

function updateSlidesOffset() {
  const swiper = this;
  const slides = swiper.slides;
  // eslint-disable-next-line
  const minusOffset = swiper.isElement ? swiper.isHorizontal() ? swiper.wrapperEl.offsetLeft : swiper.wrapperEl.offsetTop : 0;
  for (let i = 0; i < slides.length; i += 1) {
    slides[i].swiperSlideOffset = (swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop) - minusOffset - swiper.cssOverflowAdjustment();
  }
}

const toggleSlideClasses$1 = (slideEl, condition, className) => {
  if (condition && !slideEl.classList.contains(className)) {
    slideEl.classList.add(className);
  } else if (!condition && slideEl.classList.contains(className)) {
    slideEl.classList.remove(className);
  }
};
function updateSlidesProgress(translate) {
  if (translate === void 0) {
    translate = this && this.translate || 0;
  }
  const swiper = this;
  const params = swiper.params;
  const {
    slides,
    rtlTranslate: rtl,
    snapGrid
  } = swiper;
  if (slides.length === 0) return;
  if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();
  let offsetCenter = -translate;
  if (rtl) offsetCenter = translate;
  swiper.visibleSlidesIndexes = [];
  swiper.visibleSlides = [];
  let spaceBetween = params.spaceBetween;
  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
    spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiper.size;
  } else if (typeof spaceBetween === 'string') {
    spaceBetween = parseFloat(spaceBetween);
  }
  for (let i = 0; i < slides.length; i += 1) {
    const slide = slides[i];
    let slideOffset = slide.swiperSlideOffset;
    if (params.cssMode && params.centeredSlides) {
      slideOffset -= slides[0].swiperSlideOffset;
    }
    const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);
    const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);
    const slideBefore = -(offsetCenter - slideOffset);
    const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
    const isFullyVisible = slideBefore >= 0 && slideBefore <= swiper.size - swiper.slidesSizesGrid[i];
    const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;
    if (isVisible) {
      swiper.visibleSlides.push(slide);
      swiper.visibleSlidesIndexes.push(i);
    }
    toggleSlideClasses$1(slide, isVisible, params.slideVisibleClass);
    toggleSlideClasses$1(slide, isFullyVisible, params.slideFullyVisibleClass);
    slide.progress = rtl ? -slideProgress : slideProgress;
    slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
  }
}

function updateProgress(translate) {
  const swiper = this;
  if (typeof translate === 'undefined') {
    const multiplier = swiper.rtlTranslate ? -1 : 1;
    // eslint-disable-next-line
    translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
  }
  const params = swiper.params;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  let {
    progress,
    isBeginning,
    isEnd,
    progressLoop
  } = swiper;
  const wasBeginning = isBeginning;
  const wasEnd = isEnd;
  if (translatesDiff === 0) {
    progress = 0;
    isBeginning = true;
    isEnd = true;
  } else {
    progress = (translate - swiper.minTranslate()) / translatesDiff;
    const isBeginningRounded = Math.abs(translate - swiper.minTranslate()) < 1;
    const isEndRounded = Math.abs(translate - swiper.maxTranslate()) < 1;
    isBeginning = isBeginningRounded || progress <= 0;
    isEnd = isEndRounded || progress >= 1;
    if (isBeginningRounded) progress = 0;
    if (isEndRounded) progress = 1;
  }
  if (params.loop) {
    const firstSlideIndex = swiper.getSlideIndexByData(0);
    const lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1);
    const firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];
    const lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];
    const translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];
    const translateAbs = Math.abs(translate);
    if (translateAbs >= firstSlideTranslate) {
      progressLoop = (translateAbs - firstSlideTranslate) / translateMax;
    } else {
      progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;
    }
    if (progressLoop > 1) progressLoop -= 1;
  }
  Object.assign(swiper, {
    progress,
    progressLoop,
    isBeginning,
    isEnd
  });
  if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);
  if (isBeginning && !wasBeginning) {
    swiper.emit('reachBeginning toEdge');
  }
  if (isEnd && !wasEnd) {
    swiper.emit('reachEnd toEdge');
  }
  if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
    swiper.emit('fromEdge');
  }
  swiper.emit('progress', progress);
}

const toggleSlideClasses = (slideEl, condition, className) => {
  if (condition && !slideEl.classList.contains(className)) {
    slideEl.classList.add(className);
  } else if (!condition && slideEl.classList.contains(className)) {
    slideEl.classList.remove(className);
  }
};
function updateSlidesClasses() {
  const swiper = this;
  const {
    slides,
    params,
    slidesEl,
    activeIndex
  } = swiper;
  const isVirtual = swiper.virtual && params.virtual.enabled;
  const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
  const getFilteredSlide = selector => {
    return (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(slidesEl, `.${params.slideClass}${selector}, swiper-slide${selector}`)[0];
  };
  let activeSlide;
  let prevSlide;
  let nextSlide;
  if (isVirtual) {
    if (params.loop) {
      let slideIndex = activeIndex - swiper.virtual.slidesBefore;
      if (slideIndex < 0) slideIndex = swiper.virtual.slides.length + slideIndex;
      if (slideIndex >= swiper.virtual.slides.length) slideIndex -= swiper.virtual.slides.length;
      activeSlide = getFilteredSlide(`[data-swiper-slide-index="${slideIndex}"]`);
    } else {
      activeSlide = getFilteredSlide(`[data-swiper-slide-index="${activeIndex}"]`);
    }
  } else {
    if (gridEnabled) {
      activeSlide = slides.filter(slideEl => slideEl.column === activeIndex)[0];
      nextSlide = slides.filter(slideEl => slideEl.column === activeIndex + 1)[0];
      prevSlide = slides.filter(slideEl => slideEl.column === activeIndex - 1)[0];
    } else {
      activeSlide = slides[activeIndex];
    }
  }
  if (activeSlide) {
    if (!gridEnabled) {
      // Next Slide
      nextSlide = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.q)(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
      if (params.loop && !nextSlide) {
        nextSlide = slides[0];
      }

      // Prev Slide
      prevSlide = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.r)(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
      if (params.loop && !prevSlide === 0) {
        prevSlide = slides[slides.length - 1];
      }
    }
  }
  slides.forEach(slideEl => {
    toggleSlideClasses(slideEl, slideEl === activeSlide, params.slideActiveClass);
    toggleSlideClasses(slideEl, slideEl === nextSlide, params.slideNextClass);
    toggleSlideClasses(slideEl, slideEl === prevSlide, params.slidePrevClass);
  });
  swiper.emitSlidesClasses();
}

const processLazyPreloader = (swiper, imageEl) => {
  if (!swiper || swiper.destroyed || !swiper.params) return;
  const slideSelector = () => swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;
  const slideEl = imageEl.closest(slideSelector());
  if (slideEl) {
    let lazyEl = slideEl.querySelector(`.${swiper.params.lazyPreloaderClass}`);
    if (!lazyEl && swiper.isElement) {
      if (slideEl.shadowRoot) {
        lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);
      } else {
        // init later
        requestAnimationFrame(() => {
          if (slideEl.shadowRoot) {
            lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);
            if (lazyEl) lazyEl.remove();
          }
        });
      }
    }
    if (lazyEl) lazyEl.remove();
  }
};
const unlazy = (swiper, index) => {
  if (!swiper.slides[index]) return;
  const imageEl = swiper.slides[index].querySelector('[loading="lazy"]');
  if (imageEl) imageEl.removeAttribute('loading');
};
const preload = swiper => {
  if (!swiper || swiper.destroyed || !swiper.params) return;
  let amount = swiper.params.lazyPreloadPrevNext;
  const len = swiper.slides.length;
  if (!len || !amount || amount < 0) return;
  amount = Math.min(amount, len);
  const slidesPerView = swiper.params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(swiper.params.slidesPerView);
  const activeIndex = swiper.activeIndex;
  if (swiper.params.grid && swiper.params.grid.rows > 1) {
    const activeColumn = activeIndex;
    const preloadColumns = [activeColumn - amount];
    preloadColumns.push(...Array.from({
      length: amount
    }).map((_, i) => {
      return activeColumn + slidesPerView + i;
    }));
    swiper.slides.forEach((slideEl, i) => {
      if (preloadColumns.includes(slideEl.column)) unlazy(swiper, i);
    });
    return;
  }
  const slideIndexLastInView = activeIndex + slidesPerView - 1;
  if (swiper.params.rewind || swiper.params.loop) {
    for (let i = activeIndex - amount; i <= slideIndexLastInView + amount; i += 1) {
      const realIndex = (i % len + len) % len;
      if (realIndex < activeIndex || realIndex > slideIndexLastInView) unlazy(swiper, realIndex);
    }
  } else {
    for (let i = Math.max(activeIndex - amount, 0); i <= Math.min(slideIndexLastInView + amount, len - 1); i += 1) {
      if (i !== activeIndex && (i > slideIndexLastInView || i < activeIndex)) {
        unlazy(swiper, i);
      }
    }
  }
};

function getActiveIndexByTranslate(swiper) {
  const {
    slidesGrid,
    params
  } = swiper;
  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  let activeIndex;
  for (let i = 0; i < slidesGrid.length; i += 1) {
    if (typeof slidesGrid[i + 1] !== 'undefined') {
      if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
        activeIndex = i;
      } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
        activeIndex = i + 1;
      }
    } else if (translate >= slidesGrid[i]) {
      activeIndex = i;
    }
  }
  // Normalize slideIndex
  if (params.normalizeSlideIndex) {
    if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;
  }
  return activeIndex;
}
function updateActiveIndex(newActiveIndex) {
  const swiper = this;
  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  const {
    snapGrid,
    params,
    activeIndex: previousIndex,
    realIndex: previousRealIndex,
    snapIndex: previousSnapIndex
  } = swiper;
  let activeIndex = newActiveIndex;
  let snapIndex;
  const getVirtualRealIndex = aIndex => {
    let realIndex = aIndex - swiper.virtual.slidesBefore;
    if (realIndex < 0) {
      realIndex = swiper.virtual.slides.length + realIndex;
    }
    if (realIndex >= swiper.virtual.slides.length) {
      realIndex -= swiper.virtual.slides.length;
    }
    return realIndex;
  };
  if (typeof activeIndex === 'undefined') {
    activeIndex = getActiveIndexByTranslate(swiper);
  }
  if (snapGrid.indexOf(translate) >= 0) {
    snapIndex = snapGrid.indexOf(translate);
  } else {
    const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
    snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
  }
  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
  if (activeIndex === previousIndex && !swiper.params.loop) {
    if (snapIndex !== previousSnapIndex) {
      swiper.snapIndex = snapIndex;
      swiper.emit('snapIndexChange');
    }
    return;
  }
  if (activeIndex === previousIndex && swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {
    swiper.realIndex = getVirtualRealIndex(activeIndex);
    return;
  }
  const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;

  // Get real index
  let realIndex;
  if (swiper.virtual && params.virtual.enabled && params.loop) {
    realIndex = getVirtualRealIndex(activeIndex);
  } else if (gridEnabled) {
    const firstSlideInColumn = swiper.slides.filter(slideEl => slideEl.column === activeIndex)[0];
    let activeSlideIndex = parseInt(firstSlideInColumn.getAttribute('data-swiper-slide-index'), 10);
    if (Number.isNaN(activeSlideIndex)) {
      activeSlideIndex = Math.max(swiper.slides.indexOf(firstSlideInColumn), 0);
    }
    realIndex = Math.floor(activeSlideIndex / params.grid.rows);
  } else if (swiper.slides[activeIndex]) {
    const slideIndex = swiper.slides[activeIndex].getAttribute('data-swiper-slide-index');
    if (slideIndex) {
      realIndex = parseInt(slideIndex, 10);
    } else {
      realIndex = activeIndex;
    }
  } else {
    realIndex = activeIndex;
  }
  Object.assign(swiper, {
    previousSnapIndex,
    snapIndex,
    previousRealIndex,
    realIndex,
    previousIndex,
    activeIndex
  });
  if (swiper.initialized) {
    preload(swiper);
  }
  swiper.emit('activeIndexChange');
  swiper.emit('snapIndexChange');
  if (swiper.initialized || swiper.params.runCallbacksOnInit) {
    if (previousRealIndex !== realIndex) {
      swiper.emit('realIndexChange');
    }
    swiper.emit('slideChange');
  }
}

function updateClickedSlide(el, path) {
  const swiper = this;
  const params = swiper.params;
  let slide = el.closest(`.${params.slideClass}, swiper-slide`);
  if (!slide && swiper.isElement && path && path.length > 1 && path.includes(el)) {
    [...path.slice(path.indexOf(el) + 1, path.length)].forEach(pathEl => {
      if (!slide && pathEl.matches && pathEl.matches(`.${params.slideClass}, swiper-slide`)) {
        slide = pathEl;
      }
    });
  }
  let slideFound = false;
  let slideIndex;
  if (slide) {
    for (let i = 0; i < swiper.slides.length; i += 1) {
      if (swiper.slides[i] === slide) {
        slideFound = true;
        slideIndex = i;
        break;
      }
    }
  }
  if (slide && slideFound) {
    swiper.clickedSlide = slide;
    if (swiper.virtual && swiper.params.virtual.enabled) {
      swiper.clickedIndex = parseInt(slide.getAttribute('data-swiper-slide-index'), 10);
    } else {
      swiper.clickedIndex = slideIndex;
    }
  } else {
    swiper.clickedSlide = undefined;
    swiper.clickedIndex = undefined;
    return;
  }
  if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
    swiper.slideToClickedSlide();
  }
}

var update = {
  updateSize,
  updateSlides,
  updateAutoHeight,
  updateSlidesOffset,
  updateSlidesProgress,
  updateProgress,
  updateSlidesClasses,
  updateActiveIndex,
  updateClickedSlide
};

function getSwiperTranslate(axis) {
  if (axis === void 0) {
    axis = this.isHorizontal() ? 'x' : 'y';
  }
  const swiper = this;
  const {
    params,
    rtlTranslate: rtl,
    translate,
    wrapperEl
  } = swiper;
  if (params.virtualTranslate) {
    return rtl ? -translate : translate;
  }
  if (params.cssMode) {
    return translate;
  }
  let currentTranslate = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.j)(wrapperEl, axis);
  currentTranslate += swiper.cssOverflowAdjustment();
  if (rtl) currentTranslate = -currentTranslate;
  return currentTranslate || 0;
}

function setTranslate(translate, byController) {
  const swiper = this;
  const {
    rtlTranslate: rtl,
    params,
    wrapperEl,
    progress
  } = swiper;
  let x = 0;
  let y = 0;
  const z = 0;
  if (swiper.isHorizontal()) {
    x = rtl ? -translate : translate;
  } else {
    y = translate;
  }
  if (params.roundLengths) {
    x = Math.floor(x);
    y = Math.floor(y);
  }
  swiper.previousTranslate = swiper.translate;
  swiper.translate = swiper.isHorizontal() ? x : y;
  if (params.cssMode) {
    wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;
  } else if (!params.virtualTranslate) {
    if (swiper.isHorizontal()) {
      x -= swiper.cssOverflowAdjustment();
    } else {
      y -= swiper.cssOverflowAdjustment();
    }
    wrapperEl.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;
  }

  // Check if we need to update progress
  let newProgress;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (translate - swiper.minTranslate()) / translatesDiff;
  }
  if (newProgress !== progress) {
    swiper.updateProgress(translate);
  }
  swiper.emit('setTranslate', swiper.translate, byController);
}

function minTranslate() {
  return -this.snapGrid[0];
}

function maxTranslate() {
  return -this.snapGrid[this.snapGrid.length - 1];
}

function translateTo(translate, speed, runCallbacks, translateBounds, internal) {
  if (translate === void 0) {
    translate = 0;
  }
  if (speed === void 0) {
    speed = this.params.speed;
  }
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  if (translateBounds === void 0) {
    translateBounds = true;
  }
  const swiper = this;
  const {
    params,
    wrapperEl
  } = swiper;
  if (swiper.animating && params.preventInteractionOnTransition) {
    return false;
  }
  const minTranslate = swiper.minTranslate();
  const maxTranslate = swiper.maxTranslate();
  let newTranslate;
  if (translateBounds && translate > minTranslate) newTranslate = minTranslate;else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;else newTranslate = translate;

  // Update progress
  swiper.updateProgress(newTranslate);
  if (params.cssMode) {
    const isH = swiper.isHorizontal();
    if (speed === 0) {
      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
    } else {
      if (!swiper.support.smoothScroll) {
        (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.t)({
          swiper,
          targetPosition: -newTranslate,
          side: isH ? 'left' : 'top'
        });
        return true;
      }
      wrapperEl.scrollTo({
        [isH ? 'left' : 'top']: -newTranslate,
        behavior: 'smooth'
      });
    }
    return true;
  }
  if (speed === 0) {
    swiper.setTransition(0);
    swiper.setTranslate(newTranslate);
    if (runCallbacks) {
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.emit('transitionEnd');
    }
  } else {
    swiper.setTransition(speed);
    swiper.setTranslate(newTranslate);
    if (runCallbacks) {
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.emit('transitionStart');
    }
    if (!swiper.animating) {
      swiper.animating = true;
      if (!swiper.onTranslateToWrapperTransitionEnd) {
        swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
          if (!swiper || swiper.destroyed) return;
          if (e.target !== this) return;
          swiper.wrapperEl.removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
          swiper.onTranslateToWrapperTransitionEnd = null;
          delete swiper.onTranslateToWrapperTransitionEnd;
          swiper.animating = false;
          if (runCallbacks) {
            swiper.emit('transitionEnd');
          }
        };
      }
      swiper.wrapperEl.addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
    }
  }
  return true;
}

var translate = {
  getTranslate: getSwiperTranslate,
  setTranslate,
  minTranslate,
  maxTranslate,
  translateTo
};

function setTransition(duration, byController) {
  const swiper = this;
  if (!swiper.params.cssMode) {
    swiper.wrapperEl.style.transitionDuration = `${duration}ms`;
    swiper.wrapperEl.style.transitionDelay = duration === 0 ? `0ms` : '';
  }
  swiper.emit('setTransition', duration, byController);
}

function transitionEmit(_ref) {
  let {
    swiper,
    runCallbacks,
    direction,
    step
  } = _ref;
  const {
    activeIndex,
    previousIndex
  } = swiper;
  let dir = direction;
  if (!dir) {
    if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';
  }
  swiper.emit(`transition${step}`);
  if (runCallbacks && activeIndex !== previousIndex) {
    if (dir === 'reset') {
      swiper.emit(`slideResetTransition${step}`);
      return;
    }
    swiper.emit(`slideChangeTransition${step}`);
    if (dir === 'next') {
      swiper.emit(`slideNextTransition${step}`);
    } else {
      swiper.emit(`slidePrevTransition${step}`);
    }
  }
}

function transitionStart(runCallbacks, direction) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper = this;
  const {
    params
  } = swiper;
  if (params.cssMode) return;
  if (params.autoHeight) {
    swiper.updateAutoHeight();
  }
  transitionEmit({
    swiper,
    runCallbacks,
    direction,
    step: 'Start'
  });
}

function transitionEnd(runCallbacks, direction) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper = this;
  const {
    params
  } = swiper;
  swiper.animating = false;
  if (params.cssMode) return;
  swiper.setTransition(0);
  transitionEmit({
    swiper,
    runCallbacks,
    direction,
    step: 'End'
  });
}

var transition = {
  setTransition,
  transitionStart,
  transitionEnd
};

function slideTo(index, speed, runCallbacks, internal, initial) {
  if (index === void 0) {
    index = 0;
  }
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  if (typeof index === 'string') {
    index = parseInt(index, 10);
  }
  const swiper = this;
  let slideIndex = index;
  if (slideIndex < 0) slideIndex = 0;
  const {
    params,
    snapGrid,
    slidesGrid,
    previousIndex,
    activeIndex,
    rtlTranslate: rtl,
    wrapperEl,
    enabled
  } = swiper;
  if (!enabled && !internal && !initial || swiper.destroyed || swiper.animating && params.preventInteractionOnTransition) {
    return false;
  }
  if (typeof speed === 'undefined') {
    speed = swiper.params.speed;
  }
  const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
  let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
  const translate = -snapGrid[snapIndex];
  // Normalize slideIndex
  if (params.normalizeSlideIndex) {
    for (let i = 0; i < slidesGrid.length; i += 1) {
      const normalizedTranslate = -Math.floor(translate * 100);
      const normalizedGrid = Math.floor(slidesGrid[i] * 100);
      const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);
      if (typeof slidesGrid[i + 1] !== 'undefined') {
        if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {
          slideIndex = i;
        } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {
          slideIndex = i + 1;
        }
      } else if (normalizedTranslate >= normalizedGrid) {
        slideIndex = i;
      }
    }
  }
  // Directions locks
  if (swiper.initialized && slideIndex !== activeIndex) {
    if (!swiper.allowSlideNext && (rtl ? translate > swiper.translate && translate > swiper.minTranslate() : translate < swiper.translate && translate < swiper.minTranslate())) {
      return false;
    }
    if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
      if ((activeIndex || 0) !== slideIndex) {
        return false;
      }
    }
  }
  if (slideIndex !== (previousIndex || 0) && runCallbacks) {
    swiper.emit('beforeSlideChangeStart');
  }

  // Update progress
  swiper.updateProgress(translate);
  let direction;
  if (slideIndex > activeIndex) direction = 'next';else if (slideIndex < activeIndex) direction = 'prev';else direction = 'reset';

  // initial virtual
  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
  const isInitialVirtual = isVirtual && initial;
  // Update Index
  if (!isInitialVirtual && (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate)) {
    swiper.updateActiveIndex(slideIndex);
    // Update Height
    if (params.autoHeight) {
      swiper.updateAutoHeight();
    }
    swiper.updateSlidesClasses();
    if (params.effect !== 'slide') {
      swiper.setTranslate(translate);
    }
    if (direction !== 'reset') {
      swiper.transitionStart(runCallbacks, direction);
      swiper.transitionEnd(runCallbacks, direction);
    }
    return false;
  }
  if (params.cssMode) {
    const isH = swiper.isHorizontal();
    const t = rtl ? translate : -translate;
    if (speed === 0) {
      if (isVirtual) {
        swiper.wrapperEl.style.scrollSnapType = 'none';
        swiper._immediateVirtual = true;
      }
      if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {
        swiper._cssModeVirtualInitialSet = true;
        requestAnimationFrame(() => {
          wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
        });
      } else {
        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
      }
      if (isVirtual) {
        requestAnimationFrame(() => {
          swiper.wrapperEl.style.scrollSnapType = '';
          swiper._immediateVirtual = false;
        });
      }
    } else {
      if (!swiper.support.smoothScroll) {
        (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.t)({
          swiper,
          targetPosition: t,
          side: isH ? 'left' : 'top'
        });
        return true;
      }
      wrapperEl.scrollTo({
        [isH ? 'left' : 'top']: t,
        behavior: 'smooth'
      });
    }
    return true;
  }
  swiper.setTransition(speed);
  swiper.setTranslate(translate);
  swiper.updateActiveIndex(slideIndex);
  swiper.updateSlidesClasses();
  swiper.emit('beforeTransitionStart', speed, internal);
  swiper.transitionStart(runCallbacks, direction);
  if (speed === 0) {
    swiper.transitionEnd(runCallbacks, direction);
  } else if (!swiper.animating) {
    swiper.animating = true;
    if (!swiper.onSlideToWrapperTransitionEnd) {
      swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
        if (!swiper || swiper.destroyed) return;
        if (e.target !== this) return;
        swiper.wrapperEl.removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
        swiper.onSlideToWrapperTransitionEnd = null;
        delete swiper.onSlideToWrapperTransitionEnd;
        swiper.transitionEnd(runCallbacks, direction);
      };
    }
    swiper.wrapperEl.addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
  }
  return true;
}

function slideToLoop(index, speed, runCallbacks, internal) {
  if (index === void 0) {
    index = 0;
  }
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  if (typeof index === 'string') {
    const indexAsNumber = parseInt(index, 10);
    index = indexAsNumber;
  }
  const swiper = this;
  if (swiper.destroyed) return;
  if (typeof speed === 'undefined') {
    speed = swiper.params.speed;
  }
  const gridEnabled = swiper.grid && swiper.params.grid && swiper.params.grid.rows > 1;
  let newIndex = index;
  if (swiper.params.loop) {
    if (swiper.virtual && swiper.params.virtual.enabled) {
      // eslint-disable-next-line
      newIndex = newIndex + swiper.virtual.slidesBefore;
    } else {
      let targetSlideIndex;
      if (gridEnabled) {
        const slideIndex = newIndex * swiper.params.grid.rows;
        targetSlideIndex = swiper.slides.filter(slideEl => slideEl.getAttribute('data-swiper-slide-index') * 1 === slideIndex)[0].column;
      } else {
        targetSlideIndex = swiper.getSlideIndexByData(newIndex);
      }
      const cols = gridEnabled ? Math.ceil(swiper.slides.length / swiper.params.grid.rows) : swiper.slides.length;
      const {
        centeredSlides
      } = swiper.params;
      let slidesPerView = swiper.params.slidesPerView;
      if (slidesPerView === 'auto') {
        slidesPerView = swiper.slidesPerViewDynamic();
      } else {
        slidesPerView = Math.ceil(parseFloat(swiper.params.slidesPerView, 10));
        if (centeredSlides && slidesPerView % 2 === 0) {
          slidesPerView = slidesPerView + 1;
        }
      }
      let needLoopFix = cols - targetSlideIndex < slidesPerView;
      if (centeredSlides) {
        needLoopFix = needLoopFix || targetSlideIndex < Math.ceil(slidesPerView / 2);
      }
      if (internal && centeredSlides && swiper.params.slidesPerView !== 'auto' && !gridEnabled) {
        needLoopFix = false;
      }
      if (needLoopFix) {
        const direction = centeredSlides ? targetSlideIndex < swiper.activeIndex ? 'prev' : 'next' : targetSlideIndex - swiper.activeIndex - 1 < swiper.params.slidesPerView ? 'next' : 'prev';
        swiper.loopFix({
          direction,
          slideTo: true,
          activeSlideIndex: direction === 'next' ? targetSlideIndex + 1 : targetSlideIndex - cols + 1,
          slideRealIndex: direction === 'next' ? swiper.realIndex : undefined
        });
      }
      if (gridEnabled) {
        const slideIndex = newIndex * swiper.params.grid.rows;
        newIndex = swiper.slides.filter(slideEl => slideEl.getAttribute('data-swiper-slide-index') * 1 === slideIndex)[0].column;
      } else {
        newIndex = swiper.getSlideIndexByData(newIndex);
      }
    }
  }
  requestAnimationFrame(() => {
    swiper.slideTo(newIndex, speed, runCallbacks, internal);
  });
  return swiper;
}

/* eslint no-unused-vars: "off" */
function slideNext(speed, runCallbacks, internal) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper = this;
  const {
    enabled,
    params,
    animating
  } = swiper;
  if (!enabled || swiper.destroyed) return swiper;
  if (typeof speed === 'undefined') {
    speed = swiper.params.speed;
  }
  let perGroup = params.slidesPerGroup;
  if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
    perGroup = Math.max(swiper.slidesPerViewDynamic('current', true), 1);
  }
  const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
  const isVirtual = swiper.virtual && params.virtual.enabled;
  if (params.loop) {
    if (animating && !isVirtual && params.loopPreventsSliding) return false;
    swiper.loopFix({
      direction: 'next'
    });
    // eslint-disable-next-line
    swiper._clientLeft = swiper.wrapperEl.clientLeft;
    if (swiper.activeIndex === swiper.slides.length - 1 && params.cssMode) {
      requestAnimationFrame(() => {
        swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
      });
      return true;
    }
  }
  if (params.rewind && swiper.isEnd) {
    return swiper.slideTo(0, speed, runCallbacks, internal);
  }
  return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
}

/* eslint no-unused-vars: "off" */
function slidePrev(speed, runCallbacks, internal) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper = this;
  const {
    params,
    snapGrid,
    slidesGrid,
    rtlTranslate,
    enabled,
    animating
  } = swiper;
  if (!enabled || swiper.destroyed) return swiper;
  if (typeof speed === 'undefined') {
    speed = swiper.params.speed;
  }
  const isVirtual = swiper.virtual && params.virtual.enabled;
  if (params.loop) {
    if (animating && !isVirtual && params.loopPreventsSliding) return false;
    swiper.loopFix({
      direction: 'prev'
    });
    // eslint-disable-next-line
    swiper._clientLeft = swiper.wrapperEl.clientLeft;
  }
  const translate = rtlTranslate ? swiper.translate : -swiper.translate;
  function normalize(val) {
    if (val < 0) return -Math.floor(Math.abs(val));
    return Math.floor(val);
  }
  const normalizedTranslate = normalize(translate);
  const normalizedSnapGrid = snapGrid.map(val => normalize(val));
  let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
  if (typeof prevSnap === 'undefined' && params.cssMode) {
    let prevSnapIndex;
    snapGrid.forEach((snap, snapIndex) => {
      if (normalizedTranslate >= snap) {
        // prevSnap = snap;
        prevSnapIndex = snapIndex;
      }
    });
    if (typeof prevSnapIndex !== 'undefined') {
      prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
    }
  }
  let prevIndex = 0;
  if (typeof prevSnap !== 'undefined') {
    prevIndex = slidesGrid.indexOf(prevSnap);
    if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
    if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
      prevIndex = prevIndex - swiper.slidesPerViewDynamic('previous', true) + 1;
      prevIndex = Math.max(prevIndex, 0);
    }
  }
  if (params.rewind && swiper.isBeginning) {
    const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
    return swiper.slideTo(lastIndex, speed, runCallbacks, internal);
  } else if (params.loop && swiper.activeIndex === 0 && params.cssMode) {
    requestAnimationFrame(() => {
      swiper.slideTo(prevIndex, speed, runCallbacks, internal);
    });
    return true;
  }
  return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
}

/* eslint no-unused-vars: "off" */
function slideReset(speed, runCallbacks, internal) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper = this;
  if (swiper.destroyed) return;
  if (typeof speed === 'undefined') {
    speed = swiper.params.speed;
  }
  return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
}

/* eslint no-unused-vars: "off" */
function slideToClosest(speed, runCallbacks, internal, threshold) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  if (threshold === void 0) {
    threshold = 0.5;
  }
  const swiper = this;
  if (swiper.destroyed) return;
  if (typeof speed === 'undefined') {
    speed = swiper.params.speed;
  }
  let index = swiper.activeIndex;
  const skip = Math.min(swiper.params.slidesPerGroupSkip, index);
  const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  if (translate >= swiper.snapGrid[snapIndex]) {
    // The current translate is on or after the current snap index, so the choice
    // is between the current index and the one after it.
    const currentSnap = swiper.snapGrid[snapIndex];
    const nextSnap = swiper.snapGrid[snapIndex + 1];
    if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {
      index += swiper.params.slidesPerGroup;
    }
  } else {
    // The current translate is before the current snap index, so the choice
    // is between the current index and the one before it.
    const prevSnap = swiper.snapGrid[snapIndex - 1];
    const currentSnap = swiper.snapGrid[snapIndex];
    if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) {
      index -= swiper.params.slidesPerGroup;
    }
  }
  index = Math.max(index, 0);
  index = Math.min(index, swiper.slidesGrid.length - 1);
  return swiper.slideTo(index, speed, runCallbacks, internal);
}

function slideToClickedSlide() {
  const swiper = this;
  if (swiper.destroyed) return;
  const {
    params,
    slidesEl
  } = swiper;
  const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
  let slideToIndex = swiper.clickedIndex;
  let realIndex;
  const slideSelector = swiper.isElement ? `swiper-slide` : `.${params.slideClass}`;
  if (params.loop) {
    if (swiper.animating) return;
    realIndex = parseInt(swiper.clickedSlide.getAttribute('data-swiper-slide-index'), 10);
    if (params.centeredSlides) {
      if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
        swiper.loopFix();
        slideToIndex = swiper.getSlideIndex((0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
        (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.n)(() => {
          swiper.slideTo(slideToIndex);
        });
      } else {
        swiper.slideTo(slideToIndex);
      }
    } else if (slideToIndex > swiper.slides.length - slidesPerView) {
      swiper.loopFix();
      slideToIndex = swiper.getSlideIndex((0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
      (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.n)(() => {
        swiper.slideTo(slideToIndex);
      });
    } else {
      swiper.slideTo(slideToIndex);
    }
  } else {
    swiper.slideTo(slideToIndex);
  }
}

var slide = {
  slideTo,
  slideToLoop,
  slideNext,
  slidePrev,
  slideReset,
  slideToClosest,
  slideToClickedSlide
};

function loopCreate(slideRealIndex) {
  const swiper = this;
  const {
    params,
    slidesEl
  } = swiper;
  if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;
  const initSlides = () => {
    const slides = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(slidesEl, `.${params.slideClass}, swiper-slide`);
    slides.forEach((el, index) => {
      el.setAttribute('data-swiper-slide-index', index);
    });
  };
  const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
  const slidesPerGroup = params.slidesPerGroup * (gridEnabled ? params.grid.rows : 1);
  const shouldFillGroup = swiper.slides.length % slidesPerGroup !== 0;
  const shouldFillGrid = gridEnabled && swiper.slides.length % params.grid.rows !== 0;
  const addBlankSlides = amountOfSlides => {
    for (let i = 0; i < amountOfSlides; i += 1) {
      const slideEl = swiper.isElement ? (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.c)('swiper-slide', [params.slideBlankClass]) : (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.c)('div', [params.slideClass, params.slideBlankClass]);
      swiper.slidesEl.append(slideEl);
    }
  };
  if (shouldFillGroup) {
    if (params.loopAddBlankSlides) {
      const slidesToAdd = slidesPerGroup - swiper.slides.length % slidesPerGroup;
      addBlankSlides(slidesToAdd);
      swiper.recalcSlides();
      swiper.updateSlides();
    } else {
      (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.u)('Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)');
    }
    initSlides();
  } else if (shouldFillGrid) {
    if (params.loopAddBlankSlides) {
      const slidesToAdd = params.grid.rows - swiper.slides.length % params.grid.rows;
      addBlankSlides(slidesToAdd);
      swiper.recalcSlides();
      swiper.updateSlides();
    } else {
      (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.u)('Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)');
    }
    initSlides();
  } else {
    initSlides();
  }
  swiper.loopFix({
    slideRealIndex,
    direction: params.centeredSlides ? undefined : 'next'
  });
}

function loopFix(_temp) {
  let {
    slideRealIndex,
    slideTo = true,
    direction,
    setTranslate,
    activeSlideIndex,
    byController,
    byMousewheel
  } = _temp === void 0 ? {} : _temp;
  const swiper = this;
  if (!swiper.params.loop) return;
  swiper.emit('beforeLoopFix');
  const {
    slides,
    allowSlidePrev,
    allowSlideNext,
    slidesEl,
    params
  } = swiper;
  const {
    centeredSlides
  } = params;
  swiper.allowSlidePrev = true;
  swiper.allowSlideNext = true;
  if (swiper.virtual && params.virtual.enabled) {
    if (slideTo) {
      if (!params.centeredSlides && swiper.snapIndex === 0) {
        swiper.slideTo(swiper.virtual.slides.length, 0, false, true);
      } else if (params.centeredSlides && swiper.snapIndex < params.slidesPerView) {
        swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true);
      } else if (swiper.snapIndex === swiper.snapGrid.length - 1) {
        swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);
      }
    }
    swiper.allowSlidePrev = allowSlidePrev;
    swiper.allowSlideNext = allowSlideNext;
    swiper.emit('loopFix');
    return;
  }
  let slidesPerView = params.slidesPerView;
  if (slidesPerView === 'auto') {
    slidesPerView = swiper.slidesPerViewDynamic();
  } else {
    slidesPerView = Math.ceil(parseFloat(params.slidesPerView, 10));
    if (centeredSlides && slidesPerView % 2 === 0) {
      slidesPerView = slidesPerView + 1;
    }
  }
  const slidesPerGroup = params.slidesPerGroupAuto ? slidesPerView : params.slidesPerGroup;
  let loopedSlides = slidesPerGroup;
  if (loopedSlides % slidesPerGroup !== 0) {
    loopedSlides += slidesPerGroup - loopedSlides % slidesPerGroup;
  }
  loopedSlides += params.loopAdditionalSlides;
  swiper.loopedSlides = loopedSlides;
  const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
  if (slides.length < slidesPerView + loopedSlides) {
    (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.u)('Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters');
  } else if (gridEnabled && params.grid.fill === 'row') {
    (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.u)('Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`');
  }
  const prependSlidesIndexes = [];
  const appendSlidesIndexes = [];
  let activeIndex = swiper.activeIndex;
  if (typeof activeSlideIndex === 'undefined') {
    activeSlideIndex = swiper.getSlideIndex(slides.filter(el => el.classList.contains(params.slideActiveClass))[0]);
  } else {
    activeIndex = activeSlideIndex;
  }
  const isNext = direction === 'next' || !direction;
  const isPrev = direction === 'prev' || !direction;
  let slidesPrepended = 0;
  let slidesAppended = 0;
  const cols = gridEnabled ? Math.ceil(slides.length / params.grid.rows) : slides.length;
  const activeColIndex = gridEnabled ? slides[activeSlideIndex].column : activeSlideIndex;
  const activeColIndexWithShift = activeColIndex + (centeredSlides && typeof setTranslate === 'undefined' ? -slidesPerView / 2 + 0.5 : 0);
  // prepend last slides before start
  if (activeColIndexWithShift < loopedSlides) {
    slidesPrepended = Math.max(loopedSlides - activeColIndexWithShift, slidesPerGroup);
    for (let i = 0; i < loopedSlides - activeColIndexWithShift; i += 1) {
      const index = i - Math.floor(i / cols) * cols;
      if (gridEnabled) {
        const colIndexToPrepend = cols - index - 1;
        for (let i = slides.length - 1; i >= 0; i -= 1) {
          if (slides[i].column === colIndexToPrepend) prependSlidesIndexes.push(i);
        }
        // slides.forEach((slide, slideIndex) => {
        //   if (slide.column === colIndexToPrepend) prependSlidesIndexes.push(slideIndex);
        // });
      } else {
        prependSlidesIndexes.push(cols - index - 1);
      }
    }
  } else if (activeColIndexWithShift + slidesPerView > cols - loopedSlides) {
    slidesAppended = Math.max(activeColIndexWithShift - (cols - loopedSlides * 2), slidesPerGroup);
    for (let i = 0; i < slidesAppended; i += 1) {
      const index = i - Math.floor(i / cols) * cols;
      if (gridEnabled) {
        slides.forEach((slide, slideIndex) => {
          if (slide.column === index) appendSlidesIndexes.push(slideIndex);
        });
      } else {
        appendSlidesIndexes.push(index);
      }
    }
  }
  swiper.__preventObserver__ = true;
  requestAnimationFrame(() => {
    swiper.__preventObserver__ = false;
  });
  if (isPrev) {
    prependSlidesIndexes.forEach(index => {
      slides[index].swiperLoopMoveDOM = true;
      slidesEl.prepend(slides[index]);
      slides[index].swiperLoopMoveDOM = false;
    });
  }
  if (isNext) {
    appendSlidesIndexes.forEach(index => {
      slides[index].swiperLoopMoveDOM = true;
      slidesEl.append(slides[index]);
      slides[index].swiperLoopMoveDOM = false;
    });
  }
  swiper.recalcSlides();
  if (params.slidesPerView === 'auto') {
    swiper.updateSlides();
  } else if (gridEnabled && (prependSlidesIndexes.length > 0 && isPrev || appendSlidesIndexes.length > 0 && isNext)) {
    swiper.slides.forEach((slide, slideIndex) => {
      swiper.grid.updateSlide(slideIndex, slide, swiper.slides);
    });
  }
  if (params.watchSlidesProgress) {
    swiper.updateSlidesOffset();
  }
  if (slideTo) {
    if (prependSlidesIndexes.length > 0 && isPrev) {
      if (typeof slideRealIndex === 'undefined') {
        const currentSlideTranslate = swiper.slidesGrid[activeIndex];
        const newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];
        const diff = newSlideTranslate - currentSlideTranslate;
        if (byMousewheel) {
          swiper.setTranslate(swiper.translate - diff);
        } else {
          swiper.slideTo(activeIndex + Math.ceil(slidesPrepended), 0, false, true);
          if (setTranslate) {
            swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;
            swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;
          }
        }
      } else {
        if (setTranslate) {
          const shift = gridEnabled ? prependSlidesIndexes.length / params.grid.rows : prependSlidesIndexes.length;
          swiper.slideTo(swiper.activeIndex + shift, 0, false, true);
          swiper.touchEventsData.currentTranslate = swiper.translate;
        }
      }
    } else if (appendSlidesIndexes.length > 0 && isNext) {
      if (typeof slideRealIndex === 'undefined') {
        const currentSlideTranslate = swiper.slidesGrid[activeIndex];
        const newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];
        const diff = newSlideTranslate - currentSlideTranslate;
        if (byMousewheel) {
          swiper.setTranslate(swiper.translate - diff);
        } else {
          swiper.slideTo(activeIndex - slidesAppended, 0, false, true);
          if (setTranslate) {
            swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;
            swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;
          }
        }
      } else {
        const shift = gridEnabled ? appendSlidesIndexes.length / params.grid.rows : appendSlidesIndexes.length;
        swiper.slideTo(swiper.activeIndex - shift, 0, false, true);
      }
    }
  }
  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;
  if (swiper.controller && swiper.controller.control && !byController) {
    const loopParams = {
      slideRealIndex,
      direction,
      setTranslate,
      activeSlideIndex,
      byController: true
    };
    if (Array.isArray(swiper.controller.control)) {
      swiper.controller.control.forEach(c => {
        if (!c.destroyed && c.params.loop) c.loopFix({
          ...loopParams,
          slideTo: c.params.slidesPerView === params.slidesPerView ? slideTo : false
        });
      });
    } else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) {
      swiper.controller.control.loopFix({
        ...loopParams,
        slideTo: swiper.controller.control.params.slidesPerView === params.slidesPerView ? slideTo : false
      });
    }
  }
  swiper.emit('loopFix');
}

function loopDestroy() {
  const swiper = this;
  const {
    params,
    slidesEl
  } = swiper;
  if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;
  swiper.recalcSlides();
  const newSlidesOrder = [];
  swiper.slides.forEach(slideEl => {
    const index = typeof slideEl.swiperSlideIndex === 'undefined' ? slideEl.getAttribute('data-swiper-slide-index') * 1 : slideEl.swiperSlideIndex;
    newSlidesOrder[index] = slideEl;
  });
  swiper.slides.forEach(slideEl => {
    slideEl.removeAttribute('data-swiper-slide-index');
  });
  newSlidesOrder.forEach(slideEl => {
    slidesEl.append(slideEl);
  });
  swiper.recalcSlides();
  swiper.slideTo(swiper.realIndex, 0);
}

var loop = {
  loopCreate,
  loopFix,
  loopDestroy
};

function setGrabCursor(moving) {
  const swiper = this;
  if (!swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
  const el = swiper.params.touchEventsTarget === 'container' ? swiper.el : swiper.wrapperEl;
  if (swiper.isElement) {
    swiper.__preventObserver__ = true;
  }
  el.style.cursor = 'move';
  el.style.cursor = moving ? 'grabbing' : 'grab';
  if (swiper.isElement) {
    requestAnimationFrame(() => {
      swiper.__preventObserver__ = false;
    });
  }
}

function unsetGrabCursor() {
  const swiper = this;
  if (swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
    return;
  }
  if (swiper.isElement) {
    swiper.__preventObserver__ = true;
  }
  swiper[swiper.params.touchEventsTarget === 'container' ? 'el' : 'wrapperEl'].style.cursor = '';
  if (swiper.isElement) {
    requestAnimationFrame(() => {
      swiper.__preventObserver__ = false;
    });
  }
}

var grabCursor = {
  setGrabCursor,
  unsetGrabCursor
};

// Modified from https://stackoverflow.com/questions/54520554/custom-element-getrootnode-closest-function-crossing-multiple-parent-shadowd
function closestElement(selector, base) {
  if (base === void 0) {
    base = this;
  }
  function __closestFrom(el) {
    if (!el || el === (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)() || el === (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)()) return null;
    if (el.assignedSlot) el = el.assignedSlot;
    const found = el.closest(selector);
    if (!found && !el.getRootNode) {
      return null;
    }
    return found || __closestFrom(el.getRootNode().host);
  }
  return __closestFrom(base);
}
function preventEdgeSwipe(swiper, event, startX) {
  const window = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();
  const {
    params
  } = swiper;
  const edgeSwipeDetection = params.edgeSwipeDetection;
  const edgeSwipeThreshold = params.edgeSwipeThreshold;
  if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {
    if (edgeSwipeDetection === 'prevent') {
      event.preventDefault();
      return true;
    }
    return false;
  }
  return true;
}
function onTouchStart(event) {
  const swiper = this;
  const document = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();
  let e = event;
  if (e.originalEvent) e = e.originalEvent;
  const data = swiper.touchEventsData;
  if (e.type === 'pointerdown') {
    if (data.pointerId !== null && data.pointerId !== e.pointerId) {
      return;
    }
    data.pointerId = e.pointerId;
  } else if (e.type === 'touchstart' && e.targetTouches.length === 1) {
    data.touchId = e.targetTouches[0].identifier;
  }
  if (e.type === 'touchstart') {
    // don't proceed touch event
    preventEdgeSwipe(swiper, e, e.targetTouches[0].pageX);
    return;
  }
  const {
    params,
    touches,
    enabled
  } = swiper;
  if (!enabled) return;
  if (!params.simulateTouch && e.pointerType === 'mouse') return;
  if (swiper.animating && params.preventInteractionOnTransition) {
    return;
  }
  if (!swiper.animating && params.cssMode && params.loop) {
    swiper.loopFix();
  }
  let targetEl = e.target;
  if (params.touchEventsTarget === 'wrapper') {
    if (!(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.v)(targetEl, swiper.wrapperEl)) return;
  }
  if ('which' in e && e.which === 3) return;
  if ('button' in e && e.button > 0) return;
  if (data.isTouched && data.isMoved) return;

  // change target el for shadow root component
  const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';
  // eslint-disable-next-line
  const eventPath = e.composedPath ? e.composedPath() : e.path;
  if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) {
    targetEl = eventPath[0];
  }
  const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
  const isTargetShadow = !!(e.target && e.target.shadowRoot);

  // use closestElement for shadow root element to get the actual closest for nested shadow root element
  if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {
    swiper.allowClick = true;
    return;
  }
  if (params.swipeHandler) {
    if (!targetEl.closest(params.swipeHandler)) return;
  }
  touches.currentX = e.pageX;
  touches.currentY = e.pageY;
  const startX = touches.currentX;
  const startY = touches.currentY;

  // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore

  if (!preventEdgeSwipe(swiper, e, startX)) {
    return;
  }
  Object.assign(data, {
    isTouched: true,
    isMoved: false,
    allowTouchCallbacks: true,
    isScrolling: undefined,
    startMoving: undefined
  });
  touches.startX = startX;
  touches.startY = startY;
  data.touchStartTime = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.d)();
  swiper.allowClick = true;
  swiper.updateSize();
  swiper.swipeDirection = undefined;
  if (params.threshold > 0) data.allowThresholdMove = false;
  let preventDefault = true;
  if (targetEl.matches(data.focusableElements)) {
    preventDefault = false;
    if (targetEl.nodeName === 'SELECT') {
      data.isTouched = false;
    }
  }
  if (document.activeElement && document.activeElement.matches(data.focusableElements) && document.activeElement !== targetEl && (e.pointerType === 'mouse' || e.pointerType !== 'mouse' && !targetEl.matches(data.focusableElements))) {
    document.activeElement.blur();
  }
  const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
  if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) {
    e.preventDefault();
  }
  if (params.freeMode && params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {
    swiper.freeMode.onTouchStart();
  }
  swiper.emit('touchStart', e);
}

function onTouchMove(event) {
  const document = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();
  const swiper = this;
  const data = swiper.touchEventsData;
  const {
    params,
    touches,
    rtlTranslate: rtl,
    enabled
  } = swiper;
  if (!enabled) return;
  if (!params.simulateTouch && event.pointerType === 'mouse') return;
  let e = event;
  if (e.originalEvent) e = e.originalEvent;
  if (e.type === 'pointermove') {
    if (data.touchId !== null) return; // return from pointer if we use touch
    const id = e.pointerId;
    if (id !== data.pointerId) return;
  }
  let targetTouch;
  if (e.type === 'touchmove') {
    targetTouch = [...e.changedTouches].filter(t => t.identifier === data.touchId)[0];
    if (!targetTouch || targetTouch.identifier !== data.touchId) return;
  } else {
    targetTouch = e;
  }
  if (!data.isTouched) {
    if (data.startMoving && data.isScrolling) {
      swiper.emit('touchMoveOpposite', e);
    }
    return;
  }
  const pageX = targetTouch.pageX;
  const pageY = targetTouch.pageY;
  if (e.preventedByNestedSwiper) {
    touches.startX = pageX;
    touches.startY = pageY;
    return;
  }
  if (!swiper.allowTouchMove) {
    if (!e.target.matches(data.focusableElements)) {
      swiper.allowClick = false;
    }
    if (data.isTouched) {
      Object.assign(touches, {
        startX: pageX,
        startY: pageY,
        currentX: pageX,
        currentY: pageY
      });
      data.touchStartTime = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.d)();
    }
    return;
  }
  if (params.touchReleaseOnEdges && !params.loop) {
    if (swiper.isVertical()) {
      // Vertical
      if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
        data.isTouched = false;
        data.isMoved = false;
        return;
      }
    } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
      return;
    }
  }
  if (document.activeElement && document.activeElement.matches(data.focusableElements) && document.activeElement !== e.target && e.pointerType !== 'mouse') {
    document.activeElement.blur();
  }
  if (document.activeElement) {
    if (e.target === document.activeElement && e.target.matches(data.focusableElements)) {
      data.isMoved = true;
      swiper.allowClick = false;
      return;
    }
  }
  if (data.allowTouchCallbacks) {
    swiper.emit('touchMove', e);
  }
  touches.previousX = touches.currentX;
  touches.previousY = touches.currentY;
  touches.currentX = pageX;
  touches.currentY = pageY;
  const diffX = touches.currentX - touches.startX;
  const diffY = touches.currentY - touches.startY;
  if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;
  if (typeof data.isScrolling === 'undefined') {
    let touchAngle;
    if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
      data.isScrolling = false;
    } else {
      // eslint-disable-next-line
      if (diffX * diffX + diffY * diffY >= 25) {
        touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
        data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
      }
    }
  }
  if (data.isScrolling) {
    swiper.emit('touchMoveOpposite', e);
  }
  if (typeof data.startMoving === 'undefined') {
    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
      data.startMoving = true;
    }
  }
  if (data.isScrolling || e.type === 'touchmove' && data.preventTouchMoveFromPointerMove) {
    data.isTouched = false;
    return;
  }
  if (!data.startMoving) {
    return;
  }
  swiper.allowClick = false;
  if (!params.cssMode && e.cancelable) {
    e.preventDefault();
  }
  if (params.touchMoveStopPropagation && !params.nested) {
    e.stopPropagation();
  }
  let diff = swiper.isHorizontal() ? diffX : diffY;
  let touchesDiff = swiper.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;
  if (params.oneWayMovement) {
    diff = Math.abs(diff) * (rtl ? 1 : -1);
    touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);
  }
  touches.diff = diff;
  diff *= params.touchRatio;
  if (rtl) {
    diff = -diff;
    touchesDiff = -touchesDiff;
  }
  const prevTouchesDirection = swiper.touchesDirection;
  swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
  swiper.touchesDirection = touchesDiff > 0 ? 'prev' : 'next';
  const isLoop = swiper.params.loop && !params.cssMode;
  const allowLoopFix = swiper.touchesDirection === 'next' && swiper.allowSlideNext || swiper.touchesDirection === 'prev' && swiper.allowSlidePrev;
  if (!data.isMoved) {
    if (isLoop && allowLoopFix) {
      swiper.loopFix({
        direction: swiper.swipeDirection
      });
    }
    data.startTranslate = swiper.getTranslate();
    swiper.setTransition(0);
    if (swiper.animating) {
      const evt = new window.CustomEvent('transitionend', {
        bubbles: true,
        cancelable: true,
        detail: {
          bySwiperTouchMove: true
        }
      });
      swiper.wrapperEl.dispatchEvent(evt);
    }
    data.allowMomentumBounce = false;
    // Grab Cursor
    if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
      swiper.setGrabCursor(true);
    }
    swiper.emit('sliderFirstMove', e);
  }
  let loopFixed;
  new Date().getTime();
  if (data.isMoved && data.allowThresholdMove && prevTouchesDirection !== swiper.touchesDirection && isLoop && allowLoopFix && Math.abs(diff) >= 1) {
    Object.assign(touches, {
      startX: pageX,
      startY: pageY,
      currentX: pageX,
      currentY: pageY,
      startTranslate: data.currentTranslate
    });
    data.loopSwapReset = true;
    data.startTranslate = data.currentTranslate;
    return;
  }
  swiper.emit('sliderMove', e);
  data.isMoved = true;
  data.currentTranslate = diff + data.startTranslate;
  let disableParentSwiper = true;
  let resistanceRatio = params.resistanceRatio;
  if (params.touchReleaseOnEdges) {
    resistanceRatio = 0;
  }
  if (diff > 0) {
    if (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate > (params.centeredSlides ? swiper.minTranslate() - swiper.slidesSizesGrid[swiper.activeIndex + 1] - (params.slidesPerView !== 'auto' && swiper.slides.length - params.slidesPerView >= 2 ? swiper.slidesSizesGrid[swiper.activeIndex + 1] + swiper.params.spaceBetween : 0) - swiper.params.spaceBetween : swiper.minTranslate())) {
      swiper.loopFix({
        direction: 'prev',
        setTranslate: true,
        activeSlideIndex: 0
      });
    }
    if (data.currentTranslate > swiper.minTranslate()) {
      disableParentSwiper = false;
      if (params.resistance) {
        data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
      }
    }
  } else if (diff < 0) {
    if (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate < (params.centeredSlides ? swiper.maxTranslate() + swiper.slidesSizesGrid[swiper.slidesSizesGrid.length - 1] + swiper.params.spaceBetween + (params.slidesPerView !== 'auto' && swiper.slides.length - params.slidesPerView >= 2 ? swiper.slidesSizesGrid[swiper.slidesSizesGrid.length - 1] + swiper.params.spaceBetween : 0) : swiper.maxTranslate())) {
      swiper.loopFix({
        direction: 'next',
        setTranslate: true,
        activeSlideIndex: swiper.slides.length - (params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))
      });
    }
    if (data.currentTranslate < swiper.maxTranslate()) {
      disableParentSwiper = false;
      if (params.resistance) {
        data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
      }
    }
  }
  if (disableParentSwiper) {
    e.preventedByNestedSwiper = true;
  }

  // Directions locks
  if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }
  if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }
  if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
    data.currentTranslate = data.startTranslate;
  }

  // Threshold
  if (params.threshold > 0) {
    if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
      if (!data.allowThresholdMove) {
        data.allowThresholdMove = true;
        touches.startX = touches.currentX;
        touches.startY = touches.currentY;
        data.currentTranslate = data.startTranslate;
        touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
        return;
      }
    } else {
      data.currentTranslate = data.startTranslate;
      return;
    }
  }
  if (!params.followFinger || params.cssMode) return;

  // Update active index in free mode
  if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }
  if (params.freeMode && params.freeMode.enabled && swiper.freeMode) {
    swiper.freeMode.onTouchMove();
  }
  // Update progress
  swiper.updateProgress(data.currentTranslate);
  // Update translate
  swiper.setTranslate(data.currentTranslate);
}

function onTouchEnd(event) {
  const swiper = this;
  const data = swiper.touchEventsData;
  let e = event;
  if (e.originalEvent) e = e.originalEvent;
  let targetTouch;
  const isTouchEvent = e.type === 'touchend' || e.type === 'touchcancel';
  if (!isTouchEvent) {
    if (data.touchId !== null) return; // return from pointer if we use touch
    if (e.pointerId !== data.pointerId) return;
    targetTouch = e;
  } else {
    targetTouch = [...e.changedTouches].filter(t => t.identifier === data.touchId)[0];
    if (!targetTouch || targetTouch.identifier !== data.touchId) return;
  }
  if (['pointercancel', 'pointerout', 'pointerleave', 'contextmenu'].includes(e.type)) {
    const proceed = ['pointercancel', 'contextmenu'].includes(e.type) && (swiper.browser.isSafari || swiper.browser.isWebView);
    if (!proceed) {
      return;
    }
  }
  data.pointerId = null;
  data.touchId = null;
  const {
    params,
    touches,
    rtlTranslate: rtl,
    slidesGrid,
    enabled
  } = swiper;
  if (!enabled) return;
  if (!params.simulateTouch && e.pointerType === 'mouse') return;
  if (data.allowTouchCallbacks) {
    swiper.emit('touchEnd', e);
  }
  data.allowTouchCallbacks = false;
  if (!data.isTouched) {
    if (data.isMoved && params.grabCursor) {
      swiper.setGrabCursor(false);
    }
    data.isMoved = false;
    data.startMoving = false;
    return;
  }

  // Return Grab Cursor
  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
    swiper.setGrabCursor(false);
  }

  // Time diff
  const touchEndTime = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.d)();
  const timeDiff = touchEndTime - data.touchStartTime;

  // Tap, doubleTap, Click
  if (swiper.allowClick) {
    const pathTree = e.path || e.composedPath && e.composedPath();
    swiper.updateClickedSlide(pathTree && pathTree[0] || e.target, pathTree);
    swiper.emit('tap click', e);
    if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
      swiper.emit('doubleTap doubleClick', e);
    }
  }
  data.lastClickTime = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.d)();
  (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.n)(() => {
    if (!swiper.destroyed) swiper.allowClick = true;
  });
  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 && !data.loopSwapReset || data.currentTranslate === data.startTranslate && !data.loopSwapReset) {
    data.isTouched = false;
    data.isMoved = false;
    data.startMoving = false;
    return;
  }
  data.isTouched = false;
  data.isMoved = false;
  data.startMoving = false;
  let currentPos;
  if (params.followFinger) {
    currentPos = rtl ? swiper.translate : -swiper.translate;
  } else {
    currentPos = -data.currentTranslate;
  }
  if (params.cssMode) {
    return;
  }
  if (params.freeMode && params.freeMode.enabled) {
    swiper.freeMode.onTouchEnd({
      currentPos
    });
    return;
  }

  // Find current slide
  const swipeToLast = currentPos >= -swiper.maxTranslate() && !swiper.params.loop;
  let stopIndex = 0;
  let groupSize = swiper.slidesSizesGrid[0];
  for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
    const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
    if (typeof slidesGrid[i + increment] !== 'undefined') {
      if (swipeToLast || currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {
        stopIndex = i;
        groupSize = slidesGrid[i + increment] - slidesGrid[i];
      }
    } else if (swipeToLast || currentPos >= slidesGrid[i]) {
      stopIndex = i;
      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
    }
  }
  let rewindFirstIndex = null;
  let rewindLastIndex = null;
  if (params.rewind) {
    if (swiper.isBeginning) {
      rewindLastIndex = params.virtual && params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
    } else if (swiper.isEnd) {
      rewindFirstIndex = 0;
    }
  }
  // Find current slide size
  const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
  const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
  if (timeDiff > params.longSwipesMs) {
    // Long touches
    if (!params.longSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    if (swiper.swipeDirection === 'next') {
      if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);else swiper.slideTo(stopIndex);
    }
    if (swiper.swipeDirection === 'prev') {
      if (ratio > 1 - params.longSwipesRatio) {
        swiper.slideTo(stopIndex + increment);
      } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {
        swiper.slideTo(rewindLastIndex);
      } else {
        swiper.slideTo(stopIndex);
      }
    }
  } else {
    // Short swipes
    if (!params.shortSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);
    if (!isNavButtonTarget) {
      if (swiper.swipeDirection === 'next') {
        swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);
      }
      if (swiper.swipeDirection === 'prev') {
        swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);
      }
    } else if (e.target === swiper.navigation.nextEl) {
      swiper.slideTo(stopIndex + increment);
    } else {
      swiper.slideTo(stopIndex);
    }
  }
}

function onResize() {
  const swiper = this;
  const {
    params,
    el
  } = swiper;
  if (el && el.offsetWidth === 0) return;

  // Breakpoints
  if (params.breakpoints) {
    swiper.setBreakpoint();
  }

  // Save locks
  const {
    allowSlideNext,
    allowSlidePrev,
    snapGrid
  } = swiper;
  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;

  // Disable locks on resize
  swiper.allowSlideNext = true;
  swiper.allowSlidePrev = true;
  swiper.updateSize();
  swiper.updateSlides();
  swiper.updateSlidesClasses();
  const isVirtualLoop = isVirtual && params.loop;
  if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides && !isVirtualLoop) {
    swiper.slideTo(swiper.slides.length - 1, 0, false, true);
  } else {
    if (swiper.params.loop && !isVirtual) {
      swiper.slideToLoop(swiper.realIndex, 0, false, true);
    } else {
      swiper.slideTo(swiper.activeIndex, 0, false, true);
    }
  }
  if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
    clearTimeout(swiper.autoplay.resizeTimeout);
    swiper.autoplay.resizeTimeout = setTimeout(() => {
      if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
        swiper.autoplay.resume();
      }
    }, 500);
  }
  // Return locks after resize
  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;
  if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
    swiper.checkOverflow();
  }
}

function onClick(e) {
  const swiper = this;
  if (!swiper.enabled) return;
  if (!swiper.allowClick) {
    if (swiper.params.preventClicks) e.preventDefault();
    if (swiper.params.preventClicksPropagation && swiper.animating) {
      e.stopPropagation();
      e.stopImmediatePropagation();
    }
  }
}

function onScroll() {
  const swiper = this;
  const {
    wrapperEl,
    rtlTranslate,
    enabled
  } = swiper;
  if (!enabled) return;
  swiper.previousTranslate = swiper.translate;
  if (swiper.isHorizontal()) {
    swiper.translate = -wrapperEl.scrollLeft;
  } else {
    swiper.translate = -wrapperEl.scrollTop;
  }
  // eslint-disable-next-line
  if (swiper.translate === 0) swiper.translate = 0;
  swiper.updateActiveIndex();
  swiper.updateSlidesClasses();
  let newProgress;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
  }
  if (newProgress !== swiper.progress) {
    swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
  }
  swiper.emit('setTranslate', swiper.translate, false);
}

function onLoad(e) {
  const swiper = this;
  processLazyPreloader(swiper, e.target);
  if (swiper.params.cssMode || swiper.params.slidesPerView !== 'auto' && !swiper.params.autoHeight) {
    return;
  }
  swiper.update();
}

function onDocumentTouchStart() {
  const swiper = this;
  if (swiper.documentTouchHandlerProceeded) return;
  swiper.documentTouchHandlerProceeded = true;
  if (swiper.params.touchReleaseOnEdges) {
    swiper.el.style.touchAction = 'auto';
  }
}

const events = (swiper, method) => {
  const document = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();
  const {
    params,
    el,
    wrapperEl,
    device
  } = swiper;
  const capture = !!params.nested;
  const domMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';
  const swiperMethod = method;
  if (!el || typeof el === 'string') return;

  // Touch Events
  document[domMethod]('touchstart', swiper.onDocumentTouchStart, {
    passive: false,
    capture
  });
  el[domMethod]('touchstart', swiper.onTouchStart, {
    passive: false
  });
  el[domMethod]('pointerdown', swiper.onTouchStart, {
    passive: false
  });
  document[domMethod]('touchmove', swiper.onTouchMove, {
    passive: false,
    capture
  });
  document[domMethod]('pointermove', swiper.onTouchMove, {
    passive: false,
    capture
  });
  document[domMethod]('touchend', swiper.onTouchEnd, {
    passive: true
  });
  document[domMethod]('pointerup', swiper.onTouchEnd, {
    passive: true
  });
  document[domMethod]('pointercancel', swiper.onTouchEnd, {
    passive: true
  });
  document[domMethod]('touchcancel', swiper.onTouchEnd, {
    passive: true
  });
  document[domMethod]('pointerout', swiper.onTouchEnd, {
    passive: true
  });
  document[domMethod]('pointerleave', swiper.onTouchEnd, {
    passive: true
  });
  document[domMethod]('contextmenu', swiper.onTouchEnd, {
    passive: true
  });

  // Prevent Links Clicks
  if (params.preventClicks || params.preventClicksPropagation) {
    el[domMethod]('click', swiper.onClick, true);
  }
  if (params.cssMode) {
    wrapperEl[domMethod]('scroll', swiper.onScroll);
  }

  // Resize handler
  if (params.updateOnWindowResize) {
    swiper[swiperMethod](device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize, true);
  } else {
    swiper[swiperMethod]('observerUpdate', onResize, true);
  }

  // Images loader
  el[domMethod]('load', swiper.onLoad, {
    capture: true
  });
};
function attachEvents() {
  const swiper = this;
  const {
    params
  } = swiper;
  swiper.onTouchStart = onTouchStart.bind(swiper);
  swiper.onTouchMove = onTouchMove.bind(swiper);
  swiper.onTouchEnd = onTouchEnd.bind(swiper);
  swiper.onDocumentTouchStart = onDocumentTouchStart.bind(swiper);
  if (params.cssMode) {
    swiper.onScroll = onScroll.bind(swiper);
  }
  swiper.onClick = onClick.bind(swiper);
  swiper.onLoad = onLoad.bind(swiper);
  events(swiper, 'on');
}
function detachEvents() {
  const swiper = this;
  events(swiper, 'off');
}
var events$1 = {
  attachEvents,
  detachEvents
};

const isGridEnabled = (swiper, params) => {
  return swiper.grid && params.grid && params.grid.rows > 1;
};
function setBreakpoint() {
  const swiper = this;
  const {
    realIndex,
    initialized,
    params,
    el
  } = swiper;
  const breakpoints = params.breakpoints;
  if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return;

  // Get breakpoint for window width and update parameters
  const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);
  if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
  const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;
  const breakpointParams = breakpointOnlyParams || swiper.originalParams;
  const wasMultiRow = isGridEnabled(swiper, params);
  const isMultiRow = isGridEnabled(swiper, breakpointParams);
  const wasGrabCursor = swiper.params.grabCursor;
  const isGrabCursor = breakpointParams.grabCursor;
  const wasEnabled = params.enabled;
  if (wasMultiRow && !isMultiRow) {
    el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);
    swiper.emitContainerClasses();
  } else if (!wasMultiRow && isMultiRow) {
    el.classList.add(`${params.containerModifierClass}grid`);
    if (breakpointParams.grid.fill && breakpointParams.grid.fill === 'column' || !breakpointParams.grid.fill && params.grid.fill === 'column') {
      el.classList.add(`${params.containerModifierClass}grid-column`);
    }
    swiper.emitContainerClasses();
  }
  if (wasGrabCursor && !isGrabCursor) {
    swiper.unsetGrabCursor();
  } else if (!wasGrabCursor && isGrabCursor) {
    swiper.setGrabCursor();
  }

  // Toggle navigation, pagination, scrollbar
  ['navigation', 'pagination', 'scrollbar'].forEach(prop => {
    if (typeof breakpointParams[prop] === 'undefined') return;
    const wasModuleEnabled = params[prop] && params[prop].enabled;
    const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;
    if (wasModuleEnabled && !isModuleEnabled) {
      swiper[prop].disable();
    }
    if (!wasModuleEnabled && isModuleEnabled) {
      swiper[prop].enable();
    }
  });
  const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
  const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
  const wasLoop = params.loop;
  if (directionChanged && initialized) {
    swiper.changeDirection();
  }
  (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.w)(swiper.params, breakpointParams);
  const isEnabled = swiper.params.enabled;
  const hasLoop = swiper.params.loop;
  Object.assign(swiper, {
    allowTouchMove: swiper.params.allowTouchMove,
    allowSlideNext: swiper.params.allowSlideNext,
    allowSlidePrev: swiper.params.allowSlidePrev
  });
  if (wasEnabled && !isEnabled) {
    swiper.disable();
  } else if (!wasEnabled && isEnabled) {
    swiper.enable();
  }
  swiper.currentBreakpoint = breakpoint;
  swiper.emit('_beforeBreakpoint', breakpointParams);
  if (initialized) {
    if (needsReLoop) {
      swiper.loopDestroy();
      swiper.loopCreate(realIndex);
      swiper.updateSlides();
    } else if (!wasLoop && hasLoop) {
      swiper.loopCreate(realIndex);
      swiper.updateSlides();
    } else if (wasLoop && !hasLoop) {
      swiper.loopDestroy();
    }
  }
  swiper.emit('breakpoint', breakpointParams);
}

function getBreakpoint(breakpoints, base, containerEl) {
  if (base === void 0) {
    base = 'window';
  }
  if (!breakpoints || base === 'container' && !containerEl) return undefined;
  let breakpoint = false;
  const window = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();
  const currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;
  const points = Object.keys(breakpoints).map(point => {
    if (typeof point === 'string' && point.indexOf('@') === 0) {
      const minRatio = parseFloat(point.substr(1));
      const value = currentHeight * minRatio;
      return {
        value,
        point
      };
    }
    return {
      value: point,
      point
    };
  });
  points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));
  for (let i = 0; i < points.length; i += 1) {
    const {
      point,
      value
    } = points[i];
    if (base === 'window') {
      if (window.matchMedia(`(min-width: ${value}px)`).matches) {
        breakpoint = point;
      }
    } else if (value <= containerEl.clientWidth) {
      breakpoint = point;
    }
  }
  return breakpoint || 'max';
}

var breakpoints = {
  setBreakpoint,
  getBreakpoint
};

function prepareClasses(entries, prefix) {
  const resultClasses = [];
  entries.forEach(item => {
    if (typeof item === 'object') {
      Object.keys(item).forEach(classNames => {
        if (item[classNames]) {
          resultClasses.push(prefix + classNames);
        }
      });
    } else if (typeof item === 'string') {
      resultClasses.push(prefix + item);
    }
  });
  return resultClasses;
}
function addClasses() {
  const swiper = this;
  const {
    classNames,
    params,
    rtl,
    el,
    device
  } = swiper;
  // prettier-ignore
  const suffixes = prepareClasses(['initialized', params.direction, {
    'free-mode': swiper.params.freeMode && params.freeMode.enabled
  }, {
    'autoheight': params.autoHeight
  }, {
    'rtl': rtl
  }, {
    'grid': params.grid && params.grid.rows > 1
  }, {
    'grid-column': params.grid && params.grid.rows > 1 && params.grid.fill === 'column'
  }, {
    'android': device.android
  }, {
    'ios': device.ios
  }, {
    'css-mode': params.cssMode
  }, {
    'centered': params.cssMode && params.centeredSlides
  }, {
    'watch-progress': params.watchSlidesProgress
  }], params.containerModifierClass);
  classNames.push(...suffixes);
  el.classList.add(...classNames);
  swiper.emitContainerClasses();
}

function removeClasses() {
  const swiper = this;
  const {
    el,
    classNames
  } = swiper;
  if (!el || typeof el === 'string') return;
  el.classList.remove(...classNames);
  swiper.emitContainerClasses();
}

var classes = {
  addClasses,
  removeClasses
};

function checkOverflow() {
  const swiper = this;
  const {
    isLocked: wasLocked,
    params
  } = swiper;
  const {
    slidesOffsetBefore
  } = params;
  if (slidesOffsetBefore) {
    const lastSlideIndex = swiper.slides.length - 1;
    const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
    swiper.isLocked = swiper.size > lastSlideRightEdge;
  } else {
    swiper.isLocked = swiper.snapGrid.length === 1;
  }
  if (params.allowSlideNext === true) {
    swiper.allowSlideNext = !swiper.isLocked;
  }
  if (params.allowSlidePrev === true) {
    swiper.allowSlidePrev = !swiper.isLocked;
  }
  if (wasLocked && wasLocked !== swiper.isLocked) {
    swiper.isEnd = false;
  }
  if (wasLocked !== swiper.isLocked) {
    swiper.emit(swiper.isLocked ? 'lock' : 'unlock');
  }
}
var checkOverflow$1 = {
  checkOverflow
};

var defaults = {
  init: true,
  direction: 'horizontal',
  oneWayMovement: false,
  swiperElementNodeName: 'SWIPER-CONTAINER',
  touchEventsTarget: 'wrapper',
  initialSlide: 0,
  speed: 300,
  cssMode: false,
  updateOnWindowResize: true,
  resizeObserver: true,
  nested: false,
  createElements: false,
  eventsPrefix: 'swiper',
  enabled: true,
  focusableElements: 'input, select, option, textarea, button, video, label',
  // Overrides
  width: null,
  height: null,
  //
  preventInteractionOnTransition: false,
  // ssr
  userAgent: null,
  url: null,
  // To support iOS's swipe-to-go-back gesture (when being used in-app).
  edgeSwipeDetection: false,
  edgeSwipeThreshold: 20,
  // Autoheight
  autoHeight: false,
  // Set wrapper width
  setWrapperSize: false,
  // Virtual Translate
  virtualTranslate: false,
  // Effects
  effect: 'slide',
  // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'

  // Breakpoints
  breakpoints: undefined,
  breakpointsBase: 'window',
  // Slides grid
  spaceBetween: 0,
  slidesPerView: 1,
  slidesPerGroup: 1,
  slidesPerGroupSkip: 0,
  slidesPerGroupAuto: false,
  centeredSlides: false,
  centeredSlidesBounds: false,
  slidesOffsetBefore: 0,
  // in px
  slidesOffsetAfter: 0,
  // in px
  normalizeSlideIndex: true,
  centerInsufficientSlides: false,
  // Disable swiper and hide navigation when container not overflow
  watchOverflow: true,
  // Round length
  roundLengths: false,
  // Touches
  touchRatio: 1,
  touchAngle: 45,
  simulateTouch: true,
  shortSwipes: true,
  longSwipes: true,
  longSwipesRatio: 0.5,
  longSwipesMs: 300,
  followFinger: true,
  allowTouchMove: true,
  threshold: 5,
  touchMoveStopPropagation: false,
  touchStartPreventDefault: true,
  touchStartForcePreventDefault: false,
  touchReleaseOnEdges: false,
  // Unique Navigation Elements
  uniqueNavElements: true,
  // Resistance
  resistance: true,
  resistanceRatio: 0.85,
  // Progress
  watchSlidesProgress: false,
  // Cursor
  grabCursor: false,
  // Clicks
  preventClicks: true,
  preventClicksPropagation: true,
  slideToClickedSlide: false,
  // loop
  loop: false,
  loopAddBlankSlides: true,
  loopAdditionalSlides: 0,
  loopPreventsSliding: true,
  // rewind
  rewind: false,
  // Swiping/no swiping
  allowSlidePrev: true,
  allowSlideNext: true,
  swipeHandler: null,
  // '.swipe-handler',
  noSwiping: true,
  noSwipingClass: 'swiper-no-swiping',
  noSwipingSelector: null,
  // Passive Listeners
  passiveListeners: true,
  maxBackfaceHiddenSlides: 10,
  // NS
  containerModifierClass: 'swiper-',
  // NEW
  slideClass: 'swiper-slide',
  slideBlankClass: 'swiper-slide-blank',
  slideActiveClass: 'swiper-slide-active',
  slideVisibleClass: 'swiper-slide-visible',
  slideFullyVisibleClass: 'swiper-slide-fully-visible',
  slideNextClass: 'swiper-slide-next',
  slidePrevClass: 'swiper-slide-prev',
  wrapperClass: 'swiper-wrapper',
  lazyPreloaderClass: 'swiper-lazy-preloader',
  lazyPreloadPrevNext: 0,
  // Callbacks
  runCallbacksOnInit: true,
  // Internals
  _emitClasses: false
};

function moduleExtendParams(params, allModulesParams) {
  return function extendParams(obj) {
    if (obj === void 0) {
      obj = {};
    }
    const moduleParamName = Object.keys(obj)[0];
    const moduleParams = obj[moduleParamName];
    if (typeof moduleParams !== 'object' || moduleParams === null) {
      (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.w)(allModulesParams, obj);
      return;
    }
    if (params[moduleParamName] === true) {
      params[moduleParamName] = {
        enabled: true
      };
    }
    if (moduleParamName === 'navigation' && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].prevEl && !params[moduleParamName].nextEl) {
      params[moduleParamName].auto = true;
    }
    if (['pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].el) {
      params[moduleParamName].auto = true;
    }
    if (!(moduleParamName in params && 'enabled' in moduleParams)) {
      (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.w)(allModulesParams, obj);
      return;
    }
    if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {
      params[moduleParamName].enabled = true;
    }
    if (!params[moduleParamName]) params[moduleParamName] = {
      enabled: false
    };
    (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.w)(allModulesParams, obj);
  };
}

/* eslint no-param-reassign: "off" */
const prototypes = {
  eventsEmitter,
  update,
  translate,
  transition,
  slide,
  loop,
  grabCursor,
  events: events$1,
  breakpoints,
  checkOverflow: checkOverflow$1,
  classes
};
const extendedDefaults = {};
class Swiper {
  constructor() {
    let el;
    let params;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object') {
      params = args[0];
    } else {
      [el, params] = args;
    }
    if (!params) params = {};
    params = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.w)({}, params);
    if (el && !params.el) params.el = el;
    const document = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();
    if (params.el && typeof params.el === 'string' && document.querySelectorAll(params.el).length > 1) {
      const swipers = [];
      document.querySelectorAll(params.el).forEach(containerEl => {
        const newParams = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.w)({}, params, {
          el: containerEl
        });
        swipers.push(new Swiper(newParams));
      });
      // eslint-disable-next-line no-constructor-return
      return swipers;
    }

    // Swiper Instance
    const swiper = this;
    swiper.__swiper__ = true;
    swiper.support = getSupport();
    swiper.device = getDevice({
      userAgent: params.userAgent
    });
    swiper.browser = getBrowser();
    swiper.eventsListeners = {};
    swiper.eventsAnyListeners = [];
    swiper.modules = [...swiper.__modules__];
    if (params.modules && Array.isArray(params.modules)) {
      swiper.modules.push(...params.modules);
    }
    const allModulesParams = {};
    swiper.modules.forEach(mod => {
      mod({
        params,
        swiper,
        extendParams: moduleExtendParams(params, allModulesParams),
        on: swiper.on.bind(swiper),
        once: swiper.once.bind(swiper),
        off: swiper.off.bind(swiper),
        emit: swiper.emit.bind(swiper)
      });
    });

    // Extend defaults with modules params
    const swiperParams = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.w)({}, defaults, allModulesParams);

    // Extend defaults with passed params
    swiper.params = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.w)({}, swiperParams, extendedDefaults, params);
    swiper.originalParams = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.w)({}, swiper.params);
    swiper.passedParams = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.w)({}, params);

    // add event listeners
    if (swiper.params && swiper.params.on) {
      Object.keys(swiper.params.on).forEach(eventName => {
        swiper.on(eventName, swiper.params.on[eventName]);
      });
    }
    if (swiper.params && swiper.params.onAny) {
      swiper.onAny(swiper.params.onAny);
    }

    // Extend Swiper
    Object.assign(swiper, {
      enabled: swiper.params.enabled,
      el,
      // Classes
      classNames: [],
      // Slides
      slides: [],
      slidesGrid: [],
      snapGrid: [],
      slidesSizesGrid: [],
      // isDirection
      isHorizontal() {
        return swiper.params.direction === 'horizontal';
      },
      isVertical() {
        return swiper.params.direction === 'vertical';
      },
      // Indexes
      activeIndex: 0,
      realIndex: 0,
      //
      isBeginning: true,
      isEnd: false,
      // Props
      translate: 0,
      previousTranslate: 0,
      progress: 0,
      velocity: 0,
      animating: false,
      cssOverflowAdjustment() {
        // Returns 0 unless `translate` is > 2**23
        // Should be subtracted from css values to prevent overflow
        return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;
      },
      // Locks
      allowSlideNext: swiper.params.allowSlideNext,
      allowSlidePrev: swiper.params.allowSlidePrev,
      // Touch Events
      touchEventsData: {
        isTouched: undefined,
        isMoved: undefined,
        allowTouchCallbacks: undefined,
        touchStartTime: undefined,
        isScrolling: undefined,
        currentTranslate: undefined,
        startTranslate: undefined,
        allowThresholdMove: undefined,
        // Form elements to match
        focusableElements: swiper.params.focusableElements,
        // Last click time
        lastClickTime: 0,
        clickTimeout: undefined,
        // Velocities
        velocities: [],
        allowMomentumBounce: undefined,
        startMoving: undefined,
        pointerId: null,
        touchId: null
      },
      // Clicks
      allowClick: true,
      // Touches
      allowTouchMove: swiper.params.allowTouchMove,
      touches: {
        startX: 0,
        startY: 0,
        currentX: 0,
        currentY: 0,
        diff: 0
      },
      // Images
      imagesToLoad: [],
      imagesLoaded: 0
    });
    swiper.emit('_swiper');

    // Init
    if (swiper.params.init) {
      swiper.init();
    }

    // Return app instance
    // eslint-disable-next-line no-constructor-return
    return swiper;
  }
  getDirectionLabel(property) {
    if (this.isHorizontal()) {
      return property;
    }
    // prettier-ignore
    return {
      'width': 'height',
      'margin-top': 'margin-left',
      'margin-bottom ': 'margin-right',
      'margin-left': 'margin-top',
      'margin-right': 'margin-bottom',
      'padding-left': 'padding-top',
      'padding-right': 'padding-bottom',
      'marginRight': 'marginBottom'
    }[property];
  }
  getSlideIndex(slideEl) {
    const {
      slidesEl,
      params
    } = this;
    const slides = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(slidesEl, `.${params.slideClass}, swiper-slide`);
    const firstSlideIndex = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.h)(slides[0]);
    return (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.h)(slideEl) - firstSlideIndex;
  }
  getSlideIndexByData(index) {
    return this.getSlideIndex(this.slides.filter(slideEl => slideEl.getAttribute('data-swiper-slide-index') * 1 === index)[0]);
  }
  recalcSlides() {
    const swiper = this;
    const {
      slidesEl,
      params
    } = swiper;
    swiper.slides = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(slidesEl, `.${params.slideClass}, swiper-slide`);
  }
  enable() {
    const swiper = this;
    if (swiper.enabled) return;
    swiper.enabled = true;
    if (swiper.params.grabCursor) {
      swiper.setGrabCursor();
    }
    swiper.emit('enable');
  }
  disable() {
    const swiper = this;
    if (!swiper.enabled) return;
    swiper.enabled = false;
    if (swiper.params.grabCursor) {
      swiper.unsetGrabCursor();
    }
    swiper.emit('disable');
  }
  setProgress(progress, speed) {
    const swiper = this;
    progress = Math.min(Math.max(progress, 0), 1);
    const min = swiper.minTranslate();
    const max = swiper.maxTranslate();
    const current = (max - min) * progress + min;
    swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }
  emitContainerClasses() {
    const swiper = this;
    if (!swiper.params._emitClasses || !swiper.el) return;
    const cls = swiper.el.className.split(' ').filter(className => {
      return className.indexOf('swiper') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
    });
    swiper.emit('_containerClasses', cls.join(' '));
  }
  getSlideClasses(slideEl) {
    const swiper = this;
    if (swiper.destroyed) return '';
    return slideEl.className.split(' ').filter(className => {
      return className.indexOf('swiper-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0;
    }).join(' ');
  }
  emitSlidesClasses() {
    const swiper = this;
    if (!swiper.params._emitClasses || !swiper.el) return;
    const updates = [];
    swiper.slides.forEach(slideEl => {
      const classNames = swiper.getSlideClasses(slideEl);
      updates.push({
        slideEl,
        classNames
      });
      swiper.emit('_slideClass', slideEl, classNames);
    });
    swiper.emit('_slideClasses', updates);
  }
  slidesPerViewDynamic(view, exact) {
    if (view === void 0) {
      view = 'current';
    }
    if (exact === void 0) {
      exact = false;
    }
    const swiper = this;
    const {
      params,
      slides,
      slidesGrid,
      slidesSizesGrid,
      size: swiperSize,
      activeIndex
    } = swiper;
    let spv = 1;
    if (typeof params.slidesPerView === 'number') return params.slidesPerView;
    if (params.centeredSlides) {
      let slideSize = slides[activeIndex] ? Math.ceil(slides[activeIndex].swiperSlideSize) : 0;
      let breakLoop;
      for (let i = activeIndex + 1; i < slides.length; i += 1) {
        if (slides[i] && !breakLoop) {
          slideSize += Math.ceil(slides[i].swiperSlideSize);
          spv += 1;
          if (slideSize > swiperSize) breakLoop = true;
        }
      }
      for (let i = activeIndex - 1; i >= 0; i -= 1) {
        if (slides[i] && !breakLoop) {
          slideSize += slides[i].swiperSlideSize;
          spv += 1;
          if (slideSize > swiperSize) breakLoop = true;
        }
      }
    } else {
      // eslint-disable-next-line
      if (view === 'current') {
        for (let i = activeIndex + 1; i < slides.length; i += 1) {
          const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;
          if (slideInView) {
            spv += 1;
          }
        }
      } else {
        // previous
        for (let i = activeIndex - 1; i >= 0; i -= 1) {
          const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;
          if (slideInView) {
            spv += 1;
          }
        }
      }
    }
    return spv;
  }
  update() {
    const swiper = this;
    if (!swiper || swiper.destroyed) return;
    const {
      snapGrid,
      params
    } = swiper;
    // Breakpoints
    if (params.breakpoints) {
      swiper.setBreakpoint();
    }
    [...swiper.el.querySelectorAll('[loading="lazy"]')].forEach(imageEl => {
      if (imageEl.complete) {
        processLazyPreloader(swiper, imageEl);
      }
    });
    swiper.updateSize();
    swiper.updateSlides();
    swiper.updateProgress();
    swiper.updateSlidesClasses();
    function setTranslate() {
      const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
      const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
      swiper.setTranslate(newTranslate);
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
    let translated;
    if (params.freeMode && params.freeMode.enabled && !params.cssMode) {
      setTranslate();
      if (params.autoHeight) {
        swiper.updateAutoHeight();
      }
    } else {
      if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !params.centeredSlides) {
        const slides = swiper.virtual && params.virtual.enabled ? swiper.virtual.slides : swiper.slides;
        translated = swiper.slideTo(slides.length - 1, 0, false, true);
      } else {
        translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
      }
      if (!translated) {
        setTranslate();
      }
    }
    if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
      swiper.checkOverflow();
    }
    swiper.emit('update');
  }
  changeDirection(newDirection, needUpdate) {
    if (needUpdate === void 0) {
      needUpdate = true;
    }
    const swiper = this;
    const currentDirection = swiper.params.direction;
    if (!newDirection) {
      // eslint-disable-next-line
      newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
    }
    if (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {
      return swiper;
    }
    swiper.el.classList.remove(`${swiper.params.containerModifierClass}${currentDirection}`);
    swiper.el.classList.add(`${swiper.params.containerModifierClass}${newDirection}`);
    swiper.emitContainerClasses();
    swiper.params.direction = newDirection;
    swiper.slides.forEach(slideEl => {
      if (newDirection === 'vertical') {
        slideEl.style.width = '';
      } else {
        slideEl.style.height = '';
      }
    });
    swiper.emit('changeDirection');
    if (needUpdate) swiper.update();
    return swiper;
  }
  changeLanguageDirection(direction) {
    const swiper = this;
    if (swiper.rtl && direction === 'rtl' || !swiper.rtl && direction === 'ltr') return;
    swiper.rtl = direction === 'rtl';
    swiper.rtlTranslate = swiper.params.direction === 'horizontal' && swiper.rtl;
    if (swiper.rtl) {
      swiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`);
      swiper.el.dir = 'rtl';
    } else {
      swiper.el.classList.remove(`${swiper.params.containerModifierClass}rtl`);
      swiper.el.dir = 'ltr';
    }
    swiper.update();
  }
  mount(element) {
    const swiper = this;
    if (swiper.mounted) return true;

    // Find el
    let el = element || swiper.params.el;
    if (typeof el === 'string') {
      el = document.querySelector(el);
    }
    if (!el) {
      return false;
    }
    el.swiper = swiper;
    if (el.parentNode && el.parentNode.host && el.parentNode.host.nodeName === swiper.params.swiperElementNodeName.toUpperCase()) {
      swiper.isElement = true;
    }
    const getWrapperSelector = () => {
      return `.${(swiper.params.wrapperClass || '').trim().split(' ').join('.')}`;
    };
    const getWrapper = () => {
      if (el && el.shadowRoot && el.shadowRoot.querySelector) {
        const res = el.shadowRoot.querySelector(getWrapperSelector());
        // Children needs to return slot items
        return res;
      }
      return (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(el, getWrapperSelector())[0];
    };
    // Find Wrapper
    let wrapperEl = getWrapper();
    if (!wrapperEl && swiper.params.createElements) {
      wrapperEl = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.c)('div', swiper.params.wrapperClass);
      el.append(wrapperEl);
      (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(el, `.${swiper.params.slideClass}`).forEach(slideEl => {
        wrapperEl.append(slideEl);
      });
    }
    Object.assign(swiper, {
      el,
      wrapperEl,
      slidesEl: swiper.isElement && !el.parentNode.host.slideSlots ? el.parentNode.host : wrapperEl,
      hostEl: swiper.isElement ? el.parentNode.host : el,
      mounted: true,
      // RTL
      rtl: el.dir.toLowerCase() === 'rtl' || (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.p)(el, 'direction') === 'rtl',
      rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.p)(el, 'direction') === 'rtl'),
      wrongRTL: (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.p)(wrapperEl, 'display') === '-webkit-box'
    });
    return true;
  }
  init(el) {
    const swiper = this;
    if (swiper.initialized) return swiper;
    const mounted = swiper.mount(el);
    if (mounted === false) return swiper;
    swiper.emit('beforeInit');

    // Set breakpoint
    if (swiper.params.breakpoints) {
      swiper.setBreakpoint();
    }

    // Add Classes
    swiper.addClasses();

    // Update size
    swiper.updateSize();

    // Update slides
    swiper.updateSlides();
    if (swiper.params.watchOverflow) {
      swiper.checkOverflow();
    }

    // Set Grab Cursor
    if (swiper.params.grabCursor && swiper.enabled) {
      swiper.setGrabCursor();
    }

    // Slide To Initial Slide
    if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {
      swiper.slideTo(swiper.params.initialSlide + swiper.virtual.slidesBefore, 0, swiper.params.runCallbacksOnInit, false, true);
    } else {
      swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
    }

    // Create loop
    if (swiper.params.loop) {
      swiper.loopCreate();
    }

    // Attach events
    swiper.attachEvents();
    const lazyElements = [...swiper.el.querySelectorAll('[loading="lazy"]')];
    if (swiper.isElement) {
      lazyElements.push(...swiper.hostEl.querySelectorAll('[loading="lazy"]'));
    }
    lazyElements.forEach(imageEl => {
      if (imageEl.complete) {
        processLazyPreloader(swiper, imageEl);
      } else {
        imageEl.addEventListener('load', e => {
          processLazyPreloader(swiper, e.target);
        });
      }
    });
    preload(swiper);

    // Init Flag
    swiper.initialized = true;
    preload(swiper);

    // Emit
    swiper.emit('init');
    swiper.emit('afterInit');
    return swiper;
  }
  destroy(deleteInstance, cleanStyles) {
    if (deleteInstance === void 0) {
      deleteInstance = true;
    }
    if (cleanStyles === void 0) {
      cleanStyles = true;
    }
    const swiper = this;
    const {
      params,
      el,
      wrapperEl,
      slides
    } = swiper;
    if (typeof swiper.params === 'undefined' || swiper.destroyed) {
      return null;
    }
    swiper.emit('beforeDestroy');

    // Init Flag
    swiper.initialized = false;

    // Detach events
    swiper.detachEvents();

    // Destroy loop
    if (params.loop) {
      swiper.loopDestroy();
    }

    // Cleanup styles
    if (cleanStyles) {
      swiper.removeClasses();
      if (el && typeof el !== 'string') {
        el.removeAttribute('style');
      }
      if (wrapperEl) {
        wrapperEl.removeAttribute('style');
      }
      if (slides && slides.length) {
        slides.forEach(slideEl => {
          slideEl.classList.remove(params.slideVisibleClass, params.slideFullyVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);
          slideEl.removeAttribute('style');
          slideEl.removeAttribute('data-swiper-slide-index');
        });
      }
    }
    swiper.emit('destroy');

    // Detach emitter events
    Object.keys(swiper.eventsListeners).forEach(eventName => {
      swiper.off(eventName);
    });
    if (deleteInstance !== false) {
      if (swiper.el && typeof swiper.el !== 'string') {
        swiper.el.swiper = null;
      }
      (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.x)(swiper);
    }
    swiper.destroyed = true;
    return null;
  }
  static extendDefaults(newDefaults) {
    (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.w)(extendedDefaults, newDefaults);
  }
  static get extendedDefaults() {
    return extendedDefaults;
  }
  static get defaults() {
    return defaults;
  }
  static installModule(mod) {
    if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];
    const modules = Swiper.prototype.__modules__;
    if (typeof mod === 'function' && modules.indexOf(mod) < 0) {
      modules.push(mod);
    }
  }
  static use(module) {
    if (Array.isArray(module)) {
      module.forEach(m => Swiper.installModule(m));
      return Swiper;
    }
    Swiper.installModule(module);
    return Swiper;
  }
}
Object.keys(prototypes).forEach(prototypeGroup => {
  Object.keys(prototypes[prototypeGroup]).forEach(protoMethod => {
    Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
  });
});
Swiper.use([Resize, Observer]);




/***/ }),

/***/ "./node_modules/swiper/shared/utils.mjs":
/*!**********************************************!*\
  !*** ./node_modules/swiper/shared/utils.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ elementParents),
/* harmony export */   b: () => (/* binding */ elementOffset),
/* harmony export */   c: () => (/* binding */ createElement),
/* harmony export */   d: () => (/* binding */ now),
/* harmony export */   e: () => (/* binding */ elementChildren),
/* harmony export */   f: () => (/* binding */ elementOuterSize),
/* harmony export */   g: () => (/* binding */ getSlideTransformEl),
/* harmony export */   h: () => (/* binding */ elementIndex),
/* harmony export */   i: () => (/* binding */ classesToTokens),
/* harmony export */   j: () => (/* binding */ getTranslate),
/* harmony export */   k: () => (/* binding */ elementTransitionEnd),
/* harmony export */   l: () => (/* binding */ isObject),
/* harmony export */   m: () => (/* binding */ makeElementsArray),
/* harmony export */   n: () => (/* binding */ nextTick),
/* harmony export */   o: () => (/* binding */ getRotateFix),
/* harmony export */   p: () => (/* binding */ elementStyle),
/* harmony export */   q: () => (/* binding */ elementNextAll),
/* harmony export */   r: () => (/* binding */ elementPrevAll),
/* harmony export */   s: () => (/* binding */ setCSSProperty),
/* harmony export */   t: () => (/* binding */ animateCSSModeScroll),
/* harmony export */   u: () => (/* binding */ showWarning),
/* harmony export */   v: () => (/* binding */ elementIsChildOf),
/* harmony export */   w: () => (/* binding */ extend),
/* harmony export */   x: () => (/* binding */ deleteProps)
/* harmony export */ });
/* harmony import */ var _ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ssr-window.esm.mjs */ "./node_modules/swiper/shared/ssr-window.esm.mjs");


function classesToTokens(classes) {
  if (classes === void 0) {
    classes = '';
  }
  return classes.trim().split(' ').filter(c => !!c.trim());
}

function deleteProps(obj) {
  const object = obj;
  Object.keys(object).forEach(key => {
    try {
      object[key] = null;
    } catch (e) {
      // no getter for object
    }
    try {
      delete object[key];
    } catch (e) {
      // something got wrong
    }
  });
}
function nextTick(callback, delay) {
  if (delay === void 0) {
    delay = 0;
  }
  return setTimeout(callback, delay);
}
function now() {
  return Date.now();
}
function getComputedStyle(el) {
  const window = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();
  let style;
  if (window.getComputedStyle) {
    style = window.getComputedStyle(el, null);
  }
  if (!style && el.currentStyle) {
    style = el.currentStyle;
  }
  if (!style) {
    style = el.style;
  }
  return style;
}
function getTranslate(el, axis) {
  if (axis === void 0) {
    axis = 'x';
  }
  const window = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();
  let matrix;
  let curTransform;
  let transformMatrix;
  const curStyle = getComputedStyle(el);
  if (window.WebKitCSSMatrix) {
    curTransform = curStyle.transform || curStyle.webkitTransform;
    if (curTransform.split(',').length > 6) {
      curTransform = curTransform.split(', ').map(a => a.replace(',', '.')).join(', ');
    }
    // Some old versions of Webkit choke when 'none' is passed; pass
    // empty string instead in this case
    transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
  } else {
    transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
    matrix = transformMatrix.toString().split(',');
  }
  if (axis === 'x') {
    // Latest Chrome and webkits Fix
    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41;
    // Crazy IE10 Matrix
    else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);
    // Normal Browsers
    else curTransform = parseFloat(matrix[4]);
  }
  if (axis === 'y') {
    // Latest Chrome and webkits Fix
    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42;
    // Crazy IE10 Matrix
    else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);
    // Normal Browsers
    else curTransform = parseFloat(matrix[5]);
  }
  return curTransform || 0;
}
function isObject(o) {
  return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';
}
function isNode(node) {
  // eslint-disable-next-line
  if (typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined') {
    return node instanceof HTMLElement;
  }
  return node && (node.nodeType === 1 || node.nodeType === 11);
}
function extend() {
  const to = Object(arguments.length <= 0 ? undefined : arguments[0]);
  const noExtend = ['__proto__', 'constructor', 'prototype'];
  for (let i = 1; i < arguments.length; i += 1) {
    const nextSource = i < 0 || arguments.length <= i ? undefined : arguments[i];
    if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {
      const keysArray = Object.keys(Object(nextSource)).filter(key => noExtend.indexOf(key) < 0);
      for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
        const nextKey = keysArray[nextIndex];
        const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
        if (desc !== undefined && desc.enumerable) {
          if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
            if (nextSource[nextKey].__swiper__) {
              to[nextKey] = nextSource[nextKey];
            } else {
              extend(to[nextKey], nextSource[nextKey]);
            }
          } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
            to[nextKey] = {};
            if (nextSource[nextKey].__swiper__) {
              to[nextKey] = nextSource[nextKey];
            } else {
              extend(to[nextKey], nextSource[nextKey]);
            }
          } else {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }
  }
  return to;
}
function setCSSProperty(el, varName, varValue) {
  el.style.setProperty(varName, varValue);
}
function animateCSSModeScroll(_ref) {
  let {
    swiper,
    targetPosition,
    side
  } = _ref;
  const window = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();
  const startPosition = -swiper.translate;
  let startTime = null;
  let time;
  const duration = swiper.params.speed;
  swiper.wrapperEl.style.scrollSnapType = 'none';
  window.cancelAnimationFrame(swiper.cssModeFrameID);
  const dir = targetPosition > startPosition ? 'next' : 'prev';
  const isOutOfBound = (current, target) => {
    return dir === 'next' && current >= target || dir === 'prev' && current <= target;
  };
  const animate = () => {
    time = new Date().getTime();
    if (startTime === null) {
      startTime = time;
    }
    const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
    const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
    let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
    if (isOutOfBound(currentPosition, targetPosition)) {
      currentPosition = targetPosition;
    }
    swiper.wrapperEl.scrollTo({
      [side]: currentPosition
    });
    if (isOutOfBound(currentPosition, targetPosition)) {
      swiper.wrapperEl.style.overflow = 'hidden';
      swiper.wrapperEl.style.scrollSnapType = '';
      setTimeout(() => {
        swiper.wrapperEl.style.overflow = '';
        swiper.wrapperEl.scrollTo({
          [side]: currentPosition
        });
      });
      window.cancelAnimationFrame(swiper.cssModeFrameID);
      return;
    }
    swiper.cssModeFrameID = window.requestAnimationFrame(animate);
  };
  animate();
}
function getSlideTransformEl(slideEl) {
  return slideEl.querySelector('.swiper-slide-transform') || slideEl.shadowRoot && slideEl.shadowRoot.querySelector('.swiper-slide-transform') || slideEl;
}
function elementChildren(element, selector) {
  if (selector === void 0) {
    selector = '';
  }
  const children = [...element.children];
  if (element instanceof HTMLSlotElement) {
    children.push(...element.assignedElements());
  }
  if (!selector) {
    return children;
  }
  return children.filter(el => el.matches(selector));
}
function elementIsChildOf(el, parent) {
  const isChild = parent.contains(el);
  if (!isChild && parent instanceof HTMLSlotElement) {
    const children = [...parent.assignedElements()];
    return children.includes(el);
  }
  return isChild;
}
function showWarning(text) {
  try {
    console.warn(text);
    return;
  } catch (err) {
    // err
  }
}
function createElement(tag, classes) {
  if (classes === void 0) {
    classes = [];
  }
  const el = document.createElement(tag);
  el.classList.add(...(Array.isArray(classes) ? classes : classesToTokens(classes)));
  return el;
}
function elementOffset(el) {
  const window = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();
  const document = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();
  const box = el.getBoundingClientRect();
  const body = document.body;
  const clientTop = el.clientTop || body.clientTop || 0;
  const clientLeft = el.clientLeft || body.clientLeft || 0;
  const scrollTop = el === window ? window.scrollY : el.scrollTop;
  const scrollLeft = el === window ? window.scrollX : el.scrollLeft;
  return {
    top: box.top + scrollTop - clientTop,
    left: box.left + scrollLeft - clientLeft
  };
}
function elementPrevAll(el, selector) {
  const prevEls = [];
  while (el.previousElementSibling) {
    const prev = el.previousElementSibling; // eslint-disable-line
    if (selector) {
      if (prev.matches(selector)) prevEls.push(prev);
    } else prevEls.push(prev);
    el = prev;
  }
  return prevEls;
}
function elementNextAll(el, selector) {
  const nextEls = [];
  while (el.nextElementSibling) {
    const next = el.nextElementSibling; // eslint-disable-line
    if (selector) {
      if (next.matches(selector)) nextEls.push(next);
    } else nextEls.push(next);
    el = next;
  }
  return nextEls;
}
function elementStyle(el, prop) {
  const window = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();
  return window.getComputedStyle(el, null).getPropertyValue(prop);
}
function elementIndex(el) {
  let child = el;
  let i;
  if (child) {
    i = 0;
    // eslint-disable-next-line
    while ((child = child.previousSibling) !== null) {
      if (child.nodeType === 1) i += 1;
    }
    return i;
  }
  return undefined;
}
function elementParents(el, selector) {
  const parents = []; // eslint-disable-line
  let parent = el.parentElement; // eslint-disable-line
  while (parent) {
    if (selector) {
      if (parent.matches(selector)) parents.push(parent);
    } else {
      parents.push(parent);
    }
    parent = parent.parentElement;
  }
  return parents;
}
function elementTransitionEnd(el, callback) {
  function fireCallBack(e) {
    if (e.target !== el) return;
    callback.call(el, e);
    el.removeEventListener('transitionend', fireCallBack);
  }
  if (callback) {
    el.addEventListener('transitionend', fireCallBack);
  }
}
function elementOuterSize(el, size, includeMargins) {
  const window = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();
  if (includeMargins) {
    return el[size === 'width' ? 'offsetWidth' : 'offsetHeight'] + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === 'width' ? 'margin-right' : 'margin-top')) + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === 'width' ? 'margin-left' : 'margin-bottom'));
  }
  return el.offsetWidth;
}
function makeElementsArray(el) {
  return (Array.isArray(el) ? el : [el]).filter(e => !!e);
}
function getRotateFix(swiper) {
  return v => {
    if (Math.abs(v) > 0 && swiper.browser && swiper.browser.need3dFix && Math.abs(v) % 90 === 0) {
      return v + 0.001;
    }
    return v;
  };
}




/***/ }),

/***/ "./node_modules/swiper/swiper.mjs":
/*!****************************************!*\
  !*** ./node_modules/swiper/swiper.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Swiper: () => (/* reexport safe */ _shared_swiper_core_mjs__WEBPACK_IMPORTED_MODULE_0__.S),
/* harmony export */   "default": () => (/* reexport safe */ _shared_swiper_core_mjs__WEBPACK_IMPORTED_MODULE_0__.S)
/* harmony export */ });
/* harmony import */ var _shared_swiper_core_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shared/swiper-core.mjs */ "./node_modules/swiper/shared/swiper-core.mjs");
/**
 * Swiper 11.1.15
 * Most modern mobile touch slider and framework with hardware accelerated transitions
 * https://swiperjs.com
 *
 * Copyright 2014-2024 Vladimir Kharlampidi
 *
 * Released under the MIT License
 *
 * Released on: November 18, 2024
 */




/***/ }),

/***/ "./src/js/project/map/_styles.json":
/*!*****************************************!*\
  !*** ./src/js/project/map/_styles.json ***!
  \*****************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('[{"tags":"country","elements":"geometry.fill","stylers":[{"color":"#8c8c8c"},{"zoom":0,"opacity":0.8},{"zoom":1,"opacity":0.8},{"zoom":2,"opacity":0.8},{"zoom":3,"opacity":0.8},{"zoom":4,"opacity":0.8},{"zoom":5,"opacity":1},{"zoom":6,"opacity":1},{"zoom":7,"opacity":1},{"zoom":8,"opacity":1},{"zoom":9,"opacity":1},{"zoom":10,"opacity":1},{"zoom":11,"opacity":1},{"zoom":12,"opacity":1},{"zoom":13,"opacity":1},{"zoom":14,"opacity":1},{"zoom":15,"opacity":1},{"zoom":16,"opacity":1},{"zoom":17,"opacity":1},{"zoom":18,"opacity":1},{"zoom":19,"opacity":1},{"zoom":20,"opacity":1},{"zoom":21,"opacity":1}]},{"tags":"country","elements":"geometry.outline","stylers":[{"color":"#dedede"},{"zoom":0,"opacity":0.15},{"zoom":1,"opacity":0.15},{"zoom":2,"opacity":0.15},{"zoom":3,"opacity":0.15},{"zoom":4,"opacity":0.15},{"zoom":5,"opacity":0.15},{"zoom":6,"opacity":0.25},{"zoom":7,"opacity":0.5},{"zoom":8,"opacity":0.47},{"zoom":9,"opacity":0.44},{"zoom":10,"opacity":0.41},{"zoom":11,"opacity":0.38},{"zoom":12,"opacity":0.35},{"zoom":13,"opacity":0.33},{"zoom":14,"opacity":0.3},{"zoom":15,"opacity":0.28},{"zoom":16,"opacity":0.25},{"zoom":17,"opacity":0.25},{"zoom":18,"opacity":0.25},{"zoom":19,"opacity":0.25},{"zoom":20,"opacity":0.25},{"zoom":21,"opacity":0.25}]},{"tags":"region","elements":"geometry.fill","stylers":[{"zoom":0,"color":"#a6a6a6","opacity":0.5},{"zoom":1,"color":"#a6a6a6","opacity":0.5},{"zoom":2,"color":"#a6a6a6","opacity":0.5},{"zoom":3,"color":"#a6a6a6","opacity":0.5},{"zoom":4,"color":"#a6a6a6","opacity":0.5},{"zoom":5,"color":"#a6a6a6","opacity":0.5},{"zoom":6,"color":"#a6a6a6","opacity":1},{"zoom":7,"color":"#a6a6a6","opacity":1},{"zoom":8,"color":"#8c8c8c","opacity":1},{"zoom":9,"color":"#8c8c8c","opacity":1},{"zoom":10,"color":"#8c8c8c","opacity":1},{"zoom":11,"color":"#8c8c8c","opacity":1},{"zoom":12,"color":"#8c8c8c","opacity":1},{"zoom":13,"color":"#8c8c8c","opacity":1},{"zoom":14,"color":"#8c8c8c","opacity":1},{"zoom":15,"color":"#8c8c8c","opacity":1},{"zoom":16,"color":"#8c8c8c","opacity":1},{"zoom":17,"color":"#8c8c8c","opacity":1},{"zoom":18,"color":"#8c8c8c","opacity":1},{"zoom":19,"color":"#8c8c8c","opacity":1},{"zoom":20,"color":"#8c8c8c","opacity":1},{"zoom":21,"color":"#8c8c8c","opacity":1}]},{"tags":"region","elements":"geometry.outline","stylers":[{"color":"#dedede"},{"zoom":0,"opacity":0.15},{"zoom":1,"opacity":0.15},{"zoom":2,"opacity":0.15},{"zoom":3,"opacity":0.15},{"zoom":4,"opacity":0.15},{"zoom":5,"opacity":0.15},{"zoom":6,"opacity":0.25},{"zoom":7,"opacity":0.5},{"zoom":8,"opacity":0.47},{"zoom":9,"opacity":0.44},{"zoom":10,"opacity":0.41},{"zoom":11,"opacity":0.38},{"zoom":12,"opacity":0.35},{"zoom":13,"opacity":0.33},{"zoom":14,"opacity":0.3},{"zoom":15,"opacity":0.28},{"zoom":16,"opacity":0.25},{"zoom":17,"opacity":0.25},{"zoom":18,"opacity":0.25},{"zoom":19,"opacity":0.25},{"zoom":20,"opacity":0.25},{"zoom":21,"opacity":0.25}]},{"tags":{"any":"admin","none":["country","region","locality","district","address"]},"elements":"geometry.fill","stylers":[{"color":"#8c8c8c"},{"zoom":0,"opacity":0.5},{"zoom":1,"opacity":0.5},{"zoom":2,"opacity":0.5},{"zoom":3,"opacity":0.5},{"zoom":4,"opacity":0.5},{"zoom":5,"opacity":0.5},{"zoom":6,"opacity":1},{"zoom":7,"opacity":1},{"zoom":8,"opacity":1},{"zoom":9,"opacity":1},{"zoom":10,"opacity":1},{"zoom":11,"opacity":1},{"zoom":12,"opacity":1},{"zoom":13,"opacity":1},{"zoom":14,"opacity":1},{"zoom":15,"opacity":1},{"zoom":16,"opacity":1},{"zoom":17,"opacity":1},{"zoom":18,"opacity":1},{"zoom":19,"opacity":1},{"zoom":20,"opacity":1},{"zoom":21,"opacity":1}]},{"tags":{"any":"admin","none":["country","region","locality","district","address"]},"elements":"geometry.outline","stylers":[{"color":"#dedede"},{"zoom":0,"opacity":0.15},{"zoom":1,"opacity":0.15},{"zoom":2,"opacity":0.15},{"zoom":3,"opacity":0.15},{"zoom":4,"opacity":0.15},{"zoom":5,"opacity":0.15},{"zoom":6,"opacity":0.25},{"zoom":7,"opacity":0.5},{"zoom":8,"opacity":0.47},{"zoom":9,"opacity":0.44},{"zoom":10,"opacity":0.41},{"zoom":11,"opacity":0.38},{"zoom":12,"opacity":0.35},{"zoom":13,"opacity":0.33},{"zoom":14,"opacity":0.3},{"zoom":15,"opacity":0.28},{"zoom":16,"opacity":0.25},{"zoom":17,"opacity":0.25},{"zoom":18,"opacity":0.25},{"zoom":19,"opacity":0.25},{"zoom":20,"opacity":0.25},{"zoom":21,"opacity":0.25}]},{"tags":{"any":"landcover","none":"vegetation"},"stylers":[{"hue":"#c7cfd6"}]},{"tags":"vegetation","elements":"geometry","stylers":[{"zoom":0,"color":"#aab6c0","opacity":0.1},{"zoom":1,"color":"#aab6c0","opacity":0.1},{"zoom":2,"color":"#aab6c0","opacity":0.1},{"zoom":3,"color":"#aab6c0","opacity":0.1},{"zoom":4,"color":"#aab6c0","opacity":0.1},{"zoom":5,"color":"#aab6c0","opacity":0.1},{"zoom":6,"color":"#aab6c0","opacity":0.2},{"zoom":7,"color":"#c7cfd6","opacity":0.3},{"zoom":8,"color":"#c7cfd6","opacity":0.4},{"zoom":9,"color":"#c7cfd6","opacity":0.6},{"zoom":10,"color":"#c7cfd6","opacity":0.8},{"zoom":11,"color":"#c7cfd6","opacity":1},{"zoom":12,"color":"#c7cfd6","opacity":1},{"zoom":13,"color":"#c7cfd6","opacity":1},{"zoom":14,"color":"#cdd4da","opacity":1},{"zoom":15,"color":"#d3d9df","opacity":1},{"zoom":16,"color":"#d3d9df","opacity":1},{"zoom":17,"color":"#d3d9df","opacity":1},{"zoom":18,"color":"#d3d9df","opacity":1},{"zoom":19,"color":"#d3d9df","opacity":1},{"zoom":20,"color":"#d3d9df","opacity":1},{"zoom":21,"color":"#d3d9df","opacity":1}]},{"tags":"park","elements":"geometry","stylers":[{"zoom":0,"color":"#c7cfd6","opacity":0.1},{"zoom":1,"color":"#c7cfd6","opacity":0.1},{"zoom":2,"color":"#c7cfd6","opacity":0.1},{"zoom":3,"color":"#c7cfd6","opacity":0.1},{"zoom":4,"color":"#c7cfd6","opacity":0.1},{"zoom":5,"color":"#c7cfd6","opacity":0.1},{"zoom":6,"color":"#c7cfd6","opacity":0.2},{"zoom":7,"color":"#c7cfd6","opacity":0.3},{"zoom":8,"color":"#c7cfd6","opacity":0.4},{"zoom":9,"color":"#c7cfd6","opacity":0.6},{"zoom":10,"color":"#c7cfd6","opacity":0.8},{"zoom":11,"color":"#c7cfd6","opacity":1},{"zoom":12,"color":"#c7cfd6","opacity":1},{"zoom":13,"color":"#c7cfd6","opacity":1},{"zoom":14,"color":"#cdd4da","opacity":1},{"zoom":15,"color":"#d3d9df","opacity":1},{"zoom":16,"color":"#d3d9df","opacity":0.9},{"zoom":17,"color":"#d3d9df","opacity":0.8},{"zoom":18,"color":"#d3d9df","opacity":0.7},{"zoom":19,"color":"#d3d9df","opacity":0.7},{"zoom":20,"color":"#d3d9df","opacity":0.7},{"zoom":21,"color":"#d3d9df","opacity":0.7}]},{"tags":"national_park","elements":"geometry","stylers":[{"zoom":0,"color":"#c7cfd6","opacity":0.1},{"zoom":1,"color":"#c7cfd6","opacity":0.1},{"zoom":2,"color":"#c7cfd6","opacity":0.1},{"zoom":3,"color":"#c7cfd6","opacity":0.1},{"zoom":4,"color":"#c7cfd6","opacity":0.1},{"zoom":5,"color":"#c7cfd6","opacity":0.1},{"zoom":6,"color":"#c7cfd6","opacity":0.2},{"zoom":7,"color":"#c7cfd6","opacity":0.3},{"zoom":8,"color":"#c7cfd6","opacity":0.4},{"zoom":9,"color":"#c7cfd6","opacity":0.6},{"zoom":10,"color":"#c7cfd6","opacity":0.8},{"zoom":11,"color":"#c7cfd6","opacity":1},{"zoom":12,"color":"#c7cfd6","opacity":1},{"zoom":13,"color":"#c7cfd6","opacity":1},{"zoom":14,"color":"#cdd4da","opacity":1},{"zoom":15,"color":"#d3d9df","opacity":1},{"zoom":16,"color":"#d3d9df","opacity":0.7},{"zoom":17,"color":"#d3d9df","opacity":0.7},{"zoom":18,"color":"#d3d9df","opacity":0.7},{"zoom":19,"color":"#d3d9df","opacity":0.7},{"zoom":20,"color":"#d3d9df","opacity":0.7},{"zoom":21,"color":"#d3d9df","opacity":0.7}]},{"tags":"cemetery","elements":"geometry","stylers":[{"zoom":0,"color":"#c7cfd6"},{"zoom":1,"color":"#c7cfd6"},{"zoom":2,"color":"#c7cfd6"},{"zoom":3,"color":"#c7cfd6"},{"zoom":4,"color":"#c7cfd6"},{"zoom":5,"color":"#c7cfd6"},{"zoom":6,"color":"#c7cfd6"},{"zoom":7,"color":"#c7cfd6"},{"zoom":8,"color":"#c7cfd6"},{"zoom":9,"color":"#c7cfd6"},{"zoom":10,"color":"#c7cfd6"},{"zoom":11,"color":"#c7cfd6"},{"zoom":12,"color":"#c7cfd6"},{"zoom":13,"color":"#c7cfd6"},{"zoom":14,"color":"#cdd4da"},{"zoom":15,"color":"#d3d9df"},{"zoom":16,"color":"#d3d9df"},{"zoom":17,"color":"#d3d9df"},{"zoom":18,"color":"#d3d9df"},{"zoom":19,"color":"#d3d9df"},{"zoom":20,"color":"#d3d9df"},{"zoom":21,"color":"#d3d9df"}]},{"tags":"sports_ground","elements":"geometry","stylers":[{"zoom":0,"color":"#b8c2cb","opacity":0},{"zoom":1,"color":"#b8c2cb","opacity":0},{"zoom":2,"color":"#b8c2cb","opacity":0},{"zoom":3,"color":"#b8c2cb","opacity":0},{"zoom":4,"color":"#b8c2cb","opacity":0},{"zoom":5,"color":"#b8c2cb","opacity":0},{"zoom":6,"color":"#b8c2cb","opacity":0},{"zoom":7,"color":"#b8c2cb","opacity":0},{"zoom":8,"color":"#b8c2cb","opacity":0},{"zoom":9,"color":"#b8c2cb","opacity":0},{"zoom":10,"color":"#b8c2cb","opacity":0},{"zoom":11,"color":"#b8c2cb","opacity":0},{"zoom":12,"color":"#b8c2cb","opacity":0},{"zoom":13,"color":"#b8c2cb","opacity":0},{"zoom":14,"color":"#bec7cf","opacity":0},{"zoom":15,"color":"#c4ccd4","opacity":0.5},{"zoom":16,"color":"#c5cdd5","opacity":1},{"zoom":17,"color":"#c6ced5","opacity":1},{"zoom":18,"color":"#c7ced6","opacity":1},{"zoom":19,"color":"#c8cfd7","opacity":1},{"zoom":20,"color":"#c9d0d7","opacity":1},{"zoom":21,"color":"#cad1d8","opacity":1}]},{"tags":"terrain","elements":"geometry","stylers":[{"hue":"#e1e3e5"},{"zoom":0,"opacity":0.3},{"zoom":1,"opacity":0.3},{"zoom":2,"opacity":0.3},{"zoom":3,"opacity":0.3},{"zoom":4,"opacity":0.3},{"zoom":5,"opacity":0.35},{"zoom":6,"opacity":0.4},{"zoom":7,"opacity":0.6},{"zoom":8,"opacity":0.8},{"zoom":9,"opacity":0.9},{"zoom":10,"opacity":1},{"zoom":11,"opacity":1},{"zoom":12,"opacity":1},{"zoom":13,"opacity":1},{"zoom":14,"opacity":1},{"zoom":15,"opacity":1},{"zoom":16,"opacity":1},{"zoom":17,"opacity":1},{"zoom":18,"opacity":1},{"zoom":19,"opacity":1},{"zoom":20,"opacity":1},{"zoom":21,"opacity":1}]},{"tags":"geographic_line","elements":"geometry","stylers":[{"color":"#747d86"}]},{"tags":"land","elements":"geometry","stylers":[{"zoom":0,"color":"#e1e3e4"},{"zoom":1,"color":"#e1e3e4"},{"zoom":2,"color":"#e1e3e4"},{"zoom":3,"color":"#e1e3e4"},{"zoom":4,"color":"#e1e3e4"},{"zoom":5,"color":"#e4e5e6"},{"zoom":6,"color":"#e6e8e9"},{"zoom":7,"color":"#e9eaeb"},{"zoom":8,"color":"#ecedee"},{"zoom":9,"color":"#ecedee"},{"zoom":10,"color":"#ecedee"},{"zoom":11,"color":"#ecedee"},{"zoom":12,"color":"#ecedee"},{"zoom":13,"color":"#ecedee"},{"zoom":14,"color":"#eeeff0"},{"zoom":15,"color":"#f1f2f3"},{"zoom":16,"color":"#f1f2f3"},{"zoom":17,"color":"#f2f3f4"},{"zoom":18,"color":"#f2f3f4"},{"zoom":19,"color":"#f3f4f4"},{"zoom":20,"color":"#f3f4f5"},{"zoom":21,"color":"#f4f5f5"}]},{"tags":"residential","elements":"geometry","stylers":[{"zoom":0,"color":"#e1e3e5","opacity":0.5},{"zoom":1,"color":"#e1e3e5","opacity":0.5},{"zoom":2,"color":"#e1e3e5","opacity":0.5},{"zoom":3,"color":"#e1e3e5","opacity":0.5},{"zoom":4,"color":"#e1e3e5","opacity":0.5},{"zoom":5,"color":"#e1e3e5","opacity":0.5},{"zoom":6,"color":"#e1e3e5","opacity":0.5},{"zoom":7,"color":"#e1e3e5","opacity":0.5},{"zoom":8,"color":"#e1e3e5","opacity":0.5},{"zoom":9,"color":"#e1e3e5","opacity":0.5},{"zoom":10,"color":"#e1e3e5","opacity":0.5},{"zoom":11,"color":"#e1e3e5","opacity":0.5},{"zoom":12,"color":"#e1e3e5","opacity":0.5},{"zoom":13,"color":"#e1e3e5","opacity":1},{"zoom":14,"color":"#e6e8e9","opacity":1},{"zoom":15,"color":"#ecedee","opacity":1},{"zoom":16,"color":"#edeeef","opacity":1},{"zoom":17,"color":"#eeeff0","opacity":1},{"zoom":18,"color":"#eeeff0","opacity":1},{"zoom":19,"color":"#eff0f1","opacity":1},{"zoom":20,"color":"#f0f1f2","opacity":1},{"zoom":21,"color":"#f1f2f3","opacity":1}]},{"tags":"locality","elements":"geometry","stylers":[{"zoom":0,"color":"#e1e3e5"},{"zoom":1,"color":"#e1e3e5"},{"zoom":2,"color":"#e1e3e5"},{"zoom":3,"color":"#e1e3e5"},{"zoom":4,"color":"#e1e3e5"},{"zoom":5,"color":"#e1e3e5"},{"zoom":6,"color":"#e1e3e5"},{"zoom":7,"color":"#e1e3e5"},{"zoom":8,"color":"#e1e3e5"},{"zoom":9,"color":"#e1e3e5"},{"zoom":10,"color":"#e1e3e5"},{"zoom":11,"color":"#e1e3e5"},{"zoom":12,"color":"#e1e3e5"},{"zoom":13,"color":"#e1e3e5"},{"zoom":14,"color":"#e6e8e9"},{"zoom":15,"color":"#ecedee"},{"zoom":16,"color":"#edeeef"},{"zoom":17,"color":"#eeeff0"},{"zoom":18,"color":"#eeeff0"},{"zoom":19,"color":"#eff0f1"},{"zoom":20,"color":"#f0f1f2"},{"zoom":21,"color":"#f1f2f3"}]},{"tags":{"any":"structure","none":["building","fence"]},"elements":"geometry","stylers":[{"opacity":0.9},{"zoom":0,"color":"#e1e3e5"},{"zoom":1,"color":"#e1e3e5"},{"zoom":2,"color":"#e1e3e5"},{"zoom":3,"color":"#e1e3e5"},{"zoom":4,"color":"#e1e3e5"},{"zoom":5,"color":"#e1e3e5"},{"zoom":6,"color":"#e1e3e5"},{"zoom":7,"color":"#e1e3e5"},{"zoom":8,"color":"#e1e3e5"},{"zoom":9,"color":"#e1e3e5"},{"zoom":10,"color":"#e1e3e5"},{"zoom":11,"color":"#e1e3e5"},{"zoom":12,"color":"#e1e3e5"},{"zoom":13,"color":"#e1e3e5"},{"zoom":14,"color":"#e6e8e9"},{"zoom":15,"color":"#ecedee"},{"zoom":16,"color":"#edeeef"},{"zoom":17,"color":"#eeeff0"},{"zoom":18,"color":"#eeeff0"},{"zoom":19,"color":"#eff0f1"},{"zoom":20,"color":"#f0f1f2"},{"zoom":21,"color":"#f1f2f3"}]},{"tags":"building","elements":"geometry.fill","stylers":[{"color":"#dee0e3"},{"zoom":0,"opacity":0.7},{"zoom":1,"opacity":0.7},{"zoom":2,"opacity":0.7},{"zoom":3,"opacity":0.7},{"zoom":4,"opacity":0.7},{"zoom":5,"opacity":0.7},{"zoom":6,"opacity":0.7},{"zoom":7,"opacity":0.7},{"zoom":8,"opacity":0.7},{"zoom":9,"opacity":0.7},{"zoom":10,"opacity":0.7},{"zoom":11,"opacity":0.7},{"zoom":12,"opacity":0.7},{"zoom":13,"opacity":0.7},{"zoom":14,"opacity":0.7},{"zoom":15,"opacity":0.7},{"zoom":16,"opacity":0.9},{"zoom":17,"opacity":0.6},{"zoom":18,"opacity":0.6},{"zoom":19,"opacity":0.6},{"zoom":20,"opacity":0.6},{"zoom":21,"opacity":0.6}]},{"tags":"building","elements":"geometry.outline","stylers":[{"color":"#c8ccd1"},{"zoom":0,"opacity":0.5},{"zoom":1,"opacity":0.5},{"zoom":2,"opacity":0.5},{"zoom":3,"opacity":0.5},{"zoom":4,"opacity":0.5},{"zoom":5,"opacity":0.5},{"zoom":6,"opacity":0.5},{"zoom":7,"opacity":0.5},{"zoom":8,"opacity":0.5},{"zoom":9,"opacity":0.5},{"zoom":10,"opacity":0.5},{"zoom":11,"opacity":0.5},{"zoom":12,"opacity":0.5},{"zoom":13,"opacity":0.5},{"zoom":14,"opacity":0.5},{"zoom":15,"opacity":0.5},{"zoom":16,"opacity":0.5},{"zoom":17,"opacity":1},{"zoom":18,"opacity":1},{"zoom":19,"opacity":1},{"zoom":20,"opacity":1},{"zoom":21,"opacity":1}]},{"tags":{"any":"urban_area","none":["residential","industrial","cemetery","park","medical","sports_ground","beach","construction_site"]},"elements":"geometry","stylers":[{"zoom":0,"color":"#d6d9dc","opacity":1},{"zoom":1,"color":"#d6d9dc","opacity":1},{"zoom":2,"color":"#d6d9dc","opacity":1},{"zoom":3,"color":"#d6d9dc","opacity":1},{"zoom":4,"color":"#d6d9dc","opacity":1},{"zoom":5,"color":"#d6d9dc","opacity":1},{"zoom":6,"color":"#d6d9dc","opacity":1},{"zoom":7,"color":"#d6d9dc","opacity":1},{"zoom":8,"color":"#d6d9dc","opacity":1},{"zoom":9,"color":"#d6d9dc","opacity":1},{"zoom":10,"color":"#d6d9dc","opacity":1},{"zoom":11,"color":"#d6d9dc","opacity":1},{"zoom":12,"color":"#d6d9dc","opacity":1},{"zoom":13,"color":"#d6d9dc","opacity":1},{"zoom":14,"color":"#dddfe2","opacity":1},{"zoom":15,"color":"#e4e6e8","opacity":1},{"zoom":16,"color":"#ebeced","opacity":0.67},{"zoom":17,"color":"#f2f3f3","opacity":0.33},{"zoom":18,"color":"#f2f3f3","opacity":0},{"zoom":19,"color":"#f2f3f3","opacity":0},{"zoom":20,"color":"#f2f3f3","opacity":0},{"zoom":21,"color":"#f2f3f3","opacity":0}]},{"tags":"poi","elements":"label.icon","stylers":[{"color":"#9da6af"},{"secondary-color":"#ffffff"},{"tertiary-color":"#ffffff"}]},{"tags":"poi","elements":"label.text.fill","stylers":[{"color":"#778088"}]},{"tags":"poi","elements":"label.text.outline","stylers":[{"color":"#ffffff"},{"opacity":0.5}]},{"tags":"outdoor","elements":"label.icon","stylers":[{"color":"#9da6af"},{"secondary-color":"#ffffff"},{"tertiary-color":"#ffffff"}]},{"tags":"outdoor","elements":"label.text.fill","stylers":[{"color":"#778088"}]},{"tags":"outdoor","elements":"label.text.outline","stylers":[{"color":"#ffffff"},{"opacity":0.5}]},{"tags":"park","elements":"label.icon","stylers":[{"color":"#9da6af"},{"secondary-color":"#ffffff"},{"tertiary-color":"#ffffff"}]},{"tags":"park","elements":"label.text.fill","stylers":[{"color":"#778088"}]},{"tags":"park","elements":"label.text.outline","stylers":[{"color":"#ffffff"},{"opacity":0.5}]},{"tags":"cemetery","elements":"label.icon","stylers":[{"color":"#9da6af"},{"secondary-color":"#ffffff"},{"tertiary-color":"#ffffff"}]},{"tags":"cemetery","elements":"label.text.fill","stylers":[{"color":"#778088"}]},{"tags":"cemetery","elements":"label.text.outline","stylers":[{"color":"#ffffff"},{"opacity":0.5}]},{"tags":"beach","elements":"label.icon","stylers":[{"color":"#9da6af"},{"secondary-color":"#ffffff"},{"tertiary-color":"#ffffff"}]},{"tags":"beach","elements":"label.text.fill","stylers":[{"color":"#778088"}]},{"tags":"beach","elements":"label.text.outline","stylers":[{"color":"#ffffff"},{"opacity":0.5}]},{"tags":"medical","elements":"label.icon","stylers":[{"color":"#9da6af"},{"secondary-color":"#ffffff"},{"tertiary-color":"#ffffff"}]},{"tags":"medical","elements":"label.text.fill","stylers":[{"color":"#778088"}]},{"tags":"medical","elements":"label.text.outline","stylers":[{"color":"#ffffff"},{"opacity":0.5}]},{"tags":"shopping","elements":"label.icon","stylers":[{"color":"#9da6af"},{"secondary-color":"#ffffff"},{"tertiary-color":"#ffffff"}]},{"tags":"shopping","elements":"label.text.fill","stylers":[{"color":"#778088"}]},{"tags":"shopping","elements":"label.text.outline","stylers":[{"color":"#ffffff"},{"opacity":0.5}]},{"tags":"commercial_services","elements":"label.icon","stylers":[{"color":"#9da6af"},{"secondary-color":"#ffffff"},{"tertiary-color":"#ffffff"}]},{"tags":"commercial_services","elements":"label.text.fill","stylers":[{"color":"#778088"}]},{"tags":"commercial_services","elements":"label.text.outline","stylers":[{"color":"#ffffff"},{"opacity":0.5}]},{"tags":"food_and_drink","elements":"label.icon","stylers":[{"color":"#9da6af"},{"secondary-color":"#ffffff"},{"tertiary-color":"#ffffff"}]},{"tags":"food_and_drink","elements":"label.text.fill","stylers":[{"color":"#778088"}]},{"tags":"food_and_drink","elements":"label.text.outline","stylers":[{"color":"#ffffff"},{"opacity":0.5}]},{"tags":"road","elements":"label.icon","types":"point","stylers":[{"color":"#9da6af"},{"secondary-color":"#ffffff"},{"tertiary-color":"#ffffff"}]},{"tags":"road","elements":"label.text.fill","types":"point","stylers":[{"color":"#ffffff"}]},{"tags":"entrance","elements":"label.icon","stylers":[{"color":"#9da6af"},{"secondary-color":"#ffffff"}]},{"tags":"locality","elements":"label.icon","stylers":[{"color":"#9da6af"},{"secondary-color":"#ffffff"}]},{"tags":"country","elements":"label.text.fill","stylers":[{"opacity":0.8},{"color":"#8f969e"}]},{"tags":"country","elements":"label.text.outline","stylers":[{"color":"#ffffff"},{"opacity":0.5}]},{"tags":"region","elements":"label.text.fill","stylers":[{"color":"#8f969e"},{"opacity":0.8}]},{"tags":"region","elements":"label.text.outline","stylers":[{"color":"#ffffff"},{"opacity":0.5}]},{"tags":"district","elements":"label.text.fill","stylers":[{"color":"#8f969e"},{"opacity":0.8}]},{"tags":"district","elements":"label.text.outline","stylers":[{"color":"#ffffff"},{"opacity":0.5}]},{"tags":{"any":"admin","none":["country","region","locality","district","address"]},"elements":"label.text.fill","stylers":[{"color":"#8f969e"}]},{"tags":{"any":"admin","none":["country","region","locality","district","address"]},"elements":"label.text.outline","stylers":[{"color":"#ffffff"},{"opacity":0.5}]},{"tags":"locality","elements":"label.text.fill","stylers":[{"zoom":0,"color":"#778088"},{"zoom":1,"color":"#778088"},{"zoom":2,"color":"#778088"},{"zoom":3,"color":"#778088"},{"zoom":4,"color":"#778088"},{"zoom":5,"color":"#757e86"},{"zoom":6,"color":"#737c83"},{"zoom":7,"color":"#717a81"},{"zoom":8,"color":"#6f777f"},{"zoom":9,"color":"#6d757c"},{"zoom":10,"color":"#6b737a"},{"zoom":11,"color":"#6b737a"},{"zoom":12,"color":"#6b737a"},{"zoom":13,"color":"#6b737a"},{"zoom":14,"color":"#6b737a"},{"zoom":15,"color":"#6b737a"},{"zoom":16,"color":"#6b737a"},{"zoom":17,"color":"#6b737a"},{"zoom":18,"color":"#6b737a"},{"zoom":19,"color":"#6b737a"},{"zoom":20,"color":"#6b737a"},{"zoom":21,"color":"#6b737a"}]},{"tags":"locality","elements":"label.text.outline","stylers":[{"color":"#ffffff"},{"opacity":0.5}]},{"tags":"road","elements":"label.text.fill","types":"polyline","stylers":[{"color":"#778088"}]},{"tags":"road","elements":"label.text.outline","types":"polyline","stylers":[{"color":"#ffffff"},{"opacity":0.5}]},{"tags":"road","elements":"geometry.fill.pattern","types":"polyline","stylers":[{"scale":1},{"color":"#adb3b8"}]},{"tags":"road","elements":"label.text.fill","types":"point","stylers":[{"color":"#ffffff"}]},{"tags":"structure","elements":"label.text.fill","stylers":[{"color":"#5f666d"},{"opacity":0.5}]},{"tags":"structure","elements":"label.text.outline","stylers":[{"color":"#ffffff"},{"opacity":0.5}]},{"tags":"entrance","elements":"label.text.fill","stylers":[{"color":"#5f666d"},{"opacity":1}]},{"tags":"entrance","elements":"label.text.outline","stylers":[{"color":"#ffffff"},{"opacity":0.5}]},{"tags":"address","elements":"label.text.fill","stylers":[{"color":"#5f666d"},{"zoom":0,"opacity":0.9},{"zoom":1,"opacity":0.9},{"zoom":2,"opacity":0.9},{"zoom":3,"opacity":0.9},{"zoom":4,"opacity":0.9},{"zoom":5,"opacity":0.9},{"zoom":6,"opacity":0.9},{"zoom":7,"opacity":0.9},{"zoom":8,"opacity":0.9},{"zoom":9,"opacity":0.9},{"zoom":10,"opacity":0.9},{"zoom":11,"opacity":0.9},{"zoom":12,"opacity":0.9},{"zoom":13,"opacity":0.9},{"zoom":14,"opacity":0.9},{"zoom":15,"opacity":0.9},{"zoom":16,"opacity":0.9},{"zoom":17,"opacity":1},{"zoom":18,"opacity":1},{"zoom":19,"opacity":1},{"zoom":20,"opacity":1},{"zoom":21,"opacity":1}]},{"tags":"address","elements":"label.text.outline","stylers":[{"color":"#ffffff"},{"opacity":0.5}]},{"tags":"landscape","elements":"label.text.fill","stylers":[{"zoom":0,"color":"#8f969e","opacity":1},{"zoom":1,"color":"#8f969e","opacity":1},{"zoom":2,"color":"#8f969e","opacity":1},{"zoom":3,"color":"#8f969e","opacity":1},{"zoom":4,"color":"#5f666d","opacity":0.5},{"zoom":5,"color":"#5f666d","opacity":0.5},{"zoom":6,"color":"#5f666d","opacity":0.5},{"zoom":7,"color":"#5f666d","opacity":0.5},{"zoom":8,"color":"#5f666d","opacity":0.5},{"zoom":9,"color":"#5f666d","opacity":0.5},{"zoom":10,"color":"#5f666d","opacity":0.5},{"zoom":11,"color":"#5f666d","opacity":0.5},{"zoom":12,"color":"#5f666d","opacity":0.5},{"zoom":13,"color":"#5f666d","opacity":0.5},{"zoom":14,"color":"#5f666d","opacity":0.5},{"zoom":15,"color":"#5f666d","opacity":0.5},{"zoom":16,"color":"#5f666d","opacity":0.5},{"zoom":17,"color":"#5f666d","opacity":0.5},{"zoom":18,"color":"#5f666d","opacity":0.5},{"zoom":19,"color":"#5f666d","opacity":0.5},{"zoom":20,"color":"#5f666d","opacity":0.5},{"zoom":21,"color":"#5f666d","opacity":0.5}]},{"tags":"landscape","elements":"label.text.outline","stylers":[{"color":"#ffffff"},{"zoom":0,"opacity":0.5},{"zoom":1,"opacity":0.5},{"zoom":2,"opacity":0.5},{"zoom":3,"opacity":0.5},{"zoom":4,"opacity":0},{"zoom":5,"opacity":0},{"zoom":6,"opacity":0},{"zoom":7,"opacity":0},{"zoom":8,"opacity":0},{"zoom":9,"opacity":0},{"zoom":10,"opacity":0},{"zoom":11,"opacity":0},{"zoom":12,"opacity":0},{"zoom":13,"opacity":0},{"zoom":14,"opacity":0},{"zoom":15,"opacity":0},{"zoom":16,"opacity":0},{"zoom":17,"opacity":0},{"zoom":18,"opacity":0},{"zoom":19,"opacity":0},{"zoom":20,"opacity":0},{"zoom":21,"opacity":0}]},{"tags":"water","elements":"label.text.fill","stylers":[{"color":"#5e6871"},{"opacity":0.8}]},{"tags":"water","elements":"label.text.outline","types":"polyline","stylers":[{"color":"#ffffff"},{"opacity":0.2}]},{"tags":{"any":"road_1","none":"is_tunnel"},"elements":"geometry.fill","stylers":[{"color":"#ffffff"},{"zoom":0,"scale":0},{"zoom":1,"scale":0},{"zoom":2,"scale":0},{"zoom":3,"scale":0},{"zoom":4,"scale":0},{"zoom":5,"scale":0},{"zoom":6,"scale":3.3},{"zoom":7,"scale":3.55},{"zoom":8,"scale":3.92},{"zoom":9,"scale":4.44},{"zoom":10,"scale":4.01},{"zoom":11,"scale":3.39},{"zoom":12,"scale":2.94},{"zoom":13,"scale":2.53},{"zoom":14,"scale":2.26},{"zoom":15,"scale":2.11},{"zoom":16,"scale":2.07},{"zoom":17,"scale":1.64},{"zoom":18,"scale":1.35},{"zoom":19,"scale":1.16},{"zoom":20,"scale":1.05},{"zoom":21,"scale":1}]},{"tags":{"any":"road_1"},"elements":"geometry.outline","stylers":[{"color":"#c8ccd0"},{"zoom":0,"scale":1},{"zoom":1,"scale":1},{"zoom":2,"scale":1},{"zoom":3,"scale":1},{"zoom":4,"scale":1},{"zoom":5,"scale":1},{"zoom":6,"scale":2.18},{"zoom":7,"scale":2.18},{"zoom":8,"scale":2.25},{"zoom":9,"scale":2.4},{"zoom":10,"scale":2.4},{"zoom":11,"scale":2.26},{"zoom":12,"scale":2.15},{"zoom":13,"scale":2},{"zoom":14,"scale":1.9},{"zoom":15,"scale":1.86},{"zoom":16,"scale":1.88},{"zoom":17,"scale":1.53},{"zoom":18,"scale":1.28},{"zoom":19,"scale":1.11},{"zoom":20,"scale":1.01},{"zoom":21,"scale":0.96}]},{"tags":{"any":"road_2","none":"is_tunnel"},"elements":"geometry.fill","stylers":[{"color":"#ffffff"},{"zoom":0,"scale":0},{"zoom":1,"scale":0},{"zoom":2,"scale":0},{"zoom":3,"scale":0},{"zoom":4,"scale":0},{"zoom":5,"scale":0},{"zoom":6,"scale":3.3},{"zoom":7,"scale":3.55},{"zoom":8,"scale":3.92},{"zoom":9,"scale":4.44},{"zoom":10,"scale":4.01},{"zoom":11,"scale":3.39},{"zoom":12,"scale":2.94},{"zoom":13,"scale":2.53},{"zoom":14,"scale":2.26},{"zoom":15,"scale":2.11},{"zoom":16,"scale":2.07},{"zoom":17,"scale":1.64},{"zoom":18,"scale":1.35},{"zoom":19,"scale":1.16},{"zoom":20,"scale":1.05},{"zoom":21,"scale":1}]},{"tags":{"any":"road_2"},"elements":"geometry.outline","stylers":[{"color":"#c8ccd0"},{"zoom":0,"scale":1},{"zoom":1,"scale":1},{"zoom":2,"scale":1},{"zoom":3,"scale":1},{"zoom":4,"scale":1},{"zoom":5,"scale":1},{"zoom":6,"scale":2.18},{"zoom":7,"scale":2.18},{"zoom":8,"scale":2.25},{"zoom":9,"scale":2.4},{"zoom":10,"scale":2.4},{"zoom":11,"scale":2.26},{"zoom":12,"scale":2.15},{"zoom":13,"scale":2},{"zoom":14,"scale":1.9},{"zoom":15,"scale":1.86},{"zoom":16,"scale":1.88},{"zoom":17,"scale":1.53},{"zoom":18,"scale":1.28},{"zoom":19,"scale":1.11},{"zoom":20,"scale":1.01},{"zoom":21,"scale":0.96}]},{"tags":{"any":"road_3","none":"is_tunnel"},"elements":"geometry.fill","stylers":[{"color":"#ffffff"},{"zoom":0,"scale":0},{"zoom":1,"scale":0},{"zoom":2,"scale":0},{"zoom":3,"scale":0},{"zoom":4,"scale":0},{"zoom":5,"scale":0},{"zoom":6,"scale":0},{"zoom":7,"scale":0},{"zoom":8,"scale":0},{"zoom":9,"scale":2.79},{"zoom":10,"scale":2.91},{"zoom":11,"scale":1.86},{"zoom":12,"scale":1.86},{"zoom":13,"scale":1.54},{"zoom":14,"scale":1.32},{"zoom":15,"scale":1.2},{"zoom":16,"scale":1.15},{"zoom":17,"scale":1.01},{"zoom":18,"scale":0.93},{"zoom":19,"scale":0.91},{"zoom":20,"scale":0.93},{"zoom":21,"scale":1}]},{"tags":{"any":"road_3"},"elements":"geometry.outline","stylers":[{"color":"#c8ccd0"},{"zoom":0,"scale":1.14},{"zoom":1,"scale":1.14},{"zoom":2,"scale":1.14},{"zoom":3,"scale":1.14},{"zoom":4,"scale":1.14},{"zoom":5,"scale":1.14},{"zoom":6,"scale":1.14},{"zoom":7,"scale":1.14},{"zoom":8,"scale":0.92},{"zoom":9,"scale":3.01},{"zoom":10,"scale":1.95},{"zoom":11,"scale":1.46},{"zoom":12,"scale":1.52},{"zoom":13,"scale":1.35},{"zoom":14,"scale":1.22},{"zoom":15,"scale":1.14},{"zoom":16,"scale":1.11},{"zoom":17,"scale":0.98},{"zoom":18,"scale":0.9},{"zoom":19,"scale":0.88},{"zoom":20,"scale":0.9},{"zoom":21,"scale":0.96}]},{"tags":{"any":"road_4","none":"is_tunnel"},"elements":"geometry.fill","stylers":[{"color":"#ffffff"},{"zoom":0,"scale":0},{"zoom":1,"scale":0},{"zoom":2,"scale":0},{"zoom":3,"scale":0},{"zoom":4,"scale":0},{"zoom":5,"scale":0},{"zoom":6,"scale":0},{"zoom":7,"scale":0},{"zoom":8,"scale":0},{"zoom":9,"scale":0},{"zoom":10,"scale":1.88},{"zoom":11,"scale":1.4},{"zoom":12,"scale":1.57},{"zoom":13,"scale":1.32},{"zoom":14,"scale":1.16},{"zoom":15,"scale":1.07},{"zoom":16,"scale":1.28},{"zoom":17,"scale":1.1},{"zoom":18,"scale":0.99},{"zoom":19,"scale":0.94},{"zoom":20,"scale":0.95},{"zoom":21,"scale":1}]},{"tags":{"any":"road_4"},"elements":"geometry.outline","stylers":[{"color":"#c8ccd0"},{"zoom":0,"scale":1},{"zoom":1,"scale":1},{"zoom":2,"scale":1},{"zoom":3,"scale":1},{"zoom":4,"scale":1},{"zoom":5,"scale":1},{"zoom":6,"scale":1},{"zoom":7,"scale":1},{"zoom":8,"scale":1},{"zoom":9,"scale":0.8},{"zoom":10,"scale":1.36},{"zoom":11,"scale":1.15},{"zoom":12,"scale":1.3},{"zoom":13,"scale":1.17},{"zoom":14,"scale":1.08},{"zoom":15,"scale":1.03},{"zoom":16,"scale":1.21},{"zoom":17,"scale":1.05},{"zoom":18,"scale":0.96},{"zoom":19,"scale":0.91},{"zoom":20,"scale":0.91},{"zoom":21,"scale":0.96}]},{"tags":{"any":"road_5","none":"is_tunnel"},"elements":"geometry.fill","stylers":[{"color":"#ffffff"},{"zoom":0,"scale":0},{"zoom":1,"scale":0},{"zoom":2,"scale":0},{"zoom":3,"scale":0},{"zoom":4,"scale":0},{"zoom":5,"scale":0},{"zoom":6,"scale":0},{"zoom":7,"scale":0},{"zoom":8,"scale":0},{"zoom":9,"scale":0},{"zoom":10,"scale":0},{"zoom":11,"scale":0},{"zoom":12,"scale":1.39},{"zoom":13,"scale":1.05},{"zoom":14,"scale":0.9},{"zoom":15,"scale":1.05},{"zoom":16,"scale":1.22},{"zoom":17,"scale":1.04},{"zoom":18,"scale":0.94},{"zoom":19,"scale":0.91},{"zoom":20,"scale":0.93},{"zoom":21,"scale":1}]},{"tags":{"any":"road_5"},"elements":"geometry.outline","stylers":[{"color":"#c8ccd0"},{"zoom":0,"scale":1},{"zoom":1,"scale":1},{"zoom":2,"scale":1},{"zoom":3,"scale":1},{"zoom":4,"scale":1},{"zoom":5,"scale":1},{"zoom":6,"scale":1},{"zoom":7,"scale":1},{"zoom":8,"scale":1},{"zoom":9,"scale":1},{"zoom":10,"scale":1},{"zoom":11,"scale":0.44},{"zoom":12,"scale":1.15},{"zoom":13,"scale":0.97},{"zoom":14,"scale":0.87},{"zoom":15,"scale":1.01},{"zoom":16,"scale":1.16},{"zoom":17,"scale":1},{"zoom":18,"scale":0.91},{"zoom":19,"scale":0.88},{"zoom":20,"scale":0.89},{"zoom":21,"scale":0.96}]},{"tags":{"any":"road_6","none":"is_tunnel"},"elements":"geometry.fill","stylers":[{"color":"#ffffff"},{"zoom":0,"scale":0},{"zoom":1,"scale":0},{"zoom":2,"scale":0},{"zoom":3,"scale":0},{"zoom":4,"scale":0},{"zoom":5,"scale":0},{"zoom":6,"scale":0},{"zoom":7,"scale":0},{"zoom":8,"scale":0},{"zoom":9,"scale":0},{"zoom":10,"scale":0},{"zoom":11,"scale":0},{"zoom":12,"scale":0},{"zoom":13,"scale":2.5},{"zoom":14,"scale":1.41},{"zoom":15,"scale":1.39},{"zoom":16,"scale":1.45},{"zoom":17,"scale":1.16},{"zoom":18,"scale":1},{"zoom":19,"scale":0.94},{"zoom":20,"scale":0.94},{"zoom":21,"scale":1}]},{"tags":{"any":"road_6"},"elements":"geometry.outline","stylers":[{"color":"#c8ccd0"},{"zoom":0,"scale":1},{"zoom":1,"scale":1},{"zoom":2,"scale":1},{"zoom":3,"scale":1},{"zoom":4,"scale":1},{"zoom":5,"scale":1},{"zoom":6,"scale":1},{"zoom":7,"scale":1},{"zoom":8,"scale":1},{"zoom":9,"scale":1},{"zoom":10,"scale":1},{"zoom":11,"scale":1},{"zoom":12,"scale":1},{"zoom":13,"scale":1.65},{"zoom":14,"scale":1.21},{"zoom":15,"scale":1.26},{"zoom":16,"scale":1.35},{"zoom":17,"scale":1.1},{"zoom":18,"scale":0.97},{"zoom":19,"scale":0.91},{"zoom":20,"scale":0.91},{"zoom":21,"scale":0.96}]},{"tags":{"any":"road_7","none":"is_tunnel"},"elements":"geometry.fill","stylers":[{"color":"#ffffff"},{"zoom":0,"scale":0},{"zoom":1,"scale":0},{"zoom":2,"scale":0},{"zoom":3,"scale":0},{"zoom":4,"scale":0},{"zoom":5,"scale":0},{"zoom":6,"scale":0},{"zoom":7,"scale":0},{"zoom":8,"scale":0},{"zoom":9,"scale":0},{"zoom":10,"scale":0},{"zoom":11,"scale":0},{"zoom":12,"scale":0},{"zoom":13,"scale":0},{"zoom":14,"scale":1},{"zoom":15,"scale":0.87},{"zoom":16,"scale":0.97},{"zoom":17,"scale":0.89},{"zoom":18,"scale":0.86},{"zoom":19,"scale":0.88},{"zoom":20,"scale":0.92},{"zoom":21,"scale":1}]},{"tags":{"any":"road_7"},"elements":"geometry.outline","stylers":[{"color":"#c8ccd0"},{"zoom":0,"scale":1},{"zoom":1,"scale":1},{"zoom":2,"scale":1},{"zoom":3,"scale":1},{"zoom":4,"scale":1},{"zoom":5,"scale":1},{"zoom":6,"scale":1},{"zoom":7,"scale":1},{"zoom":8,"scale":1},{"zoom":9,"scale":1},{"zoom":10,"scale":1},{"zoom":11,"scale":1},{"zoom":12,"scale":1},{"zoom":13,"scale":1},{"zoom":14,"scale":0.93},{"zoom":15,"scale":0.85},{"zoom":16,"scale":0.94},{"zoom":17,"scale":0.86},{"zoom":18,"scale":0.83},{"zoom":19,"scale":0.84},{"zoom":20,"scale":0.88},{"zoom":21,"scale":0.95}]},{"tags":{"any":"road_minor","none":"is_tunnel"},"elements":"geometry.fill","stylers":[{"color":"#ffffff"},{"zoom":0,"scale":0},{"zoom":1,"scale":0},{"zoom":2,"scale":0},{"zoom":3,"scale":0},{"zoom":4,"scale":0},{"zoom":5,"scale":0},{"zoom":6,"scale":0},{"zoom":7,"scale":0},{"zoom":8,"scale":0},{"zoom":9,"scale":0},{"zoom":10,"scale":0},{"zoom":11,"scale":0},{"zoom":12,"scale":0},{"zoom":13,"scale":0},{"zoom":14,"scale":0},{"zoom":15,"scale":0},{"zoom":16,"scale":1},{"zoom":17,"scale":1},{"zoom":18,"scale":1},{"zoom":19,"scale":1},{"zoom":20,"scale":1},{"zoom":21,"scale":1}]},{"tags":{"any":"road_minor"},"elements":"geometry.outline","stylers":[{"color":"#c8ccd0"},{"zoom":0,"scale":0.29},{"zoom":1,"scale":0.29},{"zoom":2,"scale":0.29},{"zoom":3,"scale":0.29},{"zoom":4,"scale":0.29},{"zoom":5,"scale":0.29},{"zoom":6,"scale":0.29},{"zoom":7,"scale":0.29},{"zoom":8,"scale":0.29},{"zoom":9,"scale":0.29},{"zoom":10,"scale":0.29},{"zoom":11,"scale":0.29},{"zoom":12,"scale":0.29},{"zoom":13,"scale":0.29},{"zoom":14,"scale":0.29},{"zoom":15,"scale":0.29},{"zoom":16,"scale":1},{"zoom":17,"scale":0.9},{"zoom":18,"scale":0.91},{"zoom":19,"scale":0.92},{"zoom":20,"scale":0.93},{"zoom":21,"scale":0.95}]},{"tags":{"any":"road_unclassified","none":"is_tunnel"},"elements":"geometry.fill","stylers":[{"color":"#ffffff"},{"zoom":0,"scale":0},{"zoom":1,"scale":0},{"zoom":2,"scale":0},{"zoom":3,"scale":0},{"zoom":4,"scale":0},{"zoom":5,"scale":0},{"zoom":6,"scale":0},{"zoom":7,"scale":0},{"zoom":8,"scale":0},{"zoom":9,"scale":0},{"zoom":10,"scale":0},{"zoom":11,"scale":0},{"zoom":12,"scale":0},{"zoom":13,"scale":0},{"zoom":14,"scale":0},{"zoom":15,"scale":0},{"zoom":16,"scale":1},{"zoom":17,"scale":1},{"zoom":18,"scale":1},{"zoom":19,"scale":1},{"zoom":20,"scale":1},{"zoom":21,"scale":1}]},{"tags":{"any":"road_unclassified"},"elements":"geometry.outline","stylers":[{"color":"#c8ccd0"},{"zoom":0,"scale":0.29},{"zoom":1,"scale":0.29},{"zoom":2,"scale":0.29},{"zoom":3,"scale":0.29},{"zoom":4,"scale":0.29},{"zoom":5,"scale":0.29},{"zoom":6,"scale":0.29},{"zoom":7,"scale":0.29},{"zoom":8,"scale":0.29},{"zoom":9,"scale":0.29},{"zoom":10,"scale":0.29},{"zoom":11,"scale":0.29},{"zoom":12,"scale":0.29},{"zoom":13,"scale":0.29},{"zoom":14,"scale":0.29},{"zoom":15,"scale":0.29},{"zoom":16,"scale":1},{"zoom":17,"scale":0.9},{"zoom":18,"scale":0.91},{"zoom":19,"scale":0.92},{"zoom":20,"scale":0.93},{"zoom":21,"scale":0.95}]},{"tags":{"all":"is_tunnel","none":"path"},"elements":"geometry.fill","stylers":[{"zoom":0,"color":"#dcdee0"},{"zoom":1,"color":"#dcdee0"},{"zoom":2,"color":"#dcdee0"},{"zoom":3,"color":"#dcdee0"},{"zoom":4,"color":"#dcdee0"},{"zoom":5,"color":"#dcdee0"},{"zoom":6,"color":"#dcdee0"},{"zoom":7,"color":"#dcdee0"},{"zoom":8,"color":"#dcdee0"},{"zoom":9,"color":"#dcdee0"},{"zoom":10,"color":"#dcdee0"},{"zoom":11,"color":"#dcdee0"},{"zoom":12,"color":"#dcdee0"},{"zoom":13,"color":"#dcdee0"},{"zoom":14,"color":"#e1e3e5"},{"zoom":15,"color":"#e6e8ea"},{"zoom":16,"color":"#e7e9eb"},{"zoom":17,"color":"#e8eaeb"},{"zoom":18,"color":"#e9eaec"},{"zoom":19,"color":"#eaebed"},{"zoom":20,"color":"#ebeced"},{"zoom":21,"color":"#ecedee"}]},{"tags":{"all":"path","none":"is_tunnel"},"elements":"geometry.fill","stylers":[{"color":"#c8ccd0"}]},{"tags":{"all":"path","none":"is_tunnel"},"elements":"geometry.outline","stylers":[{"opacity":0.7},{"zoom":0,"color":"#e1e3e5"},{"zoom":1,"color":"#e1e3e5"},{"zoom":2,"color":"#e1e3e5"},{"zoom":3,"color":"#e1e3e5"},{"zoom":4,"color":"#e1e3e5"},{"zoom":5,"color":"#e1e3e5"},{"zoom":6,"color":"#e1e3e5"},{"zoom":7,"color":"#e1e3e5"},{"zoom":8,"color":"#e1e3e5"},{"zoom":9,"color":"#e1e3e5"},{"zoom":10,"color":"#e1e3e5"},{"zoom":11,"color":"#e1e3e5"},{"zoom":12,"color":"#e1e3e5"},{"zoom":13,"color":"#e1e3e5"},{"zoom":14,"color":"#e6e8e9"},{"zoom":15,"color":"#ecedee"},{"zoom":16,"color":"#edeeef"},{"zoom":17,"color":"#eeeff0"},{"zoom":18,"color":"#eeeff0"},{"zoom":19,"color":"#eff0f1"},{"zoom":20,"color":"#f0f1f2"},{"zoom":21,"color":"#f1f2f3"}]},{"tags":"road_construction","elements":"geometry.fill","stylers":[{"color":"#ffffff"}]},{"tags":"road_construction","elements":"geometry.outline","stylers":[{"zoom":0,"color":"#e4e6e8"},{"zoom":1,"color":"#e4e6e8"},{"zoom":2,"color":"#e4e6e8"},{"zoom":3,"color":"#e4e6e8"},{"zoom":4,"color":"#e4e6e8"},{"zoom":5,"color":"#e4e6e8"},{"zoom":6,"color":"#e4e6e8"},{"zoom":7,"color":"#e4e6e8"},{"zoom":8,"color":"#e4e6e8"},{"zoom":9,"color":"#e4e6e8"},{"zoom":10,"color":"#e4e6e8"},{"zoom":11,"color":"#e4e6e8"},{"zoom":12,"color":"#e4e6e8"},{"zoom":13,"color":"#e4e6e8"},{"zoom":14,"color":"#c8ccd0"},{"zoom":15,"color":"#e4e6e8"},{"zoom":16,"color":"#e8eaec"},{"zoom":17,"color":"#edeef0"},{"zoom":18,"color":"#f1f2f3"},{"zoom":19,"color":"#f6f7f7"},{"zoom":20,"color":"#fafbfb"},{"zoom":21,"color":"#ffffff"}]},{"tags":{"any":"ferry"},"stylers":[{"color":"#919ba4"}]},{"tags":"transit_location","elements":"label.icon","stylers":[{"saturation":-1},{"zoom":0,"opacity":0},{"zoom":1,"opacity":0},{"zoom":2,"opacity":0},{"zoom":3,"opacity":0},{"zoom":4,"opacity":0},{"zoom":5,"opacity":0},{"zoom":6,"opacity":0},{"zoom":7,"opacity":0},{"zoom":8,"opacity":0},{"zoom":9,"opacity":0},{"zoom":10,"opacity":0},{"zoom":11,"opacity":0},{"zoom":12,"opacity":0},{"zoom":13,"opacity":1},{"zoom":14,"opacity":1},{"zoom":15,"opacity":1},{"zoom":16,"opacity":1},{"zoom":17,"opacity":1},{"zoom":18,"opacity":1},{"zoom":19,"opacity":1},{"zoom":20,"opacity":1},{"zoom":21,"opacity":1}]},{"tags":"transit_location","elements":"label.text","stylers":[{"zoom":0,"opacity":0},{"zoom":1,"opacity":0},{"zoom":2,"opacity":0},{"zoom":3,"opacity":0},{"zoom":4,"opacity":0},{"zoom":5,"opacity":0},{"zoom":6,"opacity":0},{"zoom":7,"opacity":0},{"zoom":8,"opacity":0},{"zoom":9,"opacity":0},{"zoom":10,"opacity":0},{"zoom":11,"opacity":0},{"zoom":12,"opacity":0},{"zoom":13,"opacity":1},{"zoom":14,"opacity":1},{"zoom":15,"opacity":1},{"zoom":16,"opacity":1},{"zoom":17,"opacity":1},{"zoom":18,"opacity":1},{"zoom":19,"opacity":1},{"zoom":20,"opacity":1},{"zoom":21,"opacity":1}]},{"tags":"transit_location","elements":"label.text.fill","stylers":[{"color":"#6c8993"}]},{"tags":"transit_location","elements":"label.text.outline","stylers":[{"color":"#ffffff"}]},{"tags":"transit_schema","elements":"geometry.fill","stylers":[{"color":"#6c8993"},{"scale":0.7},{"zoom":0,"opacity":0.6},{"zoom":1,"opacity":0.6},{"zoom":2,"opacity":0.6},{"zoom":3,"opacity":0.6},{"zoom":4,"opacity":0.6},{"zoom":5,"opacity":0.6},{"zoom":6,"opacity":0.6},{"zoom":7,"opacity":0.6},{"zoom":8,"opacity":0.6},{"zoom":9,"opacity":0.6},{"zoom":10,"opacity":0.6},{"zoom":11,"opacity":0.6},{"zoom":12,"opacity":0.6},{"zoom":13,"opacity":0.6},{"zoom":14,"opacity":0.6},{"zoom":15,"opacity":0.5},{"zoom":16,"opacity":0.4},{"zoom":17,"opacity":0.4},{"zoom":18,"opacity":0.4},{"zoom":19,"opacity":0.4},{"zoom":20,"opacity":0.4},{"zoom":21,"opacity":0.4}]},{"tags":"transit_schema","elements":"geometry.outline","stylers":[{"opacity":0}]},{"tags":"transit_line","elements":"geometry.fill.pattern","stylers":[{"color":"#949c9e"},{"zoom":0,"opacity":0},{"zoom":1,"opacity":0},{"zoom":2,"opacity":0},{"zoom":3,"opacity":0},{"zoom":4,"opacity":0},{"zoom":5,"opacity":0},{"zoom":6,"opacity":0},{"zoom":7,"opacity":0},{"zoom":8,"opacity":0},{"zoom":9,"opacity":0},{"zoom":10,"opacity":0},{"zoom":11,"opacity":0},{"zoom":12,"opacity":0},{"zoom":13,"opacity":1},{"zoom":14,"opacity":1},{"zoom":15,"opacity":1},{"zoom":16,"opacity":1},{"zoom":17,"opacity":1},{"zoom":18,"opacity":1},{"zoom":19,"opacity":1},{"zoom":20,"opacity":1},{"zoom":21,"opacity":1}]},{"tags":"transit_line","elements":"geometry.fill","stylers":[{"color":"#949c9e"},{"scale":0.4},{"zoom":0,"opacity":0},{"zoom":1,"opacity":0},{"zoom":2,"opacity":0},{"zoom":3,"opacity":0},{"zoom":4,"opacity":0},{"zoom":5,"opacity":0},{"zoom":6,"opacity":0},{"zoom":7,"opacity":0},{"zoom":8,"opacity":0},{"zoom":9,"opacity":0},{"zoom":10,"opacity":0},{"zoom":11,"opacity":0},{"zoom":12,"opacity":0},{"zoom":13,"opacity":1},{"zoom":14,"opacity":1},{"zoom":15,"opacity":1},{"zoom":16,"opacity":1},{"zoom":17,"opacity":1},{"zoom":18,"opacity":1},{"zoom":19,"opacity":1},{"zoom":20,"opacity":1},{"zoom":21,"opacity":1}]},{"tags":"water","elements":"geometry","stylers":[{"zoom":0,"color":"#adb4bb"},{"zoom":1,"color":"#adb4bb"},{"zoom":2,"color":"#adb4bb"},{"zoom":3,"color":"#adb4bb"},{"zoom":4,"color":"#adb4bb"},{"zoom":5,"color":"#adb4bb"},{"zoom":6,"color":"#adb4bb"},{"zoom":7,"color":"#adb4bb"},{"zoom":8,"color":"#afb6bd"},{"zoom":9,"color":"#b1b7be"},{"zoom":10,"color":"#b3b9c0"},{"zoom":11,"color":"#b4bac1"},{"zoom":12,"color":"#b4bbc1"},{"zoom":13,"color":"#b5bcc2"},{"zoom":14,"color":"#b6bdc3"},{"zoom":15,"color":"#b8bec4"},{"zoom":16,"color":"#b9c0c5"},{"zoom":17,"color":"#bbc1c6"},{"zoom":18,"color":"#bcc2c8"},{"zoom":19,"color":"#bec3c9"},{"zoom":20,"color":"#bfc5ca"},{"zoom":21,"color":"#c1c6cb"}]},{"tags":"water","elements":"geometry","types":"polyline","stylers":[{"zoom":0,"opacity":0.4},{"zoom":1,"opacity":0.4},{"zoom":2,"opacity":0.4},{"zoom":3,"opacity":0.4},{"zoom":4,"opacity":0.6},{"zoom":5,"opacity":0.8},{"zoom":6,"opacity":1},{"zoom":7,"opacity":1},{"zoom":8,"opacity":1},{"zoom":9,"opacity":1},{"zoom":10,"opacity":1},{"zoom":11,"opacity":1},{"zoom":12,"opacity":1},{"zoom":13,"opacity":1},{"zoom":14,"opacity":1},{"zoom":15,"opacity":1},{"zoom":16,"opacity":1},{"zoom":17,"opacity":1},{"zoom":18,"opacity":1},{"zoom":19,"opacity":1},{"zoom":20,"opacity":1},{"zoom":21,"opacity":1}]},{"tags":"bathymetry","elements":"geometry","stylers":[{"hue":"#adb4bb"}]},{"tags":{"any":["industrial","construction_site"]},"elements":"geometry","stylers":[{"zoom":0,"color":"#dcdee0"},{"zoom":1,"color":"#dcdee0"},{"zoom":2,"color":"#dcdee0"},{"zoom":3,"color":"#dcdee0"},{"zoom":4,"color":"#dcdee0"},{"zoom":5,"color":"#dcdee0"},{"zoom":6,"color":"#dcdee0"},{"zoom":7,"color":"#dcdee0"},{"zoom":8,"color":"#dcdee0"},{"zoom":9,"color":"#dcdee0"},{"zoom":10,"color":"#dcdee0"},{"zoom":11,"color":"#dcdee0"},{"zoom":12,"color":"#dcdee0"},{"zoom":13,"color":"#dcdee0"},{"zoom":14,"color":"#e1e3e5"},{"zoom":15,"color":"#e7e8ea"},{"zoom":16,"color":"#e8e9eb"},{"zoom":17,"color":"#e9eaeb"},{"zoom":18,"color":"#e9eaec"},{"zoom":19,"color":"#eaebed"},{"zoom":20,"color":"#ebeced"},{"zoom":21,"color":"#ecedee"}]},{"tags":{"any":"transit","none":["transit_location","transit_line","transit_schema","is_unclassified_transit"]},"elements":"geometry","stylers":[{"zoom":0,"color":"#dcdee0"},{"zoom":1,"color":"#dcdee0"},{"zoom":2,"color":"#dcdee0"},{"zoom":3,"color":"#dcdee0"},{"zoom":4,"color":"#dcdee0"},{"zoom":5,"color":"#dcdee0"},{"zoom":6,"color":"#dcdee0"},{"zoom":7,"color":"#dcdee0"},{"zoom":8,"color":"#dcdee0"},{"zoom":9,"color":"#dcdee0"},{"zoom":10,"color":"#dcdee0"},{"zoom":11,"color":"#dcdee0"},{"zoom":12,"color":"#dcdee0"},{"zoom":13,"color":"#dcdee0"},{"zoom":14,"color":"#e1e3e5"},{"zoom":15,"color":"#e7e8ea"},{"zoom":16,"color":"#e8e9eb"},{"zoom":17,"color":"#e9eaeb"},{"zoom":18,"color":"#e9eaec"},{"zoom":19,"color":"#eaebed"},{"zoom":20,"color":"#ebeced"},{"zoom":21,"color":"#ecedee"}]},{"tags":"fence","elements":"geometry.fill","stylers":[{"color":"#d1d4d6"},{"zoom":0,"opacity":0.75},{"zoom":1,"opacity":0.75},{"zoom":2,"opacity":0.75},{"zoom":3,"opacity":0.75},{"zoom":4,"opacity":0.75},{"zoom":5,"opacity":0.75},{"zoom":6,"opacity":0.75},{"zoom":7,"opacity":0.75},{"zoom":8,"opacity":0.75},{"zoom":9,"opacity":0.75},{"zoom":10,"opacity":0.75},{"zoom":11,"opacity":0.75},{"zoom":12,"opacity":0.75},{"zoom":13,"opacity":0.75},{"zoom":14,"opacity":0.75},{"zoom":15,"opacity":0.75},{"zoom":16,"opacity":0.75},{"zoom":17,"opacity":0.45},{"zoom":18,"opacity":0.45},{"zoom":19,"opacity":0.45},{"zoom":20,"opacity":0.45},{"zoom":21,"opacity":0.45}]},{"tags":"medical","elements":"geometry","stylers":[{"zoom":0,"color":"#dcdee0"},{"zoom":1,"color":"#dcdee0"},{"zoom":2,"color":"#dcdee0"},{"zoom":3,"color":"#dcdee0"},{"zoom":4,"color":"#dcdee0"},{"zoom":5,"color":"#dcdee0"},{"zoom":6,"color":"#dcdee0"},{"zoom":7,"color":"#dcdee0"},{"zoom":8,"color":"#dcdee0"},{"zoom":9,"color":"#dcdee0"},{"zoom":10,"color":"#dcdee0"},{"zoom":11,"color":"#dcdee0"},{"zoom":12,"color":"#dcdee0"},{"zoom":13,"color":"#dcdee0"},{"zoom":14,"color":"#e1e3e5"},{"zoom":15,"color":"#e7e8ea"},{"zoom":16,"color":"#e8e9eb"},{"zoom":17,"color":"#e9eaeb"},{"zoom":18,"color":"#e9eaec"},{"zoom":19,"color":"#eaebed"},{"zoom":20,"color":"#ebeced"},{"zoom":21,"color":"#ecedee"}]},{"tags":"beach","elements":"geometry","stylers":[{"zoom":0,"color":"#dcdee0","opacity":0.3},{"zoom":1,"color":"#dcdee0","opacity":0.3},{"zoom":2,"color":"#dcdee0","opacity":0.3},{"zoom":3,"color":"#dcdee0","opacity":0.3},{"zoom":4,"color":"#dcdee0","opacity":0.3},{"zoom":5,"color":"#dcdee0","opacity":0.3},{"zoom":6,"color":"#dcdee0","opacity":0.3},{"zoom":7,"color":"#dcdee0","opacity":0.3},{"zoom":8,"color":"#dcdee0","opacity":0.3},{"zoom":9,"color":"#dcdee0","opacity":0.3},{"zoom":10,"color":"#dcdee0","opacity":0.3},{"zoom":11,"color":"#dcdee0","opacity":0.3},{"zoom":12,"color":"#dcdee0","opacity":0.3},{"zoom":13,"color":"#dcdee0","opacity":0.65},{"zoom":14,"color":"#e1e3e5","opacity":1},{"zoom":15,"color":"#e7e8ea","opacity":1},{"zoom":16,"color":"#e8e9eb","opacity":1},{"zoom":17,"color":"#e9eaeb","opacity":1},{"zoom":18,"color":"#e9eaec","opacity":1},{"zoom":19,"color":"#eaebed","opacity":1},{"zoom":20,"color":"#ebeced","opacity":1},{"zoom":21,"color":"#ecedee","opacity":1}]},{"tags":{"all":["is_tunnel","path"]},"elements":"geometry.fill","stylers":[{"color":"#c3c7cb"},{"opacity":0.3}]},{"tags":{"all":["is_tunnel","path"]},"elements":"geometry.outline","stylers":[{"opacity":0}]},{"tags":"road_limited","elements":"geometry.fill","stylers":[{"color":"#c8ccd0"},{"zoom":0,"scale":0},{"zoom":1,"scale":0},{"zoom":2,"scale":0},{"zoom":3,"scale":0},{"zoom":4,"scale":0},{"zoom":5,"scale":0},{"zoom":6,"scale":0},{"zoom":7,"scale":0},{"zoom":8,"scale":0},{"zoom":9,"scale":0},{"zoom":10,"scale":0},{"zoom":11,"scale":0},{"zoom":12,"scale":0},{"zoom":13,"scale":0.1},{"zoom":14,"scale":0.2},{"zoom":15,"scale":0.3},{"zoom":16,"scale":0.5},{"zoom":17,"scale":0.6},{"zoom":18,"scale":0.7},{"zoom":19,"scale":0.88},{"zoom":20,"scale":0.92},{"zoom":21,"scale":1}]},{"tags":"road_limited","elements":"geometry.outline","stylers":[{"color":"#c8ccd0"},{"zoom":0,"scale":1},{"zoom":1,"scale":1},{"zoom":2,"scale":1},{"zoom":3,"scale":1},{"zoom":4,"scale":1},{"zoom":5,"scale":1},{"zoom":6,"scale":1},{"zoom":7,"scale":1},{"zoom":8,"scale":1},{"zoom":9,"scale":1},{"zoom":10,"scale":1},{"zoom":11,"scale":1},{"zoom":12,"scale":1},{"zoom":13,"scale":0.1},{"zoom":14,"scale":0.2},{"zoom":15,"scale":0.3},{"zoom":16,"scale":0.5},{"zoom":17,"scale":0.6},{"zoom":18,"scale":0.7},{"zoom":19,"scale":0.84},{"zoom":20,"scale":0.88},{"zoom":21,"scale":0.95}]},{"tags":{"any":"landcover","none":"vegetation"},"stylers":{"visibility":"off"}}]');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/async module */
/******/ 	(() => {
/******/ 		var webpackQueues = typeof Symbol === "function" ? Symbol("webpack queues") : "__webpack_queues__";
/******/ 		var webpackExports = typeof Symbol === "function" ? Symbol("webpack exports") : "__webpack_exports__";
/******/ 		var webpackError = typeof Symbol === "function" ? Symbol("webpack error") : "__webpack_error__";
/******/ 		var resolveQueue = (queue) => {
/******/ 			if(queue && queue.d < 1) {
/******/ 				queue.d = 1;
/******/ 				queue.forEach((fn) => (fn.r--));
/******/ 				queue.forEach((fn) => (fn.r-- ? fn.r++ : fn()));
/******/ 			}
/******/ 		}
/******/ 		var wrapDeps = (deps) => (deps.map((dep) => {
/******/ 			if(dep !== null && typeof dep === "object") {
/******/ 				if(dep[webpackQueues]) return dep;
/******/ 				if(dep.then) {
/******/ 					var queue = [];
/******/ 					queue.d = 0;
/******/ 					dep.then((r) => {
/******/ 						obj[webpackExports] = r;
/******/ 						resolveQueue(queue);
/******/ 					}, (e) => {
/******/ 						obj[webpackError] = e;
/******/ 						resolveQueue(queue);
/******/ 					});
/******/ 					var obj = {};
/******/ 					obj[webpackQueues] = (fn) => (fn(queue));
/******/ 					return obj;
/******/ 				}
/******/ 			}
/******/ 			var ret = {};
/******/ 			ret[webpackQueues] = x => {};
/******/ 			ret[webpackExports] = dep;
/******/ 			return ret;
/******/ 		}));
/******/ 		__webpack_require__.a = (module, body, hasAwait) => {
/******/ 			var queue;
/******/ 			hasAwait && ((queue = []).d = -1);
/******/ 			var depQueues = new Set();
/******/ 			var exports = module.exports;
/******/ 			var currentDeps;
/******/ 			var outerResolve;
/******/ 			var reject;
/******/ 			var promise = new Promise((resolve, rej) => {
/******/ 				reject = rej;
/******/ 				outerResolve = resolve;
/******/ 			});
/******/ 			promise[webpackExports] = exports;
/******/ 			promise[webpackQueues] = (fn) => (queue && fn(queue), depQueues.forEach(fn), promise["catch"](x => {}));
/******/ 			module.exports = promise;
/******/ 			body((deps) => {
/******/ 				currentDeps = wrapDeps(deps);
/******/ 				var fn;
/******/ 				var getResult = () => (currentDeps.map((d) => {
/******/ 					if(d[webpackError]) throw d[webpackError];
/******/ 					return d[webpackExports];
/******/ 				}))
/******/ 				var promise = new Promise((resolve) => {
/******/ 					fn = () => (resolve(getResult));
/******/ 					fn.r = 0;
/******/ 					var fnQueue = (q) => (q !== queue && !depQueues.has(q) && (depQueues.add(q), q && !q.d && (fn.r++, q.push(fn))));
/******/ 					currentDeps.map((dep) => (dep[webpackQueues](fnQueue)));
/******/ 				});
/******/ 				return fn.r ? promise : getResult();
/******/ 			}, (err) => ((err ? reject(promise[webpackError] = err) : outerResolve(exports)), resolveQueue(queue)));
/******/ 			queue && queue.d < 0 && (queue.d = 0);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "gulp-builder:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 		
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module used 'module' so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/main.js");
/******/ 	
/******/ })()
;
//# sourceMappingURL=main.js.map